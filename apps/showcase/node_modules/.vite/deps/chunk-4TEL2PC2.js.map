{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/GaussianBlurNode.js"],
  "sourcesContent": ["import { RenderTarget, Vector2, NodeMaterial, RendererUtils, QuadMesh, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, uniform, convertToTexture, vec2, vec4, passTexture, premultiplyAlpha, unpremultiplyAlpha } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\nlet _rendererState;\n\n/**\n * Post processing node for creating a gaussian blur effect.\n *\n * @augments TempNode\n * @three_import import { gaussianBlur, premultipliedGaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n */\nclass GaussianBlurNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'GaussianBlurNode';\n\n\t}\n\n\t/**\n\t * Constructs a new gaussian blur node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n\t * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n\t * @param {Object} [options={}] - Additional options for the gaussian blur effect.\n\t * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.\n\t * @param {number} [options.resolutionScale=1] - The resolution of the effect. 0.5 means half the resolution of the texture node.\n\t */\n\tconstructor( textureNode, directionNode = null, sigma = 4, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Defines the direction and radius of the blur.\n\t\t *\n\t\t * @type {Node<vec2|float>}\n\t\t */\n\t\tthis.directionNode = directionNode;\n\n\t\t/**\n\t\t * Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.sigma = sigma;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\t/**\n\t\t * Gaussian blur is applied in two passes (horizontal, vertical).\n\t\t * This node controls the direction of each pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._passDirection = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The render target used for the horizontal pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._horizontalRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n\n\t\t/**\n\t\t * The render target used for the vertical pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._verticalRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._verticalRT.texture );\n\t\tthis._textureNode.uvNode = textureNode.uvNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The resolution scale.\n\t\t *\n\t\t * @type {number}\n\t\t * @default (1)\n\t\t */\n\t\tthis.resolutionScale = options.resolutionScale || 1;\n\n\t\t/**\n\t\t * Whether the effect should use premultiplied alpha or not. Set this to `true`\n\t\t * if you are going to blur texture input with transparency.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.premultipliedAlpha = options.premultipliedAlpha || false;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\twidth = Math.max( Math.round( width * this.resolutionScale ), 1 );\n\t\theight = Math.max( Math.round( height * this.resolutionScale ), 1 );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\t\tthis._horizontalRT.setSize( width, height );\n\t\tthis._verticalRT.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst currentTexture = textureNode.value;\n\n\t\t_quadMesh.material = this._material;\n\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\tconst textureType = map.type;\n\n\t\tthis._horizontalRT.texture.type = textureType;\n\t\tthis._verticalRT.texture.type = textureType;\n\n\t\t// horizontal\n\n\t\trenderer.setRenderTarget( this._horizontalRT );\n\n\t\tthis._passDirection.value.set( 1, 0 );\n\n\t\t_quadMesh.name = 'Gaussian Blur [ Horizontal Pass ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// vertical\n\n\t\ttextureNode.value = this._horizontalRT.texture;\n\t\trenderer.setRenderTarget( this._verticalRT );\n\n\t\tthis._passDirection.value.set( 0, 1 );\n\n\t\t_quadMesh.name = 'Gaussian Blur [ Vertical Pass ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\ttextureNode.value = currentTexture;\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\n\t\t//\n\n\t\tconst uvNode = uv();\n\t\tconst directionNode = vec2( this.directionNode || 1 );\n\n\t\tlet sampleTexture, output;\n\n\t\tif ( this.premultipliedAlpha ) {\n\n\t\t\t// https://lisyarus.github.io/blog/posts/blur-coefficients-generator.html\n\n\t\t\tsampleTexture = ( uv ) => premultiplyAlpha( textureNode.sample( uv ) );\n\t\t\toutput = ( color ) => unpremultiplyAlpha( color );\n\n\t\t} else {\n\n\t\t\tsampleTexture = ( uv ) => textureNode.sample( uv );\n\t\t\toutput = ( color ) => color;\n\n\t\t}\n\n\t\tconst blur = Fn( () => {\n\n\t\t\tconst kernelSize = 3 + ( 2 * this.sigma );\n\t\t\tconst gaussianCoefficients = this._getCoefficients( kernelSize );\n\n\t\t\tconst invSize = this._invSize;\n\t\t\tconst direction = directionNode.mul( this._passDirection );\n\n\t\t\tconst diffuseSum = vec4( sampleTexture( uvNode ).mul( gaussianCoefficients[ 0 ] ) ).toVar();\n\n\t\t\tfor ( let i = 1; i < kernelSize; i ++ ) {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = float( gaussianCoefficients[ i ] );\n\n\t\t\t\tconst uvOffset = vec2( direction.mul( invSize.mul( x ) ) ).toVar();\n\n\t\t\t\tconst sample1 = sampleTexture( uvNode.add( uvOffset ) );\n\t\t\t\tconst sample2 = sampleTexture( uvNode.sub( uvOffset ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\n\t\t\t}\n\n\t\t\treturn output( diffuseSum );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst material = this._material || ( this._material = new NodeMaterial() );\n\t\tmaterial.fragmentNode = blur().context( builder.getSharedContext() );\n\t\tmaterial.name = 'Gaussian_blur';\n\t\tmaterial.needsUpdate = true;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._horizontalRT.dispose();\n\t\tthis._verticalRT.dispose();\n\n\t}\n\n\t/**\n\t * Computes gaussian coefficients depending on the given kernel radius.\n\t *\n\t * @private\n\t * @param {number} kernelRadius - The kernel radius.\n\t * @return {Array<number>}\n\t */\n\t_getCoefficients( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\t\tconst sigma = kernelRadius / 3;\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\n\n\t\t}\n\n\t\treturn coefficients;\n\n\t}\n\n\t/**\n\t * The resolution scale.\n\t *\n\t * @deprecated\n\t * @type {Vector2}\n\t * @default {(1,1)}\n\t */\n\tget resolution() {\n\n\t\tconsole.warn( 'THREE.GaussianBlurNode: The \"resolution\" property has been renamed to \"resolutionScale\" and is now of type `number`.' ); // @deprecated r180\n\n\t\treturn new Vector2( this.resolutionScale, this.resolutionScale );\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tconsole.warn( 'THREE.GaussianBlurNode: The \"resolution\" property has been renamed to \"resolutionScale\" and is now of type `number`.' ); // @deprecated r180\n\n\t\tthis.resolutionScale = value.x;\n\n\t}\n\n}\n\nexport default GaussianBlurNode;\n\n/**\n * TSL function for creating a gaussian blur node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n * @param {Object} [options={}] - Additional options for the gaussian blur effect.\n * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.\n * @param {number} [options.resolutionScale=1] - The resolution of the effect. 0.5 means half the resolution of the texture node.\n * @returns {GaussianBlurNode}\n */\nexport const gaussianBlur = ( node, directionNode, sigma, options = {} ) => nodeObject( new GaussianBlurNode( convertToTexture( node ), directionNode, sigma, options ) );\n\n/**\n * TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.\n *\n * @tsl\n * @function\n * @deprecated  since r180. Use `gaussianBlur()` with `premultipliedAlpha: true` option instead.\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n * @returns {GaussianBlurNode}\n */\nexport function premultipliedGaussianBlur( node, directionNode, sigma ) {\n\n\tconsole.warn( 'THREE.TSL: \"premultipliedGaussianBlur()\" is deprecated. Use \"gaussianBlur()\" with \"premultipliedAlpha: true\" option instead.' ); // deprecated, r180\n\n\treturn gaussianBlur( node, directionNode, sigma, { premultipliedAlpha: true } );\n\n}\n"],
  "mappings": "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",
  "names": ["uv"]
}
