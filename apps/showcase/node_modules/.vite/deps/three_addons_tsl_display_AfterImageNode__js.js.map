{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/AfterImageNode.js"],
  "sourcesContent": ["import { RenderTarget, Vector2, QuadMesh, NodeMaterial, RendererUtils, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, texture, passTexture, sign, max, convertToTexture } from 'three/tsl';\n\nconst _size = /*@__PURE__*/ new Vector2();\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\nlet _rendererState;\n\n/**\n * Post processing node for creating an after image effect.\n *\n * @augments TempNode\n * @three_import import { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';\n */\nclass AfterImageNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AfterImageNode';\n\n\t}\n\n\t/**\n\t * Constructs a new after image node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node<float>} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.\n\t */\n\tconstructor( textureNode, damp = float( 0.96 ) ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * How quickly the after-image fades. A higher value means the after-image\n\t\t * persists longer, while a lower value means it fades faster. Should be in\n\t\t * the range `[0, 1]`.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.damp = damp;\n\n\t\t/**\n\t\t * The render target used for compositing the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._compRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._compRT.texture.name = 'AfterImageNode.comp';\n\n\t\t/**\n\t\t * The render target that represents the previous frame.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._oldRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._oldRT.texture.name = 'AfterImageNode.old';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._compRT.texture );\n\n\t\t/**\n\t\t * The texture represents the pervious frame.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeOld = texture( this._oldRT.texture );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._compRT.setSize( width, height );\n\t\tthis._oldRT.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst textureType = map.type;\n\n\t\tthis._compRT.texture.type = textureType;\n\t\tthis._oldRT.texture.type = textureType;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis.setSize( _size.x, _size.y );\n\n\t\t// make sure texture nodes point to correct render targets\n\n\t\tthis._textureNode.value = this._compRT.texture;\n\t\tthis._textureNodeOld.value = this._oldRT.texture;\n\n\t\t// composite\n\n\t\t_quadMesh.material = this._materialComposed;\n\t\t_quadMesh.name = 'AfterImage';\n\n\t\trenderer.setRenderTarget( this._compRT );\n\t\t_quadMesh.render( renderer );\n\n\t\t// swap\n\n\t\tconst temp = this._oldRT;\n\t\tthis._oldRT = this._compRT;\n\t\tthis._compRT = temp;\n\n\t\t//\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst textureNodeOld = this._textureNodeOld;\n\n\t\t//\n\n\t\ttextureNodeOld.uvNode = textureNode.uvNode || uv();\n\n\t\tconst afterImg = Fn( () => {\n\n\t\t\tconst texelOld = textureNodeOld.sample().toVar();\n\t\t\tconst texelNew = textureNode.sample().toVar();\n\n\t\t\tconst threshold = float( 0.1 ).toConst();\n\n\t\t\t// m acts as a mask. It's 1 if the previous pixel was \"bright enough\" (above the threshold) and 0 if it wasn't.\n\t\t\tconst m = max( sign( texelOld.sub( threshold ) ), 0.0 );\n\n\t\t\t// This is where the after-image fades:\n\t\t\t//\n\t\t\t// - If m is 0, texelOld is multiplied by 0, effectively clearing the after-image for that pixel.\n\t\t\t// - If m is 1, texelOld is multiplied by \"damp\". Since \"damp\" is between 0 and 1, this reduces the color value of\n\t\t\t// texelOld, making it darker and causing it to fade.\n\t\t\ttexelOld.mulAssign( this.damp.mul( m ) );\n\n\t\t\treturn max( texelNew, texelOld );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst materialComposed = this._materialComposed || ( this._materialComposed = new NodeMaterial() );\n\t\tmaterialComposed.name = 'AfterImage';\n\t\tmaterialComposed.fragmentNode = afterImg();\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._compRT.dispose();\n\t\tthis._oldRT.dispose();\n\n\t}\n\n}\n\n/**\n * TSL function for creating an after image node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {(Node<float>|number)} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.\n * @returns {AfterImageNode}\n */\nexport const afterImage = ( node, damp ) => nodeObject( new AfterImageNode( convertToTexture( node ), nodeObject( damp ) ) );\n\nexport default AfterImageNode;\n"],
  "mappings": "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",
  "names": []
}
