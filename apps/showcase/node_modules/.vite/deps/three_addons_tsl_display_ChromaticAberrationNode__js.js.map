{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/ChromaticAberrationNode.js"],
  "sourcesContent": ["import { Vector2, TempNode } from 'three/webgpu';\nimport {\n\tnodeObject,\n\tFn,\n\tuniform,\n\tconvertToTexture,\n\tfloat,\n\tvec4,\n\tuv,\n\tNodeUpdateType,\n} from 'three/tsl';\n\n/**\n * Post processing node for applying chromatic aberration effect.\n * This effect simulates the color fringing that occurs in real camera lenses\n * by separating and offsetting the red, green, and blue channels.\n *\n * @augments TempNode\n * @three_import import { chromaticAberration } from 'three/addons/tsl/display/ChromaticAberrationNode.js';\n */\nclass ChromaticAberrationNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ChromaticAberrationNode';\n\n\t}\n\n\t/**\n\t * Constructs a new chromatic aberration node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node} strengthNode - The strength of the chromatic aberration effect as a node.\n\t * @param {Node} centerNode - The center point of the effect as a node.\n\t * @param {Node} scaleNode - The scale factor for stepped scaling from center as a node.\n\t */\n\tconstructor( textureNode, strengthNode, centerNode, scaleNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {texture}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A node holding the strength of the effect.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.strengthNode = strengthNode;\n\n\t\t/**\n\t\t * A node holding the center point of the effect.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.centerNode = centerNode;\n\n\t\t/**\n\t\t * A node holding the scale factor for stepped scaling.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst ApplyChromaticAberration = Fn( ( [ uv, strength, center, scale ] ) => {\n\n\t\t\t// Calculate distance from center\n\t\t\tconst offset = uv.sub( center );\n\t\t\tconst distance = offset.length();\n\n\t\t\t// Create stepped scaling zones based on distance\n\t\t\t// Each channel gets different scaling steps\n\t\t\tconst redScale = float( 1.0 ).add( scale.mul( 0.02 ).mul( strength ) ); // Red channel scaled outward\n\t\t\tconst greenScale = float( 1.0 ); // Green stays at original scale\n\t\t\tconst blueScale = float( 1.0 ).sub( scale.mul( 0.02 ).mul( strength ) ); // Blue channel scaled inward\n\n\t\t\t// Create radial distortion based on distance from center\n\t\t\tconst aberrationStrength = strength.mul( distance );\n\n\t\t\t// Calculate scaled UV coordinates for each channel\n\t\t\tconst redUV = center.add( offset.mul( redScale ) );\n\t\t\tconst greenUV = center.add( offset.mul( greenScale ) );\n\t\t\tconst blueUV = center.add( offset.mul( blueScale ) );\n\n\t\t\t// Apply additional chromatic offset based on aberration strength\n\t\t\tconst rOffset = offset.mul( aberrationStrength ).mul( float( 0.01 ) );\n\t\t\tconst gOffset = offset.mul( aberrationStrength ).mul( float( 0.0 ) );\n\t\t\tconst bOffset = offset.mul( aberrationStrength ).mul( float( - 0.01 ) );\n\n\t\t\t// Final UV coordinates combining scale and chromatic aberration\n\t\t\tconst finalRedUV = redUV.add( rOffset );\n\t\t\tconst finalGreenUV = greenUV.add( gOffset );\n\t\t\tconst finalBlueUV = blueUV.add( bOffset );\n\n\t\t\t// Sample texture for each channel\n\t\t\tconst r = textureNode.sample( finalRedUV ).r;\n\t\t\tconst g = textureNode.sample( finalGreenUV ).g;\n\t\t\tconst b = textureNode.sample( finalBlueUV ).b;\n\n\t\t\t// Get original alpha\n\t\t\tconst a = textureNode.sample( uv ).a;\n\n\t\t\treturn vec4( r, g, b, a );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'ChromaticAberrationShader',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'uv', type: 'vec2' },\n\t\t\t\t{ name: 'strength', type: 'float' },\n\t\t\t\t{ name: 'center', type: 'vec2' },\n\t\t\t\t{ name: 'scale', type: 'float' },\n\t\t\t\t{ name: 'invSize', type: 'vec2' }\n\t\t\t]\n\t\t} );\n\n\t\tconst chromaticAberrationFn = Fn( () => {\n\n\t\t\treturn ApplyChromaticAberration(\n\t\t\t\tuvNode,\n\t\t\t\tthis.strengthNode,\n\t\t\t\tthis.centerNode,\n\t\t\t\tthis.scaleNode,\n\t\t\t\tthis._invSize\n\t\t\t);\n\n\t\t} );\n\n\t\tconst outputNode = chromaticAberrationFn();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ChromaticAberrationNode;\n\n/**\n * TSL function for creating a chromatic aberration node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node|number} [strength=1.0] - The strength of the chromatic aberration effect as a node or value.\n * @param {?(Node|Vector2)} [center=null] - The center point of the effect as a node or value. If null, uses screen center (0.5, 0.5).\n * @param {Node|number} [scale=1.1] - The scale factor for stepped scaling from center as a node or value.\n * @returns {ChromaticAberrationNode}\n */\nexport const chromaticAberration = ( node, strength = 1.0, center = null, scale = 1.1 ) => {\n\n\treturn nodeObject(\n\t\tnew ChromaticAberrationNode(\n\t\t\tconvertToTexture( node ),\n\t\t\tnodeObject( strength ),\n\t\t\tnodeObject( center ),\n\t\t\tnodeObject( scale )\n\t\t)\n\t);\n\n};\n"],
  "mappings": "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",
  "names": ["uv"]
}
