{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/DepthOfFieldNode.js"],
  "sourcesContent": ["import { TempNode, NodeMaterial, NodeUpdateType, RenderTarget, Vector2, HalfFloatType, RedFormat, QuadMesh, RendererUtils } from 'three/webgpu';\nimport { convertToTexture, nodeObject, Fn, uniform, smoothstep, step, texture, max, uniformArray, outputStruct, property, vec4, vec3, uv, Loop, min, mix } from 'three/tsl';\nimport { gaussianBlur } from './GaussianBlurNode.js';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nlet _rendererState;\n\n/**\n * Post processing node for creating depth of field (DOF) effect.\n *\n * References:\n * - {@link https://pixelmischiefblog.wordpress.com/2016/11/25/bokeh-depth-of-field/}\n * - {@link https://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/}\n *\n * @augments TempNode\n * @three_import import { dof } from 'three/addons/tsl/display/DepthOfFieldNode.js';\n */\nclass DepthOfFieldNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'DepthOfFieldNode';\n\n\t}\n\n\t/**\n\t * Constructs a new DOF node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node<float>} viewZNode - Represents the viewZ depth values of the scene.\n\t * @param {Node<float>} focusDistanceNode - Defines the effect's focus which is the distance along the camera's look direction in world units.\n\t * @param {Node<float>} focalLengthNode - How far an object can be from the focal plane before it goes completely out-of-focus in world units.\n\t * @param {Node<float>} bokehScaleNode - A unitless value for artistic purposes to adjust the size of the bokeh.\n\t */\n\tconstructor( textureNode, viewZNode, focusDistanceNode, focalLengthNode, bokehScaleNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Represents the viewZ depth values of the scene.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.viewZNode = viewZNode;\n\n\t\t/**\n\t\t * Defines the effect's focus which is the distance along the camera's look direction in world units.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.focusDistanceNode = focusDistanceNode;\n\n\t\t/**\n\t\t * How far an object can be from the focal plane before it goes completely out-of-focus in world units.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.focalLengthNode = focalLengthNode;\n\n\t\t/**\n\t\t * A unitless value for artistic purposes to adjust the size of the bokeh.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.bokehScaleNode = bokehScaleNode;\n\n\t\t/**\n\t\t * The inverse size of the resolution.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The render target used for the near and far field.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._CoCRT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType, format: RedFormat, count: 2 } );\n\t\tthis._CoCRT.textures[ 0 ].name = 'DepthOfField.NearField';\n\t\tthis._CoCRT.textures[ 1 ].name = 'DepthOfField.FarField';\n\n\t\t/**\n\t\t * The render target used for blurring the near field.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._CoCBlurredRT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType, format: RedFormat } );\n\t\tthis._CoCBlurredRT.texture.name = 'DepthOfField.NearFieldBlurred';\n\n\t\t/**\n\t\t * The render target used for the first blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._blur64RT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._blur64RT.texture.name = 'DepthOfField.Blur64';\n\n\t\t/**\n\t\t * The render target used for the near field's second blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._blur16NearRT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._blur16NearRT.texture.name = 'DepthOfField.Blur16Near';\n\n\t\t/**\n\t\t * The render target used for the far field's second blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._blur16FarRT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._blur16FarRT.texture.name = 'DepthOfField.Blur16Far';\n\n\t\t/**\n\t\t * The render target used for the composite\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._compositeRT = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._compositeRT.texture.name = 'DepthOfField.Composite';\n\n\t\t/**\n\t\t * The material used for the CoC/near and far fields.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._CoCMaterial = new NodeMaterial();\n\n\t\t/**\n\t\t * The material used for blurring the near field.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._CoCBlurredMaterial = new NodeMaterial();\n\n\t\t/**\n\t\t * The material used for the 64 tap blur.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._blur64Material = new NodeMaterial();\n\n\t\t/**\n\t\t * The material used for the 16 tap blur.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._blur16Material = new NodeMaterial();\n\n\t\t/**\n\t\t * The material used for the final composite.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._compositeMaterial = new NodeMaterial();\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNode = texture( this._compositeRT.texture );\n\n\t\t/**\n\t\t * The result of the CoC pass as a texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._CoCTextureNode = texture( this._CoCRT.texture );\n\n\t\t/**\n\t\t * The result of the blur64 pass as a texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._blur64TextureNode = texture( this._blur64RT.texture );\n\n\t\t/**\n\t\t * The result of the near field's blur16 pass as a texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._blur16NearTextureNode = texture( this._blur16NearRT.texture );\n\n\t\t/**\n\t\t * The result of the far field's blur16 pass as a texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._blur16FarTextureNode = texture( this._blur16FarRT.texture );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\n\t\tthis._CoCRT.setSize( width, height );\n\t\tthis._compositeRT.setSize( width, height );\n\n\t\t// blur runs in half resolution\n\n\t\tconst halfResX = Math.round( width / 2 );\n\t\tconst halfResY = Math.round( height / 2 );\n\n\t\tthis._CoCBlurredRT.setSize( halfResX, halfResY );\n\t\tthis._blur64RT.setSize( halfResX, halfResY );\n\t\tthis._blur16NearRT.setSize( halfResX, halfResY );\n\t\tthis._blur16FarRT.setSize( halfResX, halfResY );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t// resize\n\n\t\tconst map = this.textureNode.value;\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\t// save state\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t// coc\n\n\t\t_quadMesh.material = this._CoCMaterial;\n\t\trenderer.setRenderTarget( this._CoCRT );\n\t\t_quadMesh.name = 'DoF [ CoC ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur near field to avoid visible aliased edges when the near field\n\t\t// is blended with the background\n\n\t\tthis._CoCTextureNode.value = this._CoCRT.textures[ 0 ];\n\n\t\t_quadMesh.material = this._CoCBlurredMaterial;\n\t\trenderer.setRenderTarget( this._CoCBlurredRT );\n\t\t_quadMesh.name = 'DoF [ CoC Blur ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur64 near\n\n\t\tthis._CoCTextureNode.value = this._CoCBlurredRT.texture;\n\n\t\t_quadMesh.material = this._blur64Material;\n\t\trenderer.setRenderTarget( this._blur64RT );\n\t\t_quadMesh.name = 'DoF [ Blur64 Near ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur16 near\n\n\t\t_quadMesh.material = this._blur16Material;\n\t\trenderer.setRenderTarget( this._blur16NearRT );\n\t\t_quadMesh.name = 'DoF [ Blur16 Near ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur64 far\n\n\t\tthis._CoCTextureNode.value = this._CoCRT.textures[ 1 ];\n\n\t\t_quadMesh.material = this._blur64Material;\n\t\trenderer.setRenderTarget( this._blur64RT );\n\t\t_quadMesh.name = 'DoF [ Blur64 Far ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur16 far\n\n\t\t_quadMesh.material = this._blur16Material;\n\t\trenderer.setRenderTarget( this._blur16FarRT );\n\t\t_quadMesh.name = 'DoF [ Blur16 Far ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// composite\n\n\t\t_quadMesh.material = this._compositeMaterial;\n\t\trenderer.setRenderTarget( this._compositeRT );\n\t\t_quadMesh.name = 'DoF [ Composite ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( builder ) {\n\n\t\tconst kernels = this._generateKernels();\n\n\t\t// CoC, near and far fields\n\n\t\tconst nearField = property( 'float' );\n\t\tconst farField = property( 'float' );\n\n\t\tconst outputNode = outputStruct( nearField, farField );\n\n\t\tconst CoC = Fn( () => {\n\n\t\t\tconst signedDist = this.viewZNode.negate().sub( this.focusDistanceNode );\n\t\t\tconst CoC = smoothstep( 0, this.focalLengthNode, signedDist.abs() );\n\n\t\t\tnearField.assign( step( signedDist, 0 ).mul( CoC ) );\n\t\t\tfarField.assign( step( 0, signedDist ).mul( CoC ) );\n\n\t\t\treturn vec4( 0 );\n\n\t\t} );\n\n\t\tthis._CoCMaterial.colorNode = CoC().context( builder.getSharedContext() );\n\t\tthis._CoCMaterial.outputNode = outputNode;\n\t\tthis._CoCMaterial.needsUpdate = true;\n\n\t\t// blurred CoC for near field\n\n\t\tthis._CoCBlurredMaterial.colorNode = gaussianBlur( this._CoCTextureNode, 1, 2 );\n\t\tthis._CoCBlurredMaterial.needsUpdate = true;\n\n\t\t// bokeh 64 blur pass\n\n\t\tconst bokeh64 = uniformArray( kernels.points64 );\n\n\t\tconst blur64 = Fn( () => {\n\n\t\t\tconst acc = vec3();\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst CoC = this._CoCTextureNode.sample( uvNode ).r;\n\t\t\tconst sampleStep = this._invSize.mul( this.bokehScaleNode ).mul( CoC );\n\n\t\t\tLoop( 64, ( { i } ) => {\n\n\t\t\t\tconst sUV = uvNode.add( sampleStep.mul( bokeh64.element( i ) ) );\n\t\t\t\tconst tap = this.textureNode.sample( sUV );\n\n\t\t\t\tacc.addAssign( tap.rgb );\n\n\t\t\t} );\n\n\t\t\tacc.divAssign( 64 );\n\n\t\t\treturn vec4( acc, CoC );\n\n\t\t} );\n\n\t\tthis._blur64Material.fragmentNode = blur64().context( builder.getSharedContext() );\n\t\tthis._blur64Material.needsUpdate = true;\n\n\t\t// bokeh 16 blur pass\n\n\t\tconst bokeh16 = uniformArray( kernels.points16 );\n\n\t\tconst blur16 = Fn( () => {\n\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst col = this._blur64TextureNode.sample( uvNode ).toVar();\n\t\t\tconst maxVal = col.rgb;\n\t\t\tconst CoC = col.a;\n\t\t\tconst sampleStep = this._invSize.mul( this.bokehScaleNode ).mul( CoC );\n\n\t\t\tLoop( 16, ( { i } ) => {\n\n\t\t\t\tconst sUV = uvNode.add( sampleStep.mul( bokeh16.element( i ) ) );\n\t\t\t\tconst tap = this._blur64TextureNode.sample( sUV );\n\n\t\t\t\tmaxVal.assign( max( tap.rgb, maxVal ) );\n\n\t\t\t} );\n\n\t\t\treturn vec4( maxVal, CoC );\n\n\t\t} );\n\n\t\tthis._blur16Material.fragmentNode = blur16().context( builder.getSharedContext() );\n\t\tthis._blur16Material.needsUpdate = true;\n\n\t\t// composite\n\n\t\tconst composite = Fn( () => {\n\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst near = this._blur16NearTextureNode.sample( uvNode );\n\t\t\tconst far = this._blur16FarTextureNode.sample( uvNode );\n\t\t\tconst beauty = this.textureNode.sample( uvNode );\n\n\t\t\t// TODO: applying the bokeh scale to the near field CoC value introduces blending\n\t\t\t// issues around edges of blurred foreground objects when their are rendered above\n\t\t\t// the background. for now, don't apply the bokeh scale to the blend factors. that\n\t\t\t// will cause less blur for objects which are partly out-of-focus (CoC between 0 and 1).\n\n\t\t\tconst blendNear = min( near.a, 0.5 ).mul( 2 );\n\t\t\tconst blendFar = min( far.a, 0.5 ).mul( 2 );\n\n\t\t\tconst result = vec4( 0, 0, 0, 1 ).toVar();\n\t\t\tresult.rgb = mix( beauty.rgb, far.rgb, blendFar );\n\t\t\tresult.rgb = mix( result.rgb, near.rgb, blendNear );\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t\tthis._compositeMaterial.fragmentNode = composite().context( builder.getSharedContext() );\n\t\tthis._compositeMaterial.needsUpdate = true;\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t_generateKernels() {\n\n\t\t// Vogel's method, see https://www.shadertoy.com/view/4fBXRG\n\t\t// this approach allows to generate uniformly distributed sample\n\t\t// points in a disc-shaped pattern. Blurring with these samples\n\t\t// produces a typical optical lens blur\n\n\t\tconst GOLDEN_ANGLE = 2.39996323;\n\t\tconst SAMPLES = 80;\n\n\t\tconst points64 = [];\n\t\tconst points16 = [];\n\n\t\tlet idx64 = 0;\n\t\tlet idx16 = 0;\n\n\t\tfor ( let i = 0; i < SAMPLES; i ++ ) {\n\n\t\t\tconst theta = i * GOLDEN_ANGLE;\n\t\t\tconst r = Math.sqrt( i ) / Math.sqrt( SAMPLES );\n\n\t\t\tconst p = new Vector2( r * Math.cos( theta ), r * Math.sin( theta ) );\n\n\t\t\tif ( i % 5 === 0 ) {\n\n\t\t\t\tpoints16[ idx16 ] = p;\n\t\t\t\tidx16 ++;\n\n\t\t\t} else {\n\n\t\t\t\tpoints64[ idx64 ] = p;\n\t\t\t\tidx64 ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn { points16, points64 };\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._CoCRT.dispose();\n\t\tthis._CoCBlurredRT.dispose();\n\t\tthis._blur64RT.dispose();\n\t\tthis._blur16NearRT.dispose();\n\t\tthis._blur16FarRT.dispose();\n\t\tthis._compositeRT.dispose();\n\n\t\tthis._CoCMaterial.dispose();\n\t\tthis._CoCBlurredMaterial.dispose();\n\t\tthis._blur64Material.dispose();\n\t\tthis._blur16Material.dispose();\n\t\tthis._compositeMaterial.dispose();\n\n\t}\n\n}\n\nexport default DepthOfFieldNode;\n\n/**\n * TSL function for creating a depth-of-field effect (DOF) for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node<float>} viewZNode - Represents the viewZ depth values of the scene.\n * @param {Node<float> | number} focusDistance - Defines the effect's focus which is the distance along the camera's look direction in world units.\n * @param {Node<float> | number} focalLength - How far an object can be from the focal plane before it goes completely out-of-focus in world units.\n * @param {Node<float> | number} bokehScale - A unitless value for artistic purposes to adjust the size of the bokeh.\n * @returns {DepthOfFieldNode}\n */\nexport const dof = ( node, viewZNode, focusDistance = 1, focalLength = 1, bokehScale = 1 ) => nodeObject( new DepthOfFieldNode( convertToTexture( node ), nodeObject( viewZNode ), nodeObject( focusDistance ), nodeObject( focalLength ), nodeObject( bokehScale ) ) );\n"],
  "mappings": "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",
  "names": ["CoC"]
}
