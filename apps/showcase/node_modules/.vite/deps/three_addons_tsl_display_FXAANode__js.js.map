{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/FXAANode.js"],
  "sourcesContent": ["import { Vector2, TempNode } from 'three/webgpu';\nimport { nodeObject, Fn, uniformArray, select, float, NodeUpdateType, uv, dot, clamp, uniform, convertToTexture, smoothstep, bool, vec2, vec3, If, Loop, max, min, Break, abs } from 'three/tsl';\n\n/**\n * Post processing node for applying FXAA. This node requires sRGB input\n * so tone mapping and color space conversion must happen before the anti-aliasing.\n *\n * @augments TempNode\n * @three_import import { fxaa } from 'three/addons/tsl/display/FXAANode.js';\n */\nclass FXAANode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FXAANode';\n\n\t}\n\n\t/**\n\t * Constructs a new FXAA node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst textureNode = this.textureNode.bias( - 100 );\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst EDGE_STEP_COUNT = float( 6 );\n\t\tconst EDGE_GUESS = float( 8.0 );\n\t\tconst EDGE_STEPS = uniformArray( [ 1.0, 1.5, 2.0, 2.0, 2.0, 4.0 ] );\n\n\t\tconst _ContrastThreshold = float( 0.0312 );\n\t\tconst _RelativeThreshold = float( 0.063 );\n\t\tconst _SubpixelBlending = float( 1.0 );\n\n\t\tconst Sample = Fn( ( [ uv ] ) => {\n\n\t\t\treturn textureNode.sample( uv );\n\n\t\t} );\n\n\t\tconst SampleLuminance = Fn( ( [ uv ] ) => {\n\n\t\t\treturn dot( Sample( uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\n\n\t\t} );\n\n\t\tconst SampleLuminanceOffset = Fn( ( [ texSize, uv, uOffset, vOffset ] ) => {\n\n\t\t\tconst shiftedUv = uv.add( texSize.mul( vec2( uOffset, vOffset ) ) );\n\t\t\treturn SampleLuminance( shiftedUv );\n\n\t\t} );\n\n\t\tconst ShouldSkipPixel = ( l ) => {\n\n\t\t\tconst threshold = max( _ContrastThreshold, _RelativeThreshold.mul( l.highest ) );\n\t\t\treturn l.contrast.lessThan( threshold );\n\n\t\t};\n\n\t\tconst SampleLuminanceNeighborhood = ( texSize, uv ) => {\n\n\t\t\tconst m = SampleLuminance( uv );\n\n\t\t\tconst n = SampleLuminanceOffset( texSize, uv, 0.0, - 1.0 );\n\t\t\tconst e = SampleLuminanceOffset( texSize, uv, 1.0, 0.0 );\n\t\t\tconst s = SampleLuminanceOffset( texSize, uv, 0.0, 1.0 );\n\t\t\tconst w = SampleLuminanceOffset( texSize, uv, - 1.0, 0.0 );\n\n\t\t\tconst ne = SampleLuminanceOffset( texSize, uv, 1.0, - 1.0 );\n\t\t\tconst nw = SampleLuminanceOffset( texSize, uv, - 1.0, - 1.0 );\n\t\t\tconst se = SampleLuminanceOffset( texSize, uv, 1.0, 1.0 );\n\t\t\tconst sw = SampleLuminanceOffset( texSize, uv, - 1.0, 1.0 );\n\n\t\t\tconst highest = max( s, e, n, w, m );\n\t\t\tconst lowest = min( s, e, n, w, m );\n\t\t\tconst contrast = highest.sub( lowest );\n\n\t\t\treturn { m, n, e, s, w, ne, nw, se, sw, highest, lowest, contrast };\n\n\t\t};\n\n\t\tconst DeterminePixelBlendFactor = ( l ) => {\n\n\t\t\tlet f = float( 2.0 ).mul( l.s.add( l.e ).add( l.n ).add( l.w ) );\n\t\t\tf = f.add( l.se.add( l.sw ).add( l.ne ).add( l.nw ) );\n\t\t\tf = f.mul( 1.0 / 12.0 );\n\t\t\tf = abs( f.sub( l.m ) );\n\t\t\tf = clamp( f.div( max( l.contrast, 0 ) ), 0.0, 1.0 );\n\n\t\t\tconst blendFactor = smoothstep( 0.0, 1.0, f );\n\t\t\treturn blendFactor.mul( blendFactor ).mul( _SubpixelBlending );\n\n\t\t};\n\n\t\tconst DetermineEdge = ( texSize, l ) => {\n\n\t\t\tconst horizontal =\n\t\t\t\tabs( l.s.add( l.n ).sub( l.m.mul( 2.0 ) ) ).mul( 2.0 ).add(\n\t\t\t\t\tabs( l.se.add( l.ne ).sub( l.e.mul( 2.0 ) ) ).add(\n\t\t\t\t\t\tabs( l.sw.add( l.nw ).sub( l.w.mul( 2.0 ) ) )\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst vertical =\n\t\t\t\tabs( l.e.add( l.w ).sub( l.m.mul( 2.0 ) ) ).mul( 2.0 ).add(\n\t\t\t\t\tabs( l.se.add( l.sw ).sub( l.s.mul( 2.0 ) ) ).add(\n\t\t\t\t\t\tabs( l.ne.add( l.nw ).sub( l.n.mul( 2.0 ) ) )\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst isHorizontal = horizontal.greaterThanEqual( vertical );\n\n\t\t\tconst pLuminance = select( isHorizontal, l.s, l.e );\n\t\t\tconst nLuminance = select( isHorizontal, l.n, l.w );\n\t\t\tconst pGradient = abs( pLuminance.sub( l.m ) );\n\t\t\tconst nGradient = abs( nLuminance.sub( l.m ) );\n\n\t\t\tconst pixelStep = select( isHorizontal, texSize.y, texSize.x ).toVar();\n\t\t\tconst oppositeLuminance = float().toVar();\n\t\t\tconst gradient = float().toVar();\n\n\t\t\tIf( pGradient.lessThan( nGradient ), () => {\n\n\t\t\t\tpixelStep.assign( pixelStep.negate() );\n\t\t\t\toppositeLuminance.assign( nLuminance );\n\t\t\t\tgradient.assign( nGradient );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\toppositeLuminance.assign( pLuminance );\n\t\t\t\tgradient.assign( pGradient );\n\n\t\t\t} );\n\n\t\t\treturn { isHorizontal, pixelStep, oppositeLuminance, gradient };\n\n\t\t};\n\n\t\tconst DetermineEdgeBlendFactor = ( texSize, l, e, uv ) => {\n\n\t\t\tconst uvEdge = uv.toVar();\n\t\t\tconst edgeStep = vec2().toVar();\n\t\t\tIf( e.isHorizontal, () => {\n\n\t\t\t\tuvEdge.y.addAssign( e.pixelStep.mul( 0.5 ) );\n\t\t\t\tedgeStep.assign( vec2( texSize.x, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tuvEdge.x.addAssign( e.pixelStep.mul( 0.5 ) );\n\t\t\t\tedgeStep.assign( vec2( 0.0, texSize.y ) );\n\n\t\t\t} );\n\n\t\t\tconst edgeLuminance = l.m.add( e.oppositeLuminance ).mul( 0.5 );\n\t\t\tconst gradientThreshold = e.gradient.mul( 0.25 );\n\n\t\t\tconst puv = uvEdge.add( edgeStep.mul( EDGE_STEPS.element( 0 ) ) ).toVar();\n\t\t\tconst pLuminanceDelta = SampleLuminance( puv ).sub( edgeLuminance ).toVar();\n\t\t\tconst pAtEnd = abs( pLuminanceDelta ).greaterThanEqual( gradientThreshold ).toVar();\n\n\t\t\tLoop( { start: 1, end: EDGE_STEP_COUNT }, ( { i } ) => {\n\n\t\t\t\tIf( pAtEnd, () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\tpuv.addAssign( edgeStep.mul( EDGE_STEPS.element( i ) ) );\n\t\t\t\tpLuminanceDelta.assign( SampleLuminance( puv ).sub( edgeLuminance ) );\n\t\t\t\tpAtEnd.assign( abs( pLuminanceDelta ).greaterThanEqual( gradientThreshold ) );\n\n\t\t\t} );\n\n\t\t\tIf( pAtEnd.not(), () => {\n\n\t\t\t\tpuv.addAssign( edgeStep.mul( EDGE_GUESS ) );\n\n\t\t\t} );\n\n\t\t\tconst nuv = uvEdge.sub( edgeStep.mul( EDGE_STEPS.element( 0 ) ) ).toVar();\n\t\t\tconst nLuminanceDelta = SampleLuminance( nuv ).sub( edgeLuminance ).toVar();\n\t\t\tconst nAtEnd = abs( nLuminanceDelta ).greaterThanEqual( gradientThreshold ).toVar();\n\n\t\t\tLoop( { start: 1, end: EDGE_STEP_COUNT }, ( { i } ) => {\n\n\t\t\t\tIf( nAtEnd, () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\tnuv.subAssign( edgeStep.mul( EDGE_STEPS.element( i ) ) );\n\t\t\t\tnLuminanceDelta.assign( SampleLuminance( nuv ).sub( edgeLuminance ) );\n\t\t\t\tnAtEnd.assign( abs( nLuminanceDelta ).greaterThanEqual( gradientThreshold ) );\n\n\t\t\t} );\n\n\t\t\tIf( nAtEnd.not(), () => {\n\n\t\t\t\tnuv.subAssign( edgeStep.mul( EDGE_GUESS ) );\n\n\t\t\t} );\n\n\t\t\tconst pDistance = float().toVar();\n\t\t\tconst nDistance = float().toVar();\n\n\t\t\tIf( e.isHorizontal, () => {\n\n\t\t\t\tpDistance.assign( puv.x.sub( uv.x ) );\n\t\t\t\tnDistance.assign( uv.x.sub( nuv.x ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tpDistance.assign( puv.y.sub( uv.y ) );\n\t\t\t\tnDistance.assign( uv.y.sub( nuv.y ) );\n\n\t\t\t} );\n\n\t\t\tconst shortestDistance = float().toVar();\n\t\t\tconst deltaSign = bool().toVar();\n\n\t\t\tIf( pDistance.lessThanEqual( nDistance ), () => {\n\n\t\t\t\tshortestDistance.assign( pDistance );\n\t\t\t\tdeltaSign.assign( pLuminanceDelta.greaterThanEqual( 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tshortestDistance.assign( nDistance );\n\t\t\t\tdeltaSign.assign( nLuminanceDelta.greaterThanEqual( 0.0 ) );\n\n\t\t\t} );\n\n\t\t\tconst blendFactor = float().toVar();\n\n\t\t\tIf( deltaSign.equal( l.m.sub( edgeLuminance ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\tblendFactor.assign( 0.0 );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tblendFactor.assign( float( 0.5 ).sub( shortestDistance.div( pDistance.add( nDistance ) ) ) );\n\n\t\t\t} );\n\n\t\t\treturn blendFactor;\n\n\t\t};\n\n\t\tconst ApplyFXAA = Fn( ( [ uv, texSize ] ) => {\n\n\t\t\tconst luminance = SampleLuminanceNeighborhood( texSize, uv );\n\t\t\tIf( ShouldSkipPixel( luminance ), () => {\n\n\t\t\t\treturn Sample( uv );\n\n\t\t\t} );\n\n\t\t\tconst pixelBlend = DeterminePixelBlendFactor( luminance );\n\t\t\tconst edge = DetermineEdge( texSize, luminance );\n\t\t\tconst edgeBlend = DetermineEdgeBlendFactor( texSize, luminance, edge, uv );\n\n\t\t\tconst finalBlend = max( pixelBlend, edgeBlend );\n\t\t\tconst finalUv = uv.toVar();\n\n\t\t\tIf( edge.isHorizontal, () => {\n\n\t\t\t\tfinalUv.y.addAssign( edge.pixelStep.mul( finalBlend ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tfinalUv.x.addAssign( edge.pixelStep.mul( finalBlend ) );\n\n\t\t\t} );\n\n\t\t\treturn Sample( finalUv );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'FxaaPixelShader',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'uv', type: 'vec2' },\n\t\t\t\t{ name: 'texSize', type: 'vec2' },\n\t\t\t]\n\t\t} );\n\n\t\tconst fxaa = Fn( () => {\n\n\t\t\treturn ApplyFXAA( uvNode, this._invSize );\n\n\t\t} );\n\n\t\tconst outputNode = fxaa();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default FXAANode;\n\n/**\n * TSL function for creating a FXAA node for anti-aliasing via post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @returns {FXAANode}\n */\nexport const fxaa = ( node ) => nodeObject( new FXAANode( convertToTexture( node ) ) );\n"],
  "mappings": "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",
  "names": ["uv", "fxaa"]
}
