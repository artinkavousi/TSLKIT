{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/TRAANode.js"],
  "sourcesContent": ["import { HalfFloatType, Vector2, RenderTarget, RendererUtils, QuadMesh, NodeMaterial, TempNode, NodeUpdateType, Matrix4, DepthTexture } from 'three/webgpu';\nimport { add, float, If, Loop, int, Fn, min, max, clamp, nodeObject, texture, uniform, uv, vec2, vec4, luminance, convertToTexture, passTexture, velocity, getViewPosition, length } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n\n/**\n * A special node that applies TRAA (Temporal Reprojection Anti-Aliasing).\n *\n * References:\n * - {@link https://alextardif.com/TAA.html}\n * - {@link https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/}\n *\n * @augments TempNode\n * @three_import import { traa } from 'three/addons/tsl/display/TRAANode.js';\n */\nclass TRAANode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'TRAANode';\n\n\t}\n\n\t/**\n\t * Constructs a new TRAA node.\n\t *\n\t * @param {TextureNode} beautyNode - The texture node that represents the input of the effect.\n\t * @param {TextureNode} depthNode - A node that represents the scene's depth.\n\t * @param {TextureNode} velocityNode - A node that represents the scene's velocity.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( beautyNode, depthNode, velocityNode, camera ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTRAANode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.beautyNode = beautyNode;\n\n\t\t/**\n\t\t * A node that represents the scene's velocity.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the scene's velocity.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.velocityNode = velocityNode;\n\n\t\t/**\n\t\t *  The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The jitter index selects the current camera offset value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._jitterIndex = 0;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\t/**\n\t\t * A uniform node holding the camera world matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * A uniform node holding the camera projection matrix inverse.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrixInverse = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * A uniform node holding the previous frame's view matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._previousCameraWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * A uniform node holding the previous frame's projection matrix inverse.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._previousCameraProjectionMatrixInverse = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * The render target that represents the history of frame data.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t */\n\t\tthis._historyRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType, depthTexture: new DepthTexture() } );\n\t\tthis._historyRenderTarget.texture.name = 'TRAANode.history';\n\n\t\t/**\n\t\t * The render target for the resolve.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t */\n\t\tthis._resolveRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._resolveRenderTarget.texture.name = 'TRAANode.resolve';\n\n\t\t/**\n\t\t * Material used for the resolve step.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._resolveMaterial = new NodeMaterial();\n\t\tthis._resolveMaterial.name = 'TRAA.resolve';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._resolveRenderTarget.texture );\n\n\t\t/**\n\t\t * Used to save the original/unjittered projection matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis._originalProjectionMatrix = new Matrix4();\n\n\t\t/**\n\t\t * A texture node for the previous depth buffer.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._previousDepthNode = texture( new DepthTexture( 1, 1 ) );\n\n\t\t/**\n\t\t * Sync the post processing stack with the TRAA node.\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._needsPostProcessingSync = false;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._historyRenderTarget.setSize( width, height );\n\t\tthis._resolveRenderTarget.setSize( width, height );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\n\t}\n\n\t/**\n\t * Defines the TRAA's current jitter as a view offset\n\t * to the scene's camera.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetViewOffset( width, height ) {\n\n\t\t// save original/unjittered projection matrix for velocity pass\n\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis._originalProjectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\tvelocity.setProjectionMatrix( this._originalProjectionMatrix );\n\n\t\t//\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: width,\n\t\t\tfullHeight: height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: width,\n\t\t\theight: height\n\n\t\t};\n\n\t\tconst jitterOffset = _JitterVectors[ this._jitterIndex ];\n\n\t\tthis.camera.setViewOffset(\n\n\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\tviewOffset.width, viewOffset.height\n\n\t\t);\n\n\t}\n\n\t/**\n\t * Clears the view offset from the scene's camera.\n\t */\n\tclearViewOffset() {\n\n\t\tthis.camera.clearViewOffset();\n\n\t\tvelocity.setProjectionMatrix( null );\n\n\t\t// update jitter index\n\n\t\tthis._jitterIndex ++;\n\t\tthis._jitterIndex = this._jitterIndex % ( _JitterVectors.length - 1 );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t// store previous frame matrices before updating current ones\n\n\t\tthis._previousCameraWorldMatrix.value.copy( this._cameraWorldMatrix.value );\n\t\tthis._previousCameraProjectionMatrixInverse.value.copy( this._cameraProjectionMatrixInverse.value );\n\n\t\t// update camera matrices uniforms\n\n\t\tthis._cameraWorldMatrix.value.copy( this.camera.matrixWorld );\n\t\tthis._cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );\n\n\t\t// keep the TRAA in sync with the dimensions of the beauty node\n\n\t\tconst beautyRenderTarget = ( this.beautyNode.isRTTNode ) ? this.beautyNode.renderTarget : this.beautyNode.passNode.renderTarget;\n\n\t\tconst width = beautyRenderTarget.texture.width;\n\t\tconst height = beautyRenderTarget.texture.height;\n\n\t\t//\n\n\t\tif ( this._needsPostProcessingSync === true ) {\n\n\t\t\tthis.setViewOffset( width, height );\n\n\t\t\tthis._needsPostProcessingSync = false;\n\n\t\t}\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst needsRestart = this._historyRenderTarget.width !== width || this._historyRenderTarget.height !== height;\n\t\tthis.setSize( width, height );\n\n\t\t// every time when the dimensions change we need fresh history data\n\n\t\tif ( needsRestart === true ) {\n\n\t\t\t// bind and clear render target to make sure they are initialized after the resize which triggers a dispose()\n\n\t\t\trenderer.setRenderTarget( this._historyRenderTarget );\n\t\t\trenderer.clear();\n\n\t\t\trenderer.setRenderTarget( this._resolveRenderTarget );\n\t\t\trenderer.clear();\n\n\t\t\t// make sure to reset the history with the contents of the beauty buffer otherwise subsequent frames after the\n\t\t\t// resize will fade from a darker color to the correct one because the history was cleared with black.\n\n\t\t\trenderer.copyTextureToTexture( beautyRenderTarget.texture, this._historyRenderTarget.texture );\n\n\t\t}\n\n\t\t// resolve\n\n\t\trenderer.setRenderTarget( this._resolveRenderTarget );\n\t\t_quadMesh.material = this._resolveMaterial;\n\t\t_quadMesh.name = 'TRAA';\n\t\t_quadMesh.render( renderer );\n\t\trenderer.setRenderTarget( null );\n\n\t\t// update history\n\n\t\trenderer.copyTextureToTexture( this._resolveRenderTarget.texture, this._historyRenderTarget.texture );\n\n\t\t// Copy current depth to previous depth buffer\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\n\t\t// only allow the depth copy if the dimensions of the history render target match with the drawing\n\t\t// render buffer and thus the depth texture of the scene. For some reasons, there are timing issues\n\t\t// with WebGPU resulting in different size of the drawing buffer and the beauty render target when\n\t\t// resizing the browser window. This does not happen with the WebGL backend\n\n\t\tif ( this._historyRenderTarget.height === size.height && this._historyRenderTarget.width === size.width ) {\n\n\t\t\tconst currentDepth = this.depthNode.value;\n\t\t\trenderer.copyTextureToTexture( currentDepth, this._historyRenderTarget.depthTexture );\n\t\t\tthis._previousDepthNode.value = this._historyRenderTarget.depthTexture;\n\n\t\t}\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's render targets and TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst postProcessing = builder.context.postProcessing;\n\n\t\tif ( postProcessing ) {\n\n\t\t\tthis._needsPostProcessingSync = true;\n\n\t\t\tpostProcessing.context.onBeforePostProcessing = () => {\n\n\t\t\t\tconst size = builder.renderer.getDrawingBufferSize( _size );\n\t\t\t\tthis.setViewOffset( size.width, size.height );\n\n\t\t\t};\n\n\t\t\tpostProcessing.context.onAfterPostProcessing = () => {\n\n\t\t\t\tthis.clearViewOffset();\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst historyTexture = texture( this._historyRenderTarget.texture );\n\t\tconst sampleTexture = this.beautyNode;\n\t\tconst depthTexture = this.depthNode;\n\t\tconst velocityTexture = this.velocityNode;\n\n\t\tconst resolve = Fn( () => {\n\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst minColor = vec4( 10000 ).toVar();\n\t\t\tconst maxColor = vec4( - 10000 ).toVar();\n\t\t\tconst closestDepth = float( 1 ).toVar();\n\t\t\tconst farthestDepth = float( 0 ).toVar();\n\t\t\tconst closestDepthPixelPosition = vec2( 0 ).toVar();\n\n\t\t\t// sample a 3x3 neighborhood to create a box in color space\n\t\t\t// clamping the history color with the resulting min/max colors mitigates ghosting\n\n\t\t\tLoop( { start: int( - 1 ), end: int( 1 ), type: 'int', condition: '<=', name: 'x' }, ( { x } ) => {\n\n\t\t\t\tLoop( { start: int( - 1 ), end: int( 1 ), type: 'int', condition: '<=', name: 'y' }, ( { y } ) => {\n\n\t\t\t\t\tconst uvNeighbor = uvNode.add( vec2( float( x ), float( y ) ).mul( this._invSize ) ).toVar();\n\t\t\t\t\tconst colorNeighbor = max( vec4( 0 ), sampleTexture.sample( uvNeighbor ) ).toVar(); // use max() to avoid propagate garbage values\n\n\t\t\t\t\tminColor.assign( min( minColor, colorNeighbor ) );\n\t\t\t\t\tmaxColor.assign( max( maxColor, colorNeighbor ) );\n\n\t\t\t\t\tconst currentDepth = depthTexture.sample( uvNeighbor ).r.toVar();\n\n\t\t\t\t\t// find the sample position of the closest depth in the neighborhood (used for velocity)\n\n\t\t\t\t\tIf( currentDepth.lessThan( closestDepth ), () => {\n\n\t\t\t\t\t\tclosestDepth.assign( currentDepth );\n\t\t\t\t\t\tclosestDepthPixelPosition.assign( uvNeighbor );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// find the farthest depth in the neighborhood (used to preserve edge anti-aliasing)\n\n\t\t\t\t\tIf( currentDepth.greaterThan( farthestDepth ), () => {\n\n\t\t\t\t\t\tfarthestDepth.assign( currentDepth );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\t// sampling/reprojection\n\n\t\t\tconst offset = velocityTexture.sample( closestDepthPixelPosition ).xy.mul( vec2( 0.5, - 0.5 ) ); // NDC to uv offset\n\n\t\t\tconst currentColor = sampleTexture.sample( uvNode );\n\t\t\tconst historyColor = historyTexture.sample( uvNode.sub( offset ) );\n\n\t\t\t// clamping\n\n\t\t\tconst clampedHistoryColor = clamp( historyColor, minColor, maxColor );\n\n\t\t\t// calculate current frame world position\n\n\t\t\tconst currentDepth = depthTexture.sample( uvNode ).r;\n\t\t\tconst currentViewPosition = getViewPosition( uvNode, currentDepth, this._cameraProjectionMatrixInverse );\n\t\t\tconst currentWorldPosition = this._cameraWorldMatrix.mul( vec4( currentViewPosition, 1.0 ) ).xyz;\n\n\t\t\t// calculate previous frame world position from history UV and previous depth\n\n\t\t\tconst historyUV = uvNode.sub( offset );\n\t\t\tconst previousDepth = this._previousDepthNode.sample( historyUV ).r;\n\t\t\tconst previousViewPosition = getViewPosition( historyUV, previousDepth, this._previousCameraProjectionMatrixInverse );\n\t\t\tconst previousWorldPosition = this._previousCameraWorldMatrix.mul( vec4( previousViewPosition, 1.0 ) ).xyz;\n\n\t\t\t// calculate difference in world positions\n\n\t\t\tconst worldPositionDifference = length( currentWorldPosition.sub( previousWorldPosition ) ).toVar();\n\t\t\tworldPositionDifference.assign( min( max( worldPositionDifference.sub( 1.0 ), 0.0 ), 1.0 ) );\n\n\t\t\t// Adaptive blend weights based on velocity magnitude suggested by CLAUDE in #32133\n\t\t\t// Higher velocity or position difference = more weight on current frame to reduce ghosting\n\n\t\t\tconst velocityMagnitude = length( offset ).toConst();\n\t\t\tconst motionFactor = max( worldPositionDifference.mul( 0.5 ), velocityMagnitude.mul( 10.0 ) ).toVar();\n\t\t\tmotionFactor.assign( min( motionFactor, 1.0 ) );\n\n\t\t\tconst currentWeight = float( 0.05 ).add( motionFactor.mul( 0.25 ) ).toVar();\n\t\t\tconst historyWeight = currentWeight.oneMinus().toVar();\n\n\t\t\t// zero out history weight if world positions are different (indicating motion) except on edges.\n\t\t\t// note that the constants 0.00001 and 0.5 were suggested by CLAUDE in #32133\n\n\t\t\tconst isEdge = farthestDepth.sub( closestDepth ).greaterThan( 0.00001 );\n\t\t\tconst strongDisocclusion = worldPositionDifference.greaterThan( 0.5 ).and( isEdge.not() );\n\n\t\t\tIf( strongDisocclusion, () => {\n\n\t\t\t\tcurrentWeight.assign( 1.0 );\n\t\t\t\thistoryWeight.assign( 0.0 );\n\n\t\t\t} );\n\n\t\t\t// flicker reduction based on luminance weighing\n\n\t\t\tconst compressedCurrent = currentColor.mul( float( 1 ).div( ( max( currentColor.r, currentColor.g, currentColor.b ).add( 1.0 ) ) ) );\n\t\t\tconst compressedHistory = clampedHistoryColor.mul( float( 1 ).div( ( max( clampedHistoryColor.r, clampedHistoryColor.g, clampedHistoryColor.b ).add( 1.0 ) ) ) );\n\n\t\t\tconst luminanceCurrent = luminance( compressedCurrent.rgb );\n\t\t\tconst luminanceHistory = luminance( compressedHistory.rgb );\n\n\t\t\tcurrentWeight.mulAssign( float( 1.0 ).div( luminanceCurrent.add( 1 ) ) );\n\t\t\thistoryWeight.mulAssign( float( 1.0 ).div( luminanceHistory.add( 1 ) ) );\n\n\t\t\tconst smoothedOutput = add( currentColor.mul( currentWeight ), clampedHistoryColor.mul( historyWeight ) ).div( max( currentWeight.add( historyWeight ), 0.00001 ) ).toVar();\n\n\t\t\treturn smoothedOutput;\n\n\t\t} );\n\n\t\t// materials\n\n\t\tthis._resolveMaterial.colorNode = resolve();\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._historyRenderTarget.dispose();\n\t\tthis._resolveRenderTarget.dispose();\n\n\t\tthis._resolveMaterial.dispose();\n\n\t}\n\n}\n\nexport default TRAANode;\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n];\n\n/**\n * TSL function for creating a TRAA node for Temporal Reprojection Anti-Aliasing.\n *\n * @tsl\n * @function\n * @param {TextureNode} beautyNode - The texture node that represents the input of the effect.\n * @param {TextureNode} depthNode - A node that represents the scene's depth.\n * @param {TextureNode} velocityNode - A node that represents the scene's velocity.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @returns {TRAANode}\n */\nexport const traa = ( beautyNode, depthNode, velocityNode, camera ) => nodeObject( new TRAANode( convertToTexture( beautyNode ), depthNode, velocityNode, camera ) );\n"],
  "mappings": "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",
  "names": ["currentDepth"]
}
