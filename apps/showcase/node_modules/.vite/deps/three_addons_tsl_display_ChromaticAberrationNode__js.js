import {
  Fn,
  NodeUpdateType,
  convertToTexture,
  float,
  nodeObject,
  uniform,
  uv,
  vec4
} from "./chunk-KPFVNXSK.js";
import {
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  Vector2
} from "./chunk-XFHY3IS3.js";
import "./chunk-PZ5AY32C.js";

// node_modules/three/examples/jsm/tsl/display/ChromaticAberrationNode.js
var ChromaticAberrationNode = class extends TempNode {
  static get type() {
    return "ChromaticAberrationNode";
  }
  /**
   * Constructs a new chromatic aberration node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the input of the effect.
   * @param {Node} strengthNode - The strength of the chromatic aberration effect as a node.
   * @param {Node} centerNode - The center point of the effect as a node.
   * @param {Node} scaleNode - The scale factor for stepped scaling from center as a node.
   */
  constructor(textureNode, strengthNode, centerNode, scaleNode) {
    super("vec4");
    this.textureNode = textureNode;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.strengthNode = strengthNode;
    this.centerNode = centerNode;
    this.scaleNode = scaleNode;
    this._invSize = uniform(new Vector2());
  }
  /**
   * This method is used to update the effect's uniforms once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore() {
    const map = this.textureNode.value;
    this._invSize.value.set(1 / map.image.width, 1 / map.image.height);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ShaderCallNodeInternal}
   */
  setup() {
    const textureNode = this.textureNode;
    const uvNode = textureNode.uvNode || uv();
    const ApplyChromaticAberration = Fn(([uv2, strength, center, scale]) => {
      const offset = uv2.sub(center);
      const distance = offset.length();
      const redScale = float(1).add(scale.mul(0.02).mul(strength));
      const greenScale = float(1);
      const blueScale = float(1).sub(scale.mul(0.02).mul(strength));
      const aberrationStrength = strength.mul(distance);
      const redUV = center.add(offset.mul(redScale));
      const greenUV = center.add(offset.mul(greenScale));
      const blueUV = center.add(offset.mul(blueScale));
      const rOffset = offset.mul(aberrationStrength).mul(float(0.01));
      const gOffset = offset.mul(aberrationStrength).mul(float(0));
      const bOffset = offset.mul(aberrationStrength).mul(float(-0.01));
      const finalRedUV = redUV.add(rOffset);
      const finalGreenUV = greenUV.add(gOffset);
      const finalBlueUV = blueUV.add(bOffset);
      const r = textureNode.sample(finalRedUV).r;
      const g = textureNode.sample(finalGreenUV).g;
      const b = textureNode.sample(finalBlueUV).b;
      const a = textureNode.sample(uv2).a;
      return vec4(r, g, b, a);
    }).setLayout({
      name: "ChromaticAberrationShader",
      type: "vec4",
      inputs: [
        { name: "uv", type: "vec2" },
        { name: "strength", type: "float" },
        { name: "center", type: "vec2" },
        { name: "scale", type: "float" },
        { name: "invSize", type: "vec2" }
      ]
    });
    const chromaticAberrationFn = Fn(() => {
      return ApplyChromaticAberration(
        uvNode,
        this.strengthNode,
        this.centerNode,
        this.scaleNode,
        this._invSize
      );
    });
    const outputNode = chromaticAberrationFn();
    return outputNode;
  }
};
var ChromaticAberrationNode_default = ChromaticAberrationNode;
var chromaticAberration = (node, strength = 1, center = null, scale = 1.1) => {
  return nodeObject(
    new ChromaticAberrationNode(
      convertToTexture(node),
      nodeObject(strength),
      nodeObject(center),
      nodeObject(scale)
    )
  );
};
export {
  chromaticAberration,
  ChromaticAberrationNode_default as default
};
//# sourceMappingURL=three_addons_tsl_display_ChromaticAberrationNode__js.js.map
