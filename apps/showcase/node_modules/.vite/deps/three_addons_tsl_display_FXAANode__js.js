import {
  Break,
  Fn,
  If,
  Loop,
  NodeUpdateType,
  abs,
  bool,
  clamp,
  convertToTexture,
  dot,
  float,
  max,
  min,
  nodeObject,
  select,
  smoothstep,
  uniform,
  uniformArray,
  uv,
  vec2,
  vec3
} from "./chunk-KPFVNXSK.js";
import {
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  Vector2
} from "./chunk-XFHY3IS3.js";
import "./chunk-PZ5AY32C.js";

// node_modules/three/examples/jsm/tsl/display/FXAANode.js
var FXAANode = class extends TempNode {
  static get type() {
    return "FXAANode";
  }
  /**
   * Constructs a new FXAA node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the input of the effect.
   */
  constructor(textureNode) {
    super("vec4");
    this.textureNode = textureNode;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._invSize = uniform(new Vector2());
  }
  /**
   * This method is used to update the effect's uniforms once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore() {
    const map = this.textureNode.value;
    this._invSize.value.set(1 / map.image.width, 1 / map.image.height);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ShaderCallNodeInternal}
   */
  setup() {
    const textureNode = this.textureNode.bias(-100);
    const uvNode = textureNode.uvNode || uv();
    const EDGE_STEP_COUNT = float(6);
    const EDGE_GUESS = float(8);
    const EDGE_STEPS = uniformArray([1, 1.5, 2, 2, 2, 4]);
    const _ContrastThreshold = float(0.0312);
    const _RelativeThreshold = float(0.063);
    const _SubpixelBlending = float(1);
    const Sample = Fn(([uv2]) => {
      return textureNode.sample(uv2);
    });
    const SampleLuminance = Fn(([uv2]) => {
      return dot(Sample(uv2).rgb, vec3(0.3, 0.59, 0.11));
    });
    const SampleLuminanceOffset = Fn(([texSize, uv2, uOffset, vOffset]) => {
      const shiftedUv = uv2.add(texSize.mul(vec2(uOffset, vOffset)));
      return SampleLuminance(shiftedUv);
    });
    const ShouldSkipPixel = (l) => {
      const threshold = max(_ContrastThreshold, _RelativeThreshold.mul(l.highest));
      return l.contrast.lessThan(threshold);
    };
    const SampleLuminanceNeighborhood = (texSize, uv2) => {
      const m = SampleLuminance(uv2);
      const n = SampleLuminanceOffset(texSize, uv2, 0, -1);
      const e = SampleLuminanceOffset(texSize, uv2, 1, 0);
      const s = SampleLuminanceOffset(texSize, uv2, 0, 1);
      const w = SampleLuminanceOffset(texSize, uv2, -1, 0);
      const ne = SampleLuminanceOffset(texSize, uv2, 1, -1);
      const nw = SampleLuminanceOffset(texSize, uv2, -1, -1);
      const se = SampleLuminanceOffset(texSize, uv2, 1, 1);
      const sw = SampleLuminanceOffset(texSize, uv2, -1, 1);
      const highest = max(s, e, n, w, m);
      const lowest = min(s, e, n, w, m);
      const contrast = highest.sub(lowest);
      return { m, n, e, s, w, ne, nw, se, sw, highest, lowest, contrast };
    };
    const DeterminePixelBlendFactor = (l) => {
      let f = float(2).mul(l.s.add(l.e).add(l.n).add(l.w));
      f = f.add(l.se.add(l.sw).add(l.ne).add(l.nw));
      f = f.mul(1 / 12);
      f = abs(f.sub(l.m));
      f = clamp(f.div(max(l.contrast, 0)), 0, 1);
      const blendFactor = smoothstep(0, 1, f);
      return blendFactor.mul(blendFactor).mul(_SubpixelBlending);
    };
    const DetermineEdge = (texSize, l) => {
      const horizontal = abs(l.s.add(l.n).sub(l.m.mul(2))).mul(2).add(
        abs(l.se.add(l.ne).sub(l.e.mul(2))).add(
          abs(l.sw.add(l.nw).sub(l.w.mul(2)))
        )
      );
      const vertical = abs(l.e.add(l.w).sub(l.m.mul(2))).mul(2).add(
        abs(l.se.add(l.sw).sub(l.s.mul(2))).add(
          abs(l.ne.add(l.nw).sub(l.n.mul(2)))
        )
      );
      const isHorizontal = horizontal.greaterThanEqual(vertical);
      const pLuminance = select(isHorizontal, l.s, l.e);
      const nLuminance = select(isHorizontal, l.n, l.w);
      const pGradient = abs(pLuminance.sub(l.m));
      const nGradient = abs(nLuminance.sub(l.m));
      const pixelStep = select(isHorizontal, texSize.y, texSize.x).toVar();
      const oppositeLuminance = float().toVar();
      const gradient = float().toVar();
      If(pGradient.lessThan(nGradient), () => {
        pixelStep.assign(pixelStep.negate());
        oppositeLuminance.assign(nLuminance);
        gradient.assign(nGradient);
      }).Else(() => {
        oppositeLuminance.assign(pLuminance);
        gradient.assign(pGradient);
      });
      return { isHorizontal, pixelStep, oppositeLuminance, gradient };
    };
    const DetermineEdgeBlendFactor = (texSize, l, e, uv2) => {
      const uvEdge = uv2.toVar();
      const edgeStep = vec2().toVar();
      If(e.isHorizontal, () => {
        uvEdge.y.addAssign(e.pixelStep.mul(0.5));
        edgeStep.assign(vec2(texSize.x, 0));
      }).Else(() => {
        uvEdge.x.addAssign(e.pixelStep.mul(0.5));
        edgeStep.assign(vec2(0, texSize.y));
      });
      const edgeLuminance = l.m.add(e.oppositeLuminance).mul(0.5);
      const gradientThreshold = e.gradient.mul(0.25);
      const puv = uvEdge.add(edgeStep.mul(EDGE_STEPS.element(0))).toVar();
      const pLuminanceDelta = SampleLuminance(puv).sub(edgeLuminance).toVar();
      const pAtEnd = abs(pLuminanceDelta).greaterThanEqual(gradientThreshold).toVar();
      Loop({ start: 1, end: EDGE_STEP_COUNT }, ({ i }) => {
        If(pAtEnd, () => {
          Break();
        });
        puv.addAssign(edgeStep.mul(EDGE_STEPS.element(i)));
        pLuminanceDelta.assign(SampleLuminance(puv).sub(edgeLuminance));
        pAtEnd.assign(abs(pLuminanceDelta).greaterThanEqual(gradientThreshold));
      });
      If(pAtEnd.not(), () => {
        puv.addAssign(edgeStep.mul(EDGE_GUESS));
      });
      const nuv = uvEdge.sub(edgeStep.mul(EDGE_STEPS.element(0))).toVar();
      const nLuminanceDelta = SampleLuminance(nuv).sub(edgeLuminance).toVar();
      const nAtEnd = abs(nLuminanceDelta).greaterThanEqual(gradientThreshold).toVar();
      Loop({ start: 1, end: EDGE_STEP_COUNT }, ({ i }) => {
        If(nAtEnd, () => {
          Break();
        });
        nuv.subAssign(edgeStep.mul(EDGE_STEPS.element(i)));
        nLuminanceDelta.assign(SampleLuminance(nuv).sub(edgeLuminance));
        nAtEnd.assign(abs(nLuminanceDelta).greaterThanEqual(gradientThreshold));
      });
      If(nAtEnd.not(), () => {
        nuv.subAssign(edgeStep.mul(EDGE_GUESS));
      });
      const pDistance = float().toVar();
      const nDistance = float().toVar();
      If(e.isHorizontal, () => {
        pDistance.assign(puv.x.sub(uv2.x));
        nDistance.assign(uv2.x.sub(nuv.x));
      }).Else(() => {
        pDistance.assign(puv.y.sub(uv2.y));
        nDistance.assign(uv2.y.sub(nuv.y));
      });
      const shortestDistance = float().toVar();
      const deltaSign = bool().toVar();
      If(pDistance.lessThanEqual(nDistance), () => {
        shortestDistance.assign(pDistance);
        deltaSign.assign(pLuminanceDelta.greaterThanEqual(0));
      }).Else(() => {
        shortestDistance.assign(nDistance);
        deltaSign.assign(nLuminanceDelta.greaterThanEqual(0));
      });
      const blendFactor = float().toVar();
      If(deltaSign.equal(l.m.sub(edgeLuminance).greaterThanEqual(0)), () => {
        blendFactor.assign(0);
      }).Else(() => {
        blendFactor.assign(float(0.5).sub(shortestDistance.div(pDistance.add(nDistance))));
      });
      return blendFactor;
    };
    const ApplyFXAA = Fn(([uv2, texSize]) => {
      const luminance = SampleLuminanceNeighborhood(texSize, uv2);
      If(ShouldSkipPixel(luminance), () => {
        return Sample(uv2);
      });
      const pixelBlend = DeterminePixelBlendFactor(luminance);
      const edge = DetermineEdge(texSize, luminance);
      const edgeBlend = DetermineEdgeBlendFactor(texSize, luminance, edge, uv2);
      const finalBlend = max(pixelBlend, edgeBlend);
      const finalUv = uv2.toVar();
      If(edge.isHorizontal, () => {
        finalUv.y.addAssign(edge.pixelStep.mul(finalBlend));
      }).Else(() => {
        finalUv.x.addAssign(edge.pixelStep.mul(finalBlend));
      });
      return Sample(finalUv);
    }).setLayout({
      name: "FxaaPixelShader",
      type: "vec4",
      inputs: [
        { name: "uv", type: "vec2" },
        { name: "texSize", type: "vec2" }
      ]
    });
    const fxaa2 = Fn(() => {
      return ApplyFXAA(uvNode, this._invSize);
    });
    const outputNode = fxaa2();
    return outputNode;
  }
};
var FXAANode_default = FXAANode;
var fxaa = (node) => nodeObject(new FXAANode(convertToTexture(node)));
export {
  FXAANode_default as default,
  fxaa
};
//# sourceMappingURL=three_addons_tsl_display_FXAANode__js.js.map
