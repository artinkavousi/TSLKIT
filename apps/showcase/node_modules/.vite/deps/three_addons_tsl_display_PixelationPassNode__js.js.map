{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/PixelationPassNode.js"],
  "sourcesContent": ["import { NearestFilter, Vector4, TempNode, NodeUpdateType, PassNode } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, uniform, convertToTexture, vec2, vec3, clamp, floor, dot, smoothstep, If, sign, step, mrt, output, normalView, property } from 'three/tsl';\n\n/**\n * A inner node definition that implements the actual pixelation TSL code.\n *\n * @inner\n * @augments TempNode\n */\nclass PixelationNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PixelationNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pixelation node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the beauty pass.\n\t * @param {TextureNode} depthNode - The texture that represents the beauty's depth.\n\t * @param {TextureNode} normalNode - The texture that represents the beauty's normals.\n\t * @param {Node<float>} pixelSize - The pixel size.\n\t * @param {Node<float>} normalEdgeStrength - The normal edge strength.\n\t * @param {Node<float>} depthEdgeStrength - The depth edge strength.\n\t */\n\tconstructor( textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the beauty pass.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The texture that represents the beauty's depth.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * The texture that represents the beauty's normals.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t\t/**\n\t\t * The pixel size.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.pixelSize = pixelSize;\n\n\t\t/**\n\t\t * The pixel size.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.normalEdgeStrength = normalEdgeStrength;\n\n\t\t/**\n\t\t * The depth edge strength.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.depthEdgeStrength = depthEdgeStrength;\n\n\t\t/**\n\t\t * Uniform node that represents the resolution.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis._resolution = uniform( new Vector4() );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * This method is used to update uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore() {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tconst width = map.image.width;\n\t\tconst height = map.image.height;\n\n\t\tthis._resolution.value.set( width, height, 1 / width, 1 / height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup() {\n\n\t\tconst { textureNode, depthNode, normalNode } = this;\n\n\t\tconst uvNodeTexture = textureNode.uvNode || uv();\n\t\tconst uvNodeDepth = depthNode.uvNode || uv();\n\t\tconst uvNodeNormal = normalNode.uvNode || uv();\n\n\t\tconst sampleTexture = () => textureNode.sample( uvNodeTexture );\n\n\t\tconst sampleDepth = ( x, y ) => depthNode.sample( uvNodeDepth.add( vec2( x, y ).mul( this._resolution.zw ) ) ).r;\n\n\t\tconst sampleNormal = ( x, y ) => normalNode.sample( uvNodeNormal.add( vec2( x, y ).mul( this._resolution.zw ) ) ).rgb.normalize();\n\n\t\tconst depthEdgeIndicator = ( depth ) => {\n\n\t\t\tconst diff = property( 'float', 'diff' );\n\t\t\tdiff.addAssign( clamp( sampleDepth( 1, 0 ).sub( depth ) ) );\n\t\t\tdiff.addAssign( clamp( sampleDepth( - 1, 0 ).sub( depth ) ) );\n\t\t\tdiff.addAssign( clamp( sampleDepth( 0, 1 ).sub( depth ) ) );\n\t\t\tdiff.addAssign( clamp( sampleDepth( 0, - 1 ).sub( depth ) ) );\n\n\t\t\treturn floor( smoothstep( 0.01, 0.02, diff ).mul( 2 ) ).div( 2 );\n\n\t\t};\n\n\t\tconst neighborNormalEdgeIndicator = ( x, y, depth, normal ) => {\n\n\t\t\tconst depthDiff = sampleDepth( x, y ).sub( depth );\n\t\t\tconst neighborNormal = sampleNormal( x, y );\n\n\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\n\t\t\tconst normalEdgeBias = vec3( 1, 1, 1 ); // This should probably be a parameter.\n\t\t\tconst normalDiff = dot( normal.sub( neighborNormal ), normalEdgeBias );\n\t\t\tconst normalIndicator = clamp( smoothstep( - 0.01, 0.01, normalDiff ), 0.0, 1.0 );\n\n\t\t\t// Only the shallower pixel should detect the normal edge.\n\n\t\t\tconst depthIndicator = clamp( sign( depthDiff.mul( .25 ).add( .0025 ) ), 0.0, 1.0 );\n\n\t\t\treturn float( 1.0 ).sub( dot( normal, neighborNormal ) ).mul( depthIndicator ).mul( normalIndicator );\n\n\t\t};\n\n\t\tconst normalEdgeIndicator = ( depth, normal ) => {\n\n\t\t\tconst indicator = property( 'float', 'indicator' );\n\n\t\t\tindicator.addAssign( neighborNormalEdgeIndicator( 0, - 1, depth, normal ) );\n\t\t\tindicator.addAssign( neighborNormalEdgeIndicator( 0, 1, depth, normal ) );\n\t\t\tindicator.addAssign( neighborNormalEdgeIndicator( - 1, 0, depth, normal ) );\n\t\t\tindicator.addAssign( neighborNormalEdgeIndicator( 1, 0, depth, normal ) );\n\n\t\t\treturn step( 0.1, indicator );\n\n\t\t};\n\n\t\tconst pixelation = Fn( () => {\n\n\t\t\tconst texel = sampleTexture();\n\n\t\t\tconst depth = property( 'float', 'depth' );\n\t\t\tconst normal = property( 'vec3', 'normal' );\n\n\t\t\tIf( this.depthEdgeStrength.greaterThan( 0.0 ).or( this.normalEdgeStrength.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\tdepth.assign( sampleDepth( 0, 0 ) );\n\t\t\t\tnormal.assign( sampleNormal( 0, 0 ) );\n\n\t\t\t} );\n\n\t\t\tconst dei = property( 'float', 'dei' );\n\n\t\t\tIf( this.depthEdgeStrength.greaterThan( 0.0 ), () => {\n\n\t\t\t\tdei.assign( depthEdgeIndicator( depth ) );\n\n\t\t\t} );\n\n\t\t\tconst nei = property( 'float', 'nei' );\n\n\t\t\tIf( this.normalEdgeStrength.greaterThan( 0.0 ), () => {\n\n\t\t\t\tnei.assign( normalEdgeIndicator( depth, normal ) );\n\n\t\t\t} );\n\n\t\t\tconst strength = dei.greaterThan( 0 ).select( float( 1.0 ).sub( dei.mul( this.depthEdgeStrength ) ), nei.mul( this.normalEdgeStrength ).add( 1 ) );\n\n\t\t\treturn texel.mul( strength );\n\n\t\t} );\n\n\t\tconst outputNode = pixelation();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst pixelation = ( node, depthNode, normalNode, pixelSize = 6, normalEdgeStrength = 0.3, depthEdgeStrength = 0.4 ) => nodeObject( new PixelationNode( convertToTexture( node ), convertToTexture( depthNode ), convertToTexture( normalNode ), nodeObject( pixelSize ), nodeObject( normalEdgeStrength ), nodeObject( depthEdgeStrength ) ) );\n\n/**\n * A special render pass node that renders the scene with a pixelation effect.\n *\n * @augments PassNode\n * @three_import import { pixelationPass } from 'three/addons/tsl/display/PixelationPassNode.js';\n */\nclass PixelationPassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'PixelationPassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pixelation pass node.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @param {Node<float> | number} [pixelSize=6] - The pixel size.\n\t * @param {Node<float> | number} [normalEdgeStrength=0.3] - The normal edge strength.\n\t * @param {Node<float> | number} [depthEdgeStrength=0.4] - The depth edge strength.\n\t */\n\tconstructor( scene, camera, pixelSize = 6, normalEdgeStrength = 0.3, depthEdgeStrength = 0.4 ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera, { minFilter: NearestFilter, magFilter: NearestFilter } );\n\n\t\t/**\n\t\t * The pixel size.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 6\n\t\t */\n\t\tthis.pixelSize = pixelSize;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.3\n\t\t */\n\t\tthis.normalEdgeStrength = normalEdgeStrength;\n\n\t\t/**\n\t\t * The depth edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.4\n\t\t */\n\t\tthis.depthEdgeStrength = depthEdgeStrength;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPixelationPassNode = true;\n\n\t\tthis._mrt = mrt( {\n\t\t\toutput: output,\n\t\t\tnormal: normalView\n\t\t} );\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width of the pass.\n\t * @param {number} height - The height of the pass.\n\t */\n\tsetSize( width, height ) {\n\n\t\tconst pixelSize = this.pixelSize.value ? this.pixelSize.value : this.pixelSize;\n\n\t\tconst adjustedWidth = Math.floor( width / pixelSize );\n\t\tconst adjustedHeight = Math.floor( height / pixelSize );\n\n\t\tsuper.setSize( adjustedWidth, adjustedHeight );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PixelationNode}\n\t */\n\tsetup() {\n\n\t\tconst color = super.getTextureNode( 'output' );\n\t\tconst depth = super.getTextureNode( 'depth' );\n\t\tconst normal = super.getTextureNode( 'normal' );\n\n\t\treturn pixelation( color, depth, normal, this.pixelSize, this.normalEdgeStrength, this.depthEdgeStrength );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a pixelation render pass node for post processing.\n *\n * @tsl\n * @function\n * @param {Scene} scene - The scene to render.\n * @param {Camera} camera - The camera to render the scene with.\n * @param {Node<float> | number} [pixelSize=6] - The pixel size.\n * @param {Node<float> | number} [normalEdgeStrength=0.3] - The normal edge strength.\n * @param {Node<float> | number} [depthEdgeStrength=0.4] - The depth edge strength.\n * @returns {PixelationPassNode}\n */\nexport const pixelationPass = ( scene, camera, pixelSize, normalEdgeStrength, depthEdgeStrength ) => nodeObject( new PixelationPassNode( scene, camera, pixelSize, normalEdgeStrength, depthEdgeStrength ) );\n\nexport default PixelationPassNode;\n"],
  "mappings": "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",
  "names": ["pixelation"]
}
