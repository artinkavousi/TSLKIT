import {
  Fn,
  convertToTexture,
  float,
  nodeObject,
  passTexture,
  premultiplyAlpha,
  uniform,
  unpremultiplyAlpha,
  uv,
  vec2,
  vec4
} from "./chunk-KPFVNXSK.js";
import {
  NodeMaterial,
  NodeUpdateType,
  QuadMesh,
  RendererUtils,
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  RenderTarget,
  Vector2
} from "./chunk-XFHY3IS3.js";

// node_modules/three/examples/jsm/tsl/display/GaussianBlurNode.js
var _quadMesh = new QuadMesh();
var _rendererState;
var GaussianBlurNode = class extends TempNode {
  static get type() {
    return "GaussianBlurNode";
  }
  /**
   * Constructs a new gaussian blur node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the input of the effect.
   * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.
   * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.
   * @param {Object} [options={}] - Additional options for the gaussian blur effect.
   * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.
   * @param {number} [options.resolutionScale=1] - The resolution of the effect. 0.5 means half the resolution of the texture node.
   */
  constructor(textureNode, directionNode = null, sigma = 4, options = {}) {
    super("vec4");
    this.textureNode = textureNode;
    this.directionNode = directionNode;
    this.sigma = sigma;
    this._invSize = uniform(new Vector2());
    this._passDirection = uniform(new Vector2());
    this._horizontalRT = new RenderTarget(1, 1, { depthBuffer: false });
    this._horizontalRT.texture.name = "GaussianBlurNode.horizontal";
    this._verticalRT = new RenderTarget(1, 1, { depthBuffer: false });
    this._verticalRT.texture.name = "GaussianBlurNode.vertical";
    this._textureNode = passTexture(this, this._verticalRT.texture);
    this._textureNode.uvNode = textureNode.uvNode;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.resolutionScale = options.resolutionScale || 1;
    this.premultipliedAlpha = options.premultipliedAlpha || false;
  }
  /**
   * Sets the size of the effect.
   *
   * @param {number} width - The width of the effect.
   * @param {number} height - The height of the effect.
   */
  setSize(width, height) {
    width = Math.max(Math.round(width * this.resolutionScale), 1);
    height = Math.max(Math.round(height * this.resolutionScale), 1);
    this._invSize.value.set(1 / width, 1 / height);
    this._horizontalRT.setSize(width, height);
    this._verticalRT.setSize(width, height);
  }
  /**
   * This method is used to render the effect once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore(frame) {
    const { renderer } = frame;
    _rendererState = RendererUtils.resetRendererState(renderer, _rendererState);
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const currentTexture = textureNode.value;
    _quadMesh.material = this._material;
    this.setSize(map.image.width, map.image.height);
    const textureType = map.type;
    this._horizontalRT.texture.type = textureType;
    this._verticalRT.texture.type = textureType;
    renderer.setRenderTarget(this._horizontalRT);
    this._passDirection.value.set(1, 0);
    _quadMesh.name = "Gaussian Blur [ Horizontal Pass ]";
    _quadMesh.render(renderer);
    textureNode.value = this._horizontalRT.texture;
    renderer.setRenderTarget(this._verticalRT);
    this._passDirection.value.set(0, 1);
    _quadMesh.name = "Gaussian Blur [ Vertical Pass ]";
    _quadMesh.render(renderer);
    textureNode.value = currentTexture;
    RendererUtils.restoreRendererState(renderer, _rendererState);
  }
  /**
   * Returns the result of the effect as a texture node.
   *
   * @return {PassTextureNode} A texture node that represents the result of the effect.
   */
  getTextureNode() {
    return this._textureNode;
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {PassTextureNode}
   */
  setup(builder) {
    const textureNode = this.textureNode;
    const uvNode = uv();
    const directionNode = vec2(this.directionNode || 1);
    let sampleTexture, output;
    if (this.premultipliedAlpha) {
      sampleTexture = (uv2) => premultiplyAlpha(textureNode.sample(uv2));
      output = (color) => unpremultiplyAlpha(color);
    } else {
      sampleTexture = (uv2) => textureNode.sample(uv2);
      output = (color) => color;
    }
    const blur = Fn(() => {
      const kernelSize = 3 + 2 * this.sigma;
      const gaussianCoefficients = this._getCoefficients(kernelSize);
      const invSize = this._invSize;
      const direction = directionNode.mul(this._passDirection);
      const diffuseSum = vec4(sampleTexture(uvNode).mul(gaussianCoefficients[0])).toVar();
      for (let i = 1; i < kernelSize; i++) {
        const x = float(i);
        const w = float(gaussianCoefficients[i]);
        const uvOffset = vec2(direction.mul(invSize.mul(x))).toVar();
        const sample1 = sampleTexture(uvNode.add(uvOffset));
        const sample2 = sampleTexture(uvNode.sub(uvOffset));
        diffuseSum.addAssign(sample1.add(sample2).mul(w));
      }
      return output(diffuseSum);
    });
    const material = this._material || (this._material = new NodeMaterial());
    material.fragmentNode = blur().context(builder.getSharedContext());
    material.name = "Gaussian_blur";
    material.needsUpdate = true;
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
  /**
   * Frees internal resources. This method should be called
   * when the effect is no longer required.
   */
  dispose() {
    this._horizontalRT.dispose();
    this._verticalRT.dispose();
  }
  /**
   * Computes gaussian coefficients depending on the given kernel radius.
   *
   * @private
   * @param {number} kernelRadius - The kernel radius.
   * @return {Array<number>}
   */
  _getCoefficients(kernelRadius) {
    const coefficients = [];
    const sigma = kernelRadius / 3;
    for (let i = 0; i < kernelRadius; i++) {
      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (sigma * sigma)) / sigma);
    }
    return coefficients;
  }
  /**
   * The resolution scale.
   *
   * @deprecated
   * @type {Vector2}
   * @default {(1,1)}
   */
  get resolution() {
    console.warn('THREE.GaussianBlurNode: The "resolution" property has been renamed to "resolutionScale" and is now of type `number`.');
    return new Vector2(this.resolutionScale, this.resolutionScale);
  }
  set resolution(value) {
    console.warn('THREE.GaussianBlurNode: The "resolution" property has been renamed to "resolutionScale" and is now of type `number`.');
    this.resolutionScale = value.x;
  }
};
var GaussianBlurNode_default = GaussianBlurNode;
var gaussianBlur = (node, directionNode, sigma, options = {}) => nodeObject(new GaussianBlurNode(convertToTexture(node), directionNode, sigma, options));
function premultipliedGaussianBlur(node, directionNode, sigma) {
  console.warn('THREE.TSL: "premultipliedGaussianBlur()" is deprecated. Use "gaussianBlur()" with "premultipliedAlpha: true" option instead.');
  return gaussianBlur(node, directionNode, sigma, { premultipliedAlpha: true });
}

export {
  GaussianBlurNode_default,
  gaussianBlur,
  premultipliedGaussianBlur
};
//# sourceMappingURL=chunk-4TEL2PC2.js.map
