{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/DotScreenNode.js"],
  "sourcesContent": ["import { TempNode } from 'three/webgpu';\nimport { nodeObject, Fn, uv, uniform, vec2, vec3, sin, cos, add, vec4, screenSize } from 'three/tsl';\n\n/**\n * Post processing node for creating dot-screen effect.\n *\n * @augments TempNode\n * @three_import import { dotScreen } from 'three/addons/tsl/display/DotScreenNode.js';\n */\nclass DotScreenNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'DotScreenNode';\n\n\t}\n\n\t/**\n\t * Constructs a new dot screen node.\n\t *\n\t * @param {Node} inputNode - The node that represents the input of the effect.\n\t * @param {number} [angle=1.57] - The rotation of the effect in radians.\n\t * @param {number} [scale=1] - The scale of the effect. A higher value means smaller dots.\n\t */\n\tconstructor( inputNode, angle = 1.57, scale = 1 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The node that represents the input of the effect.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inputNode = inputNode;\n\n\t\t/**\n\t\t * A uniform node that represents the rotation of the effect in radians.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.angle = uniform( angle );\n\n\t\t/**\n\t\t * A uniform node that represents the scale of the effect. A higher value means smaller dots.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.scale = uniform( scale );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup() {\n\n\t\tconst inputNode = this.inputNode;\n\n\t\tconst pattern = Fn( () => {\n\n\t\t\tconst s = sin( this.angle );\n\t\t\tconst c = cos( this.angle );\n\n\t\t\tconst tex = uv().mul( screenSize );\n\t\t\tconst point = vec2( c.mul( tex.x ).sub( s.mul( tex.y ) ), s.mul( tex.x ).add( c.mul( tex.y ) ) ).mul( this.scale );\n\n\t\t\treturn sin( point.x ).mul( sin( point.y ) ).mul( 4 );\n\n\t\t} );\n\n\t\tconst dotScreen = Fn( () => {\n\n\t\t\tconst color = inputNode;\n\n\t\t\tconst average = add( color.r, color.g, color.b ).div( 3 );\n\n\t\t\treturn vec4( vec3( average.mul( 10 ).sub( 5 ).add( pattern() ) ), color.a );\n\n\t\t} );\n\n\t\tconst outputNode = dotScreen();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default DotScreenNode;\n\n/**\n * TSL function for creating a dot-screen node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {number} [angle=1.57] - The rotation of the effect in radians.\n * @param {number} [scale=1] - The scale of the effect. A higher value means smaller dots.\n * @returns {DotScreenNode}\n */\nexport const dotScreen = ( node, angle, scale ) => nodeObject( new DotScreenNode( nodeObject( node ), angle, scale ) );\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AASA,IAAM,gBAAN,cAA4B,SAAS;AAAA,EAEpC,WAAW,OAAO;AAEjB,WAAO;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAa,WAAW,QAAQ,MAAM,QAAQ,GAAI;AAEjD,UAAO,MAAO;AAOd,SAAK,YAAY;AAOjB,SAAK,QAAQ,QAAS,KAAM;AAO5B,SAAK,QAAQ,QAAS,KAAM;AAAA,EAE7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ;AAEP,UAAM,YAAY,KAAK;AAEvB,UAAM,UAAU,GAAI,MAAM;AAEzB,YAAM,IAAI,IAAK,KAAK,KAAM;AAC1B,YAAM,IAAI,IAAK,KAAK,KAAM;AAE1B,YAAM,MAAM,GAAG,EAAE,IAAK,UAAW;AACjC,YAAM,QAAQ,KAAM,EAAE,IAAK,IAAI,CAAE,EAAE,IAAK,EAAE,IAAK,IAAI,CAAE,CAAE,GAAG,EAAE,IAAK,IAAI,CAAE,EAAE,IAAK,EAAE,IAAK,IAAI,CAAE,CAAE,CAAE,EAAE,IAAK,KAAK,KAAM;AAEjH,aAAO,IAAK,MAAM,CAAE,EAAE,IAAK,IAAK,MAAM,CAAE,CAAE,EAAE,IAAK,CAAE;AAAA,IAEpD,CAAE;AAEF,UAAMA,aAAY,GAAI,MAAM;AAE3B,YAAM,QAAQ;AAEd,YAAM,UAAU,IAAK,MAAM,GAAG,MAAM,GAAG,MAAM,CAAE,EAAE,IAAK,CAAE;AAExD,aAAO,KAAM,KAAM,QAAQ,IAAK,EAAG,EAAE,IAAK,CAAE,EAAE,IAAK,QAAQ,CAAE,CAAE,GAAG,MAAM,CAAE;AAAA,IAE3E,CAAE;AAEF,UAAM,aAAaA,WAAU;AAE7B,WAAO;AAAA,EAER;AAED;AAEA,IAAO,wBAAQ;AAYR,IAAM,YAAY,CAAE,MAAM,OAAO,UAAW,WAAY,IAAI,cAAe,WAAY,IAAK,GAAG,OAAO,KAAM,CAAE;",
  "names": ["dotScreen"]
}
