import {
  Fn,
  convertToTexture,
  float,
  max,
  nodeObject,
  passTexture,
  sign,
  texture,
  uv
} from "./chunk-KPFVNXSK.js";
import {
  NodeMaterial,
  NodeUpdateType,
  QuadMesh,
  RendererUtils,
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  RenderTarget,
  Vector2
} from "./chunk-XFHY3IS3.js";

// node_modules/three/examples/jsm/tsl/display/AfterImageNode.js
var _size = new Vector2();
var _quadMesh = new QuadMesh();
var _rendererState;
var AfterImageNode = class extends TempNode {
  static get type() {
    return "AfterImageNode";
  }
  /**
   * Constructs a new after image node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the input of the effect.
   * @param {Node<float>} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.
   */
  constructor(textureNode, damp = float(0.96)) {
    super("vec4");
    this.textureNode = textureNode;
    this.damp = damp;
    this._compRT = new RenderTarget(1, 1, { depthBuffer: false });
    this._compRT.texture.name = "AfterImageNode.comp";
    this._oldRT = new RenderTarget(1, 1, { depthBuffer: false });
    this._oldRT.texture.name = "AfterImageNode.old";
    this._textureNode = passTexture(this, this._compRT.texture);
    this._textureNodeOld = texture(this._oldRT.texture);
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  /**
   * Returns the result of the effect as a texture node.
   *
   * @return {PassTextureNode} A texture node that represents the result of the effect.
   */
  getTextureNode() {
    return this._textureNode;
  }
  /**
   * Sets the size of the effect.
   *
   * @param {number} width - The width of the effect.
   * @param {number} height - The height of the effect.
   */
  setSize(width, height) {
    this._compRT.setSize(width, height);
    this._oldRT.setSize(width, height);
  }
  /**
   * This method is used to render the effect once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore(frame) {
    const { renderer } = frame;
    _rendererState = RendererUtils.resetRendererState(renderer, _rendererState);
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const textureType = map.type;
    this._compRT.texture.type = textureType;
    this._oldRT.texture.type = textureType;
    renderer.getDrawingBufferSize(_size);
    this.setSize(_size.x, _size.y);
    this._textureNode.value = this._compRT.texture;
    this._textureNodeOld.value = this._oldRT.texture;
    _quadMesh.material = this._materialComposed;
    _quadMesh.name = "AfterImage";
    renderer.setRenderTarget(this._compRT);
    _quadMesh.render(renderer);
    const temp = this._oldRT;
    this._oldRT = this._compRT;
    this._compRT = temp;
    RendererUtils.restoreRendererState(renderer, _rendererState);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {PassTextureNode}
   */
  setup(builder) {
    const textureNode = this.textureNode;
    const textureNodeOld = this._textureNodeOld;
    textureNodeOld.uvNode = textureNode.uvNode || uv();
    const afterImg = Fn(() => {
      const texelOld = textureNodeOld.sample().toVar();
      const texelNew = textureNode.sample().toVar();
      const threshold = float(0.1).toConst();
      const m = max(sign(texelOld.sub(threshold)), 0);
      texelOld.mulAssign(this.damp.mul(m));
      return max(texelNew, texelOld);
    });
    const materialComposed = this._materialComposed || (this._materialComposed = new NodeMaterial());
    materialComposed.name = "AfterImage";
    materialComposed.fragmentNode = afterImg();
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
  /**
   * Frees internal resources. This method should be called
   * when the effect is no longer required.
   */
  dispose() {
    this._compRT.dispose();
    this._oldRT.dispose();
  }
};
var afterImage = (node, damp) => nodeObject(new AfterImageNode(convertToTexture(node), nodeObject(damp)));
var AfterImageNode_default = AfterImageNode;
export {
  afterImage,
  AfterImageNode_default as default
};
//# sourceMappingURL=three_addons_tsl_display_AfterImageNode__js.js.map
