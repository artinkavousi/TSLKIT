{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/SobelOperatorNode.js"],
  "sourcesContent": ["import { Vector2, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, uv, uniform, convertToTexture, vec2, vec3, vec4, mat3, luminance, add } from 'three/tsl';\n\n/**\n * Post processing node for detecting edges with a sobel filter.\n * A sobel filter should be applied after tone mapping and output color\n * space conversion.\n *\n * @augments TempNode\n * @three_import import { sobel } from 'three/addons/tsl/display/SobelOperatorNode.js';\n */\nclass SobelOperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SobelOperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new sobel operator node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst { textureNode } = this;\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.sample( uv );\n\n\t\tconst sobel = Fn( () => {\n\n\t\t\t// Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n\n\t\t\tconst texel = this._invSize;\n\n\t\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\tconst Gx = mat3( - 1, - 2, - 1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\n\t\t\tconst Gy = mat3( - 1, 0, 1, - 2, 0, 2, - 1, 0, 1 ); // y direction kernel\n\n\t\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t\t// first column\n\n\t\t\tconst tx0y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, - 1 ) ) ) ).xyz );\n\t\t\tconst tx0y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, 0 ) ) ) ).xyz );\n\t\t\tconst tx0y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, 1 ) ) ) ).xyz );\n\n\t\t\t// second column\n\n\t\t\tconst tx1y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, - 1 ) ) ) ).xyz );\n\t\t\tconst tx1y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, 0 ) ) ) ).xyz );\n\t\t\tconst tx1y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, 1 ) ) ) ).xyz );\n\n\t\t\t// third column\n\n\t\t\tconst tx2y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, - 1 ) ) ) ).xyz );\n\t\t\tconst tx2y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, 0 ) ) ) ).xyz );\n\t\t\tconst tx2y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, 1 ) ) ) ).xyz );\n\n\t\t\t// gradient value in x direction\n\n\t\t\tconst valueGx = add(\n\t\t\t\tGx[ 0 ][ 0 ].mul( tx0y0 ),\n\t\t\t\tGx[ 1 ][ 0 ].mul( tx1y0 ),\n\t\t\t\tGx[ 2 ][ 0 ].mul( tx2y0 ),\n\t\t\t\tGx[ 0 ][ 1 ].mul( tx0y1 ),\n\t\t\t\tGx[ 1 ][ 1 ].mul( tx1y1 ),\n\t\t\t\tGx[ 2 ][ 1 ].mul( tx2y1 ),\n\t\t\t\tGx[ 0 ][ 2 ].mul( tx0y2 ),\n\t\t\t\tGx[ 1 ][ 2 ].mul( tx1y2 ),\n\t\t\t\tGx[ 2 ][ 2 ].mul( tx2y2 )\n\t\t\t);\n\n\n\t\t\t// gradient value in y direction\n\n\t\t\tconst valueGy = add(\n\t\t\t\tGy[ 0 ][ 0 ].mul( tx0y0 ),\n\t\t\t\tGy[ 1 ][ 0 ].mul( tx1y0 ),\n\t\t\t\tGy[ 2 ][ 0 ].mul( tx2y0 ),\n\t\t\t\tGy[ 0 ][ 1 ].mul( tx0y1 ),\n\t\t\t\tGy[ 1 ][ 1 ].mul( tx1y1 ),\n\t\t\t\tGy[ 2 ][ 1 ].mul( tx2y1 ),\n\t\t\t\tGy[ 0 ][ 2 ].mul( tx0y2 ),\n\t\t\t\tGy[ 1 ][ 2 ].mul( tx1y2 ),\n\t\t\t\tGy[ 2 ][ 2 ].mul( tx2y2 )\n\t\t\t);\n\n\t\t\t// magnitude of the total gradient\n\n\t\t\tconst G = valueGx.mul( valueGx ).add( valueGy.mul( valueGy ) ).sqrt();\n\n\t\t\treturn vec4( vec3( G ), 1 );\n\n\t\t} );\n\n\t\tconst outputNode = sobel();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default SobelOperatorNode;\n\n/**\n * TSL function for creating a sobel operator node which performs edge detection with a sobel filter.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @returns {SobelOperatorNode}\n */\nexport const sobel = ( node ) => nodeObject( new SobelOperatorNode( convertToTexture( node ) ) );\n"],
  "mappings": "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",
  "names": ["uv", "sobel"]
}
