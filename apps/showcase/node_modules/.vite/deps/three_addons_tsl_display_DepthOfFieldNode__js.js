import {
  gaussianBlur
} from "./chunk-4TEL2PC2.js";
import {
  Fn,
  Loop,
  convertToTexture,
  max,
  min,
  mix,
  nodeObject,
  outputStruct,
  property,
  smoothstep,
  step,
  texture,
  uniform,
  uniformArray,
  uv,
  vec3,
  vec4
} from "./chunk-KPFVNXSK.js";
import {
  NodeMaterial,
  NodeUpdateType,
  QuadMesh,
  RendererUtils,
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  HalfFloatType,
  RedFormat,
  RenderTarget,
  Vector2
} from "./chunk-XFHY3IS3.js";
import "./chunk-PZ5AY32C.js";

// node_modules/three/examples/jsm/tsl/display/DepthOfFieldNode.js
var _quadMesh = new QuadMesh();
var _rendererState;
var DepthOfFieldNode = class extends TempNode {
  static get type() {
    return "DepthOfFieldNode";
  }
  /**
   * Constructs a new DOF node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the input of the effect.
   * @param {Node<float>} viewZNode - Represents the viewZ depth values of the scene.
   * @param {Node<float>} focusDistanceNode - Defines the effect's focus which is the distance along the camera's look direction in world units.
   * @param {Node<float>} focalLengthNode - How far an object can be from the focal plane before it goes completely out-of-focus in world units.
   * @param {Node<float>} bokehScaleNode - A unitless value for artistic purposes to adjust the size of the bokeh.
   */
  constructor(textureNode, viewZNode, focusDistanceNode, focalLengthNode, bokehScaleNode) {
    super("vec4");
    this.textureNode = textureNode;
    this.viewZNode = viewZNode;
    this.focusDistanceNode = focusDistanceNode;
    this.focalLengthNode = focalLengthNode;
    this.bokehScaleNode = bokehScaleNode;
    this._invSize = uniform(new Vector2());
    this._CoCRT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType, format: RedFormat, count: 2 });
    this._CoCRT.textures[0].name = "DepthOfField.NearField";
    this._CoCRT.textures[1].name = "DepthOfField.FarField";
    this._CoCBlurredRT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType, format: RedFormat });
    this._CoCBlurredRT.texture.name = "DepthOfField.NearFieldBlurred";
    this._blur64RT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType });
    this._blur64RT.texture.name = "DepthOfField.Blur64";
    this._blur16NearRT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType });
    this._blur16NearRT.texture.name = "DepthOfField.Blur16Near";
    this._blur16FarRT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType });
    this._blur16FarRT.texture.name = "DepthOfField.Blur16Far";
    this._compositeRT = new RenderTarget(1, 1, { depthBuffer: false, type: HalfFloatType });
    this._compositeRT.texture.name = "DepthOfField.Composite";
    this._CoCMaterial = new NodeMaterial();
    this._CoCBlurredMaterial = new NodeMaterial();
    this._blur64Material = new NodeMaterial();
    this._blur16Material = new NodeMaterial();
    this._compositeMaterial = new NodeMaterial();
    this._textureNode = texture(this._compositeRT.texture);
    this._CoCTextureNode = texture(this._CoCRT.texture);
    this._blur64TextureNode = texture(this._blur64RT.texture);
    this._blur16NearTextureNode = texture(this._blur16NearRT.texture);
    this._blur16FarTextureNode = texture(this._blur16FarRT.texture);
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  /**
   * Sets the size of the effect.
   *
   * @param {number} width - The width of the effect.
   * @param {number} height - The height of the effect.
   */
  setSize(width, height) {
    this._invSize.value.set(1 / width, 1 / height);
    this._CoCRT.setSize(width, height);
    this._compositeRT.setSize(width, height);
    const halfResX = Math.round(width / 2);
    const halfResY = Math.round(height / 2);
    this._CoCBlurredRT.setSize(halfResX, halfResY);
    this._blur64RT.setSize(halfResX, halfResY);
    this._blur16NearRT.setSize(halfResX, halfResY);
    this._blur16FarRT.setSize(halfResX, halfResY);
  }
  /**
   * Returns the result of the effect as a texture node.
   *
   * @return {PassTextureNode} A texture node that represents the result of the effect.
   */
  getTextureNode() {
    return this._textureNode;
  }
  /**
   * This method is used to update the effect's uniforms once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore(frame) {
    const { renderer } = frame;
    const map = this.textureNode.value;
    this.setSize(map.image.width, map.image.height);
    _rendererState = RendererUtils.resetRendererState(renderer, _rendererState);
    renderer.setClearColor(0, 0);
    _quadMesh.material = this._CoCMaterial;
    renderer.setRenderTarget(this._CoCRT);
    _quadMesh.name = "DoF [ CoC ]";
    _quadMesh.render(renderer);
    this._CoCTextureNode.value = this._CoCRT.textures[0];
    _quadMesh.material = this._CoCBlurredMaterial;
    renderer.setRenderTarget(this._CoCBlurredRT);
    _quadMesh.name = "DoF [ CoC Blur ]";
    _quadMesh.render(renderer);
    this._CoCTextureNode.value = this._CoCBlurredRT.texture;
    _quadMesh.material = this._blur64Material;
    renderer.setRenderTarget(this._blur64RT);
    _quadMesh.name = "DoF [ Blur64 Near ]";
    _quadMesh.render(renderer);
    _quadMesh.material = this._blur16Material;
    renderer.setRenderTarget(this._blur16NearRT);
    _quadMesh.name = "DoF [ Blur16 Near ]";
    _quadMesh.render(renderer);
    this._CoCTextureNode.value = this._CoCRT.textures[1];
    _quadMesh.material = this._blur64Material;
    renderer.setRenderTarget(this._blur64RT);
    _quadMesh.name = "DoF [ Blur64 Far ]";
    _quadMesh.render(renderer);
    _quadMesh.material = this._blur16Material;
    renderer.setRenderTarget(this._blur16FarRT);
    _quadMesh.name = "DoF [ Blur16 Far ]";
    _quadMesh.render(renderer);
    _quadMesh.material = this._compositeMaterial;
    renderer.setRenderTarget(this._compositeRT);
    _quadMesh.name = "DoF [ Composite ]";
    _quadMesh.render(renderer);
    RendererUtils.restoreRendererState(renderer, _rendererState);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ShaderCallNodeInternal}
   */
  setup(builder) {
    const kernels = this._generateKernels();
    const nearField = property("float");
    const farField = property("float");
    const outputNode = outputStruct(nearField, farField);
    const CoC = Fn(() => {
      const signedDist = this.viewZNode.negate().sub(this.focusDistanceNode);
      const CoC2 = smoothstep(0, this.focalLengthNode, signedDist.abs());
      nearField.assign(step(signedDist, 0).mul(CoC2));
      farField.assign(step(0, signedDist).mul(CoC2));
      return vec4(0);
    });
    this._CoCMaterial.colorNode = CoC().context(builder.getSharedContext());
    this._CoCMaterial.outputNode = outputNode;
    this._CoCMaterial.needsUpdate = true;
    this._CoCBlurredMaterial.colorNode = gaussianBlur(this._CoCTextureNode, 1, 2);
    this._CoCBlurredMaterial.needsUpdate = true;
    const bokeh64 = uniformArray(kernels.points64);
    const blur64 = Fn(() => {
      const acc = vec3();
      const uvNode = uv();
      const CoC2 = this._CoCTextureNode.sample(uvNode).r;
      const sampleStep = this._invSize.mul(this.bokehScaleNode).mul(CoC2);
      Loop(64, ({ i }) => {
        const sUV = uvNode.add(sampleStep.mul(bokeh64.element(i)));
        const tap = this.textureNode.sample(sUV);
        acc.addAssign(tap.rgb);
      });
      acc.divAssign(64);
      return vec4(acc, CoC2);
    });
    this._blur64Material.fragmentNode = blur64().context(builder.getSharedContext());
    this._blur64Material.needsUpdate = true;
    const bokeh16 = uniformArray(kernels.points16);
    const blur16 = Fn(() => {
      const uvNode = uv();
      const col = this._blur64TextureNode.sample(uvNode).toVar();
      const maxVal = col.rgb;
      const CoC2 = col.a;
      const sampleStep = this._invSize.mul(this.bokehScaleNode).mul(CoC2);
      Loop(16, ({ i }) => {
        const sUV = uvNode.add(sampleStep.mul(bokeh16.element(i)));
        const tap = this._blur64TextureNode.sample(sUV);
        maxVal.assign(max(tap.rgb, maxVal));
      });
      return vec4(maxVal, CoC2);
    });
    this._blur16Material.fragmentNode = blur16().context(builder.getSharedContext());
    this._blur16Material.needsUpdate = true;
    const composite = Fn(() => {
      const uvNode = uv();
      const near = this._blur16NearTextureNode.sample(uvNode);
      const far = this._blur16FarTextureNode.sample(uvNode);
      const beauty = this.textureNode.sample(uvNode);
      const blendNear = min(near.a, 0.5).mul(2);
      const blendFar = min(far.a, 0.5).mul(2);
      const result = vec4(0, 0, 0, 1).toVar();
      result.rgb = mix(beauty.rgb, far.rgb, blendFar);
      result.rgb = mix(result.rgb, near.rgb, blendNear);
      return result;
    });
    this._compositeMaterial.fragmentNode = composite().context(builder.getSharedContext());
    this._compositeMaterial.needsUpdate = true;
    return this._textureNode;
  }
  _generateKernels() {
    const GOLDEN_ANGLE = 2.39996323;
    const SAMPLES = 80;
    const points64 = [];
    const points16 = [];
    let idx64 = 0;
    let idx16 = 0;
    for (let i = 0; i < SAMPLES; i++) {
      const theta = i * GOLDEN_ANGLE;
      const r = Math.sqrt(i) / Math.sqrt(SAMPLES);
      const p = new Vector2(r * Math.cos(theta), r * Math.sin(theta));
      if (i % 5 === 0) {
        points16[idx16] = p;
        idx16++;
      } else {
        points64[idx64] = p;
        idx64++;
      }
    }
    return { points16, points64 };
  }
  /**
   * Frees internal resources. This method should be called
   * when the effect is no longer required.
   */
  dispose() {
    this._CoCRT.dispose();
    this._CoCBlurredRT.dispose();
    this._blur64RT.dispose();
    this._blur16NearRT.dispose();
    this._blur16FarRT.dispose();
    this._compositeRT.dispose();
    this._CoCMaterial.dispose();
    this._CoCBlurredMaterial.dispose();
    this._blur64Material.dispose();
    this._blur16Material.dispose();
    this._compositeMaterial.dispose();
  }
};
var DepthOfFieldNode_default = DepthOfFieldNode;
var dof = (node, viewZNode, focusDistance = 1, focalLength = 1, bokehScale = 1) => nodeObject(new DepthOfFieldNode(convertToTexture(node), nodeObject(viewZNode), nodeObject(focusDistance), nodeObject(focalLength), nodeObject(bokehScale)));
export {
  DepthOfFieldNode_default as default,
  dof
};
//# sourceMappingURL=three_addons_tsl_display_DepthOfFieldNode__js.js.map
