import {
  Fn,
  If,
  clamp,
  convertToTexture,
  dot,
  float,
  floor,
  mrt,
  nodeObject,
  normalView,
  output,
  property,
  sign,
  smoothstep,
  step,
  uniform,
  uv,
  vec2,
  vec3
} from "./chunk-KPFVNXSK.js";
import {
  NodeUpdateType,
  PassNode,
  TempNode
} from "./chunk-IDAOASVO.js";
import {
  NearestFilter,
  Vector4
} from "./chunk-XFHY3IS3.js";

// node_modules/three/examples/jsm/tsl/display/PixelationPassNode.js
var PixelationNode = class extends TempNode {
  static get type() {
    return "PixelationNode";
  }
  /**
   * Constructs a new pixelation node.
   *
   * @param {TextureNode} textureNode - The texture node that represents the beauty pass.
   * @param {TextureNode} depthNode - The texture that represents the beauty's depth.
   * @param {TextureNode} normalNode - The texture that represents the beauty's normals.
   * @param {Node<float>} pixelSize - The pixel size.
   * @param {Node<float>} normalEdgeStrength - The normal edge strength.
   * @param {Node<float>} depthEdgeStrength - The depth edge strength.
   */
  constructor(textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength) {
    super("vec4");
    this.textureNode = textureNode;
    this.depthNode = depthNode;
    this.normalNode = normalNode;
    this.pixelSize = pixelSize;
    this.normalEdgeStrength = normalEdgeStrength;
    this.depthEdgeStrength = depthEdgeStrength;
    this._resolution = uniform(new Vector4());
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  /**
   * This method is used to update uniforms once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore() {
    const map = this.textureNode.value;
    const width = map.image.width;
    const height = map.image.height;
    this._resolution.value.set(width, height, 1 / width, 1 / height);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ShaderCallNodeInternal}
   */
  setup() {
    const { textureNode, depthNode, normalNode } = this;
    const uvNodeTexture = textureNode.uvNode || uv();
    const uvNodeDepth = depthNode.uvNode || uv();
    const uvNodeNormal = normalNode.uvNode || uv();
    const sampleTexture = () => textureNode.sample(uvNodeTexture);
    const sampleDepth = (x, y) => depthNode.sample(uvNodeDepth.add(vec2(x, y).mul(this._resolution.zw))).r;
    const sampleNormal = (x, y) => normalNode.sample(uvNodeNormal.add(vec2(x, y).mul(this._resolution.zw))).rgb.normalize();
    const depthEdgeIndicator = (depth) => {
      const diff = property("float", "diff");
      diff.addAssign(clamp(sampleDepth(1, 0).sub(depth)));
      diff.addAssign(clamp(sampleDepth(-1, 0).sub(depth)));
      diff.addAssign(clamp(sampleDepth(0, 1).sub(depth)));
      diff.addAssign(clamp(sampleDepth(0, -1).sub(depth)));
      return floor(smoothstep(0.01, 0.02, diff).mul(2)).div(2);
    };
    const neighborNormalEdgeIndicator = (x, y, depth, normal) => {
      const depthDiff = sampleDepth(x, y).sub(depth);
      const neighborNormal = sampleNormal(x, y);
      const normalEdgeBias = vec3(1, 1, 1);
      const normalDiff = dot(normal.sub(neighborNormal), normalEdgeBias);
      const normalIndicator = clamp(smoothstep(-0.01, 0.01, normalDiff), 0, 1);
      const depthIndicator = clamp(sign(depthDiff.mul(0.25).add(25e-4)), 0, 1);
      return float(1).sub(dot(normal, neighborNormal)).mul(depthIndicator).mul(normalIndicator);
    };
    const normalEdgeIndicator = (depth, normal) => {
      const indicator = property("float", "indicator");
      indicator.addAssign(neighborNormalEdgeIndicator(0, -1, depth, normal));
      indicator.addAssign(neighborNormalEdgeIndicator(0, 1, depth, normal));
      indicator.addAssign(neighborNormalEdgeIndicator(-1, 0, depth, normal));
      indicator.addAssign(neighborNormalEdgeIndicator(1, 0, depth, normal));
      return step(0.1, indicator);
    };
    const pixelation2 = Fn(() => {
      const texel = sampleTexture();
      const depth = property("float", "depth");
      const normal = property("vec3", "normal");
      If(this.depthEdgeStrength.greaterThan(0).or(this.normalEdgeStrength.greaterThan(0)), () => {
        depth.assign(sampleDepth(0, 0));
        normal.assign(sampleNormal(0, 0));
      });
      const dei = property("float", "dei");
      If(this.depthEdgeStrength.greaterThan(0), () => {
        dei.assign(depthEdgeIndicator(depth));
      });
      const nei = property("float", "nei");
      If(this.normalEdgeStrength.greaterThan(0), () => {
        nei.assign(normalEdgeIndicator(depth, normal));
      });
      const strength = dei.greaterThan(0).select(float(1).sub(dei.mul(this.depthEdgeStrength)), nei.mul(this.normalEdgeStrength).add(1));
      return texel.mul(strength);
    });
    const outputNode = pixelation2();
    return outputNode;
  }
};
var pixelation = (node, depthNode, normalNode, pixelSize = 6, normalEdgeStrength = 0.3, depthEdgeStrength = 0.4) => nodeObject(new PixelationNode(convertToTexture(node), convertToTexture(depthNode), convertToTexture(normalNode), nodeObject(pixelSize), nodeObject(normalEdgeStrength), nodeObject(depthEdgeStrength)));
var PixelationPassNode = class extends PassNode {
  static get type() {
    return "PixelationPassNode";
  }
  /**
   * Constructs a new pixelation pass node.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {Node<float> | number} [pixelSize=6] - The pixel size.
   * @param {Node<float> | number} [normalEdgeStrength=0.3] - The normal edge strength.
   * @param {Node<float> | number} [depthEdgeStrength=0.4] - The depth edge strength.
   */
  constructor(scene, camera, pixelSize = 6, normalEdgeStrength = 0.3, depthEdgeStrength = 0.4) {
    super(PassNode.COLOR, scene, camera, { minFilter: NearestFilter, magFilter: NearestFilter });
    this.pixelSize = pixelSize;
    this.normalEdgeStrength = normalEdgeStrength;
    this.depthEdgeStrength = depthEdgeStrength;
    this.isPixelationPassNode = true;
    this._mrt = mrt({
      output,
      normal: normalView
    });
  }
  /**
   * Sets the size of the pass.
   *
   * @param {number} width - The width of the pass.
   * @param {number} height - The height of the pass.
   */
  setSize(width, height) {
    const pixelSize = this.pixelSize.value ? this.pixelSize.value : this.pixelSize;
    const adjustedWidth = Math.floor(width / pixelSize);
    const adjustedHeight = Math.floor(height / pixelSize);
    super.setSize(adjustedWidth, adjustedHeight);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {PixelationNode}
   */
  setup() {
    const color = super.getTextureNode("output");
    const depth = super.getTextureNode("depth");
    const normal = super.getTextureNode("normal");
    return pixelation(color, depth, normal, this.pixelSize, this.normalEdgeStrength, this.depthEdgeStrength);
  }
};
var pixelationPass = (scene, camera, pixelSize, normalEdgeStrength, depthEdgeStrength) => nodeObject(new PixelationPassNode(scene, camera, pixelSize, normalEdgeStrength, depthEdgeStrength));
var PixelationPassNode_default = PixelationPassNode;
export {
  PixelationPassNode_default as default,
  pixelationPass
};
//# sourceMappingURL=three_addons_tsl_display_PixelationPassNode__js.js.map
