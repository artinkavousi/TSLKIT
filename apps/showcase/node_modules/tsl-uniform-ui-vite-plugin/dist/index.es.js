var hl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zp(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var tn = {}, dl;
function il() {
  if (dl) return tn;
  dl = 1, Object.defineProperty(tn, "__esModule", {
    value: !0
  });
  function i(b, t) {
    if (b == null) return {};
    var e = {};
    for (var r in b) if ({}.hasOwnProperty.call(b, r)) {
      if (t.includes(r)) continue;
      e[r] = b[r];
    }
    return e;
  }
  class l {
    constructor(t, e, r) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = e, this.index = r;
    }
  }
  class u {
    constructor(t, e) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = e;
    }
  }
  function o(b, t) {
    const {
      line: e,
      column: r,
      index: a
    } = b;
    return new l(e, r + t, a + t);
  }
  const f = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var p = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: f
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: f
    }
  };
  const P = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, w = (b) => b.type === "UpdateExpression" ? P.UpdateExpression[`${b.prefix}`] : P[b.type];
  var x = {
    AccessorIsGenerator: ({
      kind: b
    }) => `A ${b}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind: b
    }) => `Missing initializer in ${b} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName: b
    }) => `\`${b}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase: b
    }) => `'import.${b}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName: b,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${b}' as '${t}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type: b
    }) => `'${b === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type: b
    }) => `Unsyntactic ${b === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: ({
      importName: b
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${b}" as foo }\`?`,
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix: b
    }) => `Expected number in radix ${b}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord: b
    }) => `Escape sequence in keyword ${b}.`,
    InvalidIdentifier: ({
      identifierName: b
    }) => `Invalid identifier ${b}.`,
    InvalidLhs: ({
      ancestor: b
    }) => `Invalid left-hand side in ${w(b)}.`,
    InvalidLhsBinding: ({
      ancestor: b
    }) => `Binding invalid left-hand side in ${w(b)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor: b
    }) => `Invalid optional chaining in the left-hand side of ${w(b)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected: b
    }) => `Unexpected character '${b}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName: b
    }) => `Private name #${b} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName: b
    }) => `Label '${b}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin: b
    }) => `This experimental syntax requires enabling the parser plugin: ${b.map((t) => JSON.stringify(t)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin: b
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${b.map((t) => JSON.stringify(t)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key: b
    }) => `Duplicate key "${b}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode: b
    }) => `An export name cannot include a lone surrogate, found '\\u${b.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName: b
    }) => `Export '${b}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName: b
    }) => `Private names are only allowed in property accesses (\`obj.#${b}\`) or in \`in\` expressions (\`#${b} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName: b
    }) => `Duplicate private name #${b}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword: b
    }) => `Unexpected keyword '${b}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord: b
    }) => `Unexpected reserved word '${b}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected: b,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${b ? `, expected "${b}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target: b,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${b} is ${b}.${t}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName: b
    }) => `Identifier '${b}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, A = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName: b
    }) => `Assigning to '${b}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName: b
    }) => `Binding '${b}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  const g = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var I = Object.assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token: b
    }) => `Invalid topic token ${b}. In order to use ${b} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${b}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type: b
    }) => `Hack-style pipe body cannot be an unparenthesized ${w({
      type: b
    })}; please wrap it in parentheses.`
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  });
  const v = ["message"];
  function S(b, t, e) {
    Object.defineProperty(b, t, {
      enumerable: !1,
      configurable: !0,
      value: e
    });
  }
  function _({
    toMessage: b,
    code: t,
    reasonCode: e,
    syntaxPlugin: r
  }) {
    const a = e === "MissingPlugin" || e === "MissingOneOfPlugins";
    {
      const c = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      c[e] && (e = c[e]);
    }
    return function c(E, M) {
      const Y = new SyntaxError();
      return Y.code = t, Y.reasonCode = e, Y.loc = E, Y.pos = E.index, Y.syntaxPlugin = r, a && (Y.missingPlugin = M.missingPlugin), S(Y, "clone", function(ue = {}) {
        var Ee;
        const {
          line: _e,
          column: ke,
          index: Re
        } = (Ee = ue.loc) != null ? Ee : E;
        return c(new l(_e, ke, Re), Object.assign({}, M, ue.details));
      }), S(Y, "details", M), Object.defineProperty(Y, "message", {
        configurable: !0,
        get() {
          const se = `${b(M)} (${E.line}:${E.column})`;
          return this.message = se, se;
        },
        set(se) {
          Object.defineProperty(this, "message", {
            value: se,
            writable: !0
          });
        }
      }), Y;
    };
  }
  function B(b, t) {
    if (Array.isArray(b))
      return (r) => B(r, b[0]);
    const e = {};
    for (const r of Object.keys(b)) {
      const a = b[r], c = typeof a == "string" ? {
        message: () => a
      } : typeof a == "function" ? {
        message: a
      } : a, {
        message: E
      } = c, M = i(c, v), Y = typeof E == "string" ? () => E : E;
      e[r] = _(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: r,
        toMessage: Y
      }, t ? {
        syntaxPlugin: t
      } : {}, M));
    }
    return e;
  }
  const y = Object.assign({}, B(p), B(x), B(A), B`pipelineOperator`(I));
  function X() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  function Z(b) {
    const t = X();
    if (b == null)
      return t;
    if (b.annexB != null && b.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (const e of Object.keys(t))
      b[e] != null && (t[e] = b[e]);
    if (t.startLine === 1)
      b.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : b.startColumn == null && t.startIndex > 0 && (t.startColumn = t.startIndex);
    else if ((b.startColumn == null || b.startIndex == null) && b.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return t;
  }
  const {
    defineProperty: J
  } = Object, G = (b, t) => {
    b && J(b, t, {
      enumerable: !1,
      value: b[t]
    });
  };
  function O(b) {
    return G(b.loc.start, "index"), G(b.loc.end, "index"), b;
  }
  var ee = (b) => class extends b {
    parse() {
      const e = O(super.parse());
      return this.optionFlags & 128 && (e.tokens = e.tokens.map(O)), e;
    }
    parseRegExpLiteral({
      pattern: e,
      flags: r
    }) {
      let a = null;
      try {
        a = new RegExp(e, r);
      } catch {
      }
      const c = this.estreeParseLiteral(a);
      return c.regex = {
        pattern: e,
        flags: r
      }, c;
    }
    parseBigIntLiteral(e) {
      let r;
      try {
        r = BigInt(e);
      } catch {
        r = null;
      }
      const a = this.estreeParseLiteral(r);
      return a.bigint = String(a.value || e), a;
    }
    parseDecimalLiteral(e) {
      const a = this.estreeParseLiteral(null);
      return a.decimal = String(a.value || e), a;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      const r = e.value;
      delete e.value, r.type = "Literal", r.raw = r.extra.raw, r.value = r.extra.expressionValue;
      const a = e;
      return a.type = "ExpressionStatement", a.expression = r, a.directive = r.extra.rawValue, delete r.extra, a;
    }
    initFunction(e, r) {
      super.initFunction(e, r), e.expression = !1;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var r;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((r = e.expression.extra) != null && r.parenthesized);
    }
    parseBlockBody(e, r, a, c, E) {
      super.parseBlockBody(e, r, a, c, E);
      const M = e.directives.map((Y) => this.directiveToStmt(Y));
      e.body = M.concat(e.body), delete e.directives;
    }
    parsePrivateName() {
      const e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      const r = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = r, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, r) {
      const a = super.parseLiteral(e, r);
      return a.raw = a.extra.raw, delete a.extra, a;
    }
    parseFunctionBody(e, r, a = !1) {
      super.parseFunctionBody(e, r, a), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, r, a, c, E, M, Y = !1) {
      let se = this.startNode();
      se.kind = e.kind, se = super.parseMethod(se, r, a, c, E, M, Y), se.type = "FunctionExpression", delete se.kind, e.value = se;
      const {
        typeParameters: ue
      } = e;
      return ue && (delete e.typeParameters, se.typeParameters = ue, this.resetStartLocationFromNode(se, ue)), M === "ClassPrivateMethod" && (e.computed = !1), this.finishNode(e, "MethodDefinition");
    }
    nameIsConstructor(e) {
      return e.type === "Literal" ? e.value === "constructor" : super.nameIsConstructor(e);
    }
    parseClassProperty(...e) {
      const r = super.parseClassProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (r.type = "PropertyDefinition"), r;
    }
    parseClassPrivateProperty(...e) {
      const r = super.parseClassPrivateProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (r.type = "PropertyDefinition", r.computed = !1), r;
    }
    parseObjectMethod(e, r, a, c, E) {
      const M = super.parseObjectMethod(e, r, a, c, E);
      return M && (M.type = "Property", M.kind === "method" && (M.kind = "init"), M.shorthand = !1), M;
    }
    parseObjectProperty(e, r, a, c) {
      const E = super.parseObjectProperty(e, r, a, c);
      return E && (E.kind = "init", E.type = "Property"), E;
    }
    isValidLVal(e, r, a) {
      return e === "Property" ? "value" : super.isValidLVal(e, r, a);
    }
    isAssignable(e, r) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, r) : super.isAssignable(e, r);
    }
    toAssignable(e, r = !1) {
      if (e != null && this.isObjectProperty(e)) {
        const {
          key: a,
          value: c
        } = e;
        this.isPrivateName(a) && this.classScope.usePrivateName(this.getPrivateNameSV(a), a.loc.start), this.toAssignable(c, r);
      } else
        super.toAssignable(e, r);
    }
    toAssignableObjectExpressionProp(e, r, a) {
      e.type === "Property" && (e.kind === "get" || e.kind === "set") ? this.raise(y.PatternHasAccessor, e.key) : e.type === "Property" && e.method ? this.raise(y.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, r, a);
    }
    finishCallExpression(e, r) {
      const a = super.finishCallExpression(e, r);
      if (a.callee.type === "Import") {
        var c, E;
        a.type = "ImportExpression", a.source = a.arguments[0], a.options = (c = a.arguments[1]) != null ? c : null, a.attributes = (E = a.arguments[1]) != null ? E : null, delete a.arguments, delete a.callee;
      }
      return a;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e, r) {
      const a = this.state.lastTokStartLoc, c = super.parseExport(e, r);
      switch (c.type) {
        case "ExportAllDeclaration":
          c.exported = null;
          break;
        case "ExportNamedDeclaration":
          c.specifiers.length === 1 && c.specifiers[0].type === "ExportNamespaceSpecifier" && (c.type = "ExportAllDeclaration", c.exported = c.specifiers[0].exported, delete c.specifiers);
        case "ExportDefaultDeclaration":
          {
            var E;
            const {
              declaration: M
            } = c;
            (M == null ? void 0 : M.type) === "ClassDeclaration" && ((E = M.decorators) == null ? void 0 : E.length) > 0 && M.start === c.start && this.resetStartLocation(c, a);
          }
          break;
      }
      return c;
    }
    parseSubscript(e, r, a, c) {
      const E = super.parseSubscript(e, r, a, c);
      if (c.optionalChainMember) {
        if ((E.type === "OptionalMemberExpression" || E.type === "OptionalCallExpression") && (E.type = E.type.substring(8)), c.stop) {
          const M = this.startNodeAtNode(E);
          return M.expression = E, this.finishNode(M, "ChainExpression");
        }
      } else (E.type === "MemberExpression" || E.type === "CallExpression") && (E.optional = !1);
      return E;
    }
    isOptionalMemberExpression(e) {
      return e.type === "ChainExpression" ? e.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e);
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.type === "Property" && (e.method || e.kind === "get" || e.kind === "set");
    }
    finishNodeAt(e, r, a) {
      return O(super.finishNodeAt(e, r, a));
    }
    resetStartLocation(e, r) {
      super.resetStartLocation(e, r), O(e);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      super.resetEndLocation(e, r), O(e);
    }
  };
  class L {
    constructor(t, e) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!e;
    }
  }
  const q = {
    brace: new L("{"),
    j_oTag: new L("<tag"),
    j_cTag: new L("</tag"),
    j_expr: new L("<tag>...</tag>", !0)
  };
  q.template = new L("`", !0);
  const H = !0, N = !0, F = !0, ie = !0, re = !0, Q = !0;
  class pe {
    constructor(t, e = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null, this.updateContext = null;
    }
  }
  const ne = /* @__PURE__ */ new Map();
  function R(b, t = {}) {
    t.keyword = b;
    const e = we(b, t);
    return ne.set(b, e), e;
  }
  function C(b, t) {
    return we(b, {
      beforeExpr: H,
      binop: t
    });
  }
  let z = -1;
  const ae = [], ce = [], ye = [], he = [], Pe = [], Ne = [];
  function we(b, t = {}) {
    var e, r, a, c;
    return ++z, ce.push(b), ye.push((e = t.binop) != null ? e : -1), he.push((r = t.beforeExpr) != null ? r : !1), Pe.push((a = t.startsExpr) != null ? a : !1), Ne.push((c = t.prefix) != null ? c : !1), ae.push(new pe(b, t)), z;
  }
  function Ie(b, t = {}) {
    var e, r, a, c;
    return ++z, ne.set(b, z), ce.push(b), ye.push((e = t.binop) != null ? e : -1), he.push((r = t.beforeExpr) != null ? r : !1), Pe.push((a = t.startsExpr) != null ? a : !1), Ne.push((c = t.prefix) != null ? c : !1), ae.push(new pe("name", t)), z;
  }
  const Le = {
    bracketL: we("[", {
      beforeExpr: H,
      startsExpr: N
    }),
    bracketHashL: we("#[", {
      beforeExpr: H,
      startsExpr: N
    }),
    bracketBarL: we("[|", {
      beforeExpr: H,
      startsExpr: N
    }),
    bracketR: we("]"),
    bracketBarR: we("|]"),
    braceL: we("{", {
      beforeExpr: H,
      startsExpr: N
    }),
    braceBarL: we("{|", {
      beforeExpr: H,
      startsExpr: N
    }),
    braceHashL: we("#{", {
      beforeExpr: H,
      startsExpr: N
    }),
    braceR: we("}"),
    braceBarR: we("|}"),
    parenL: we("(", {
      beforeExpr: H,
      startsExpr: N
    }),
    parenR: we(")"),
    comma: we(",", {
      beforeExpr: H
    }),
    semi: we(";", {
      beforeExpr: H
    }),
    colon: we(":", {
      beforeExpr: H
    }),
    doubleColon: we("::", {
      beforeExpr: H
    }),
    dot: we("."),
    question: we("?", {
      beforeExpr: H
    }),
    questionDot: we("?."),
    arrow: we("=>", {
      beforeExpr: H
    }),
    template: we("template"),
    ellipsis: we("...", {
      beforeExpr: H
    }),
    backQuote: we("`", {
      startsExpr: N
    }),
    dollarBraceL: we("${", {
      beforeExpr: H,
      startsExpr: N
    }),
    templateTail: we("...`", {
      startsExpr: N
    }),
    templateNonTail: we("...${", {
      beforeExpr: H,
      startsExpr: N
    }),
    at: we("@"),
    hash: we("#", {
      startsExpr: N
    }),
    interpreterDirective: we("#!..."),
    eq: we("=", {
      beforeExpr: H,
      isAssign: ie
    }),
    assign: we("_=", {
      beforeExpr: H,
      isAssign: ie
    }),
    slashAssign: we("_=", {
      beforeExpr: H,
      isAssign: ie
    }),
    xorAssign: we("_=", {
      beforeExpr: H,
      isAssign: ie
    }),
    moduloAssign: we("_=", {
      beforeExpr: H,
      isAssign: ie
    }),
    incDec: we("++/--", {
      prefix: re,
      postfix: Q,
      startsExpr: N
    }),
    bang: we("!", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    tilde: we("~", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    doubleCaret: we("^^", {
      startsExpr: N
    }),
    doubleAt: we("@@", {
      startsExpr: N
    }),
    pipeline: C("|>", 0),
    nullishCoalescing: C("??", 1),
    logicalOR: C("||", 1),
    logicalAND: C("&&", 2),
    bitwiseOR: C("|", 3),
    bitwiseXOR: C("^", 4),
    bitwiseAND: C("&", 5),
    equality: C("==/!=/===/!==", 6),
    lt: C("</>/<=/>=", 7),
    gt: C("</>/<=/>=", 7),
    relational: C("</>/<=/>=", 7),
    bitShift: C("<</>>/>>>", 8),
    bitShiftL: C("<</>>/>>>", 8),
    bitShiftR: C("<</>>/>>>", 8),
    plusMin: we("+/-", {
      beforeExpr: H,
      binop: 9,
      prefix: re,
      startsExpr: N
    }),
    modulo: we("%", {
      binop: 10,
      startsExpr: N
    }),
    star: we("*", {
      binop: 10
    }),
    slash: C("/", 10),
    exponent: we("**", {
      beforeExpr: H,
      binop: 11,
      rightAssociative: !0
    }),
    _in: R("in", {
      beforeExpr: H,
      binop: 7
    }),
    _instanceof: R("instanceof", {
      beforeExpr: H,
      binop: 7
    }),
    _break: R("break"),
    _case: R("case", {
      beforeExpr: H
    }),
    _catch: R("catch"),
    _continue: R("continue"),
    _debugger: R("debugger"),
    _default: R("default", {
      beforeExpr: H
    }),
    _else: R("else", {
      beforeExpr: H
    }),
    _finally: R("finally"),
    _function: R("function", {
      startsExpr: N
    }),
    _if: R("if"),
    _return: R("return", {
      beforeExpr: H
    }),
    _switch: R("switch"),
    _throw: R("throw", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    _try: R("try"),
    _var: R("var"),
    _const: R("const"),
    _with: R("with"),
    _new: R("new", {
      beforeExpr: H,
      startsExpr: N
    }),
    _this: R("this", {
      startsExpr: N
    }),
    _super: R("super", {
      startsExpr: N
    }),
    _class: R("class", {
      startsExpr: N
    }),
    _extends: R("extends", {
      beforeExpr: H
    }),
    _export: R("export"),
    _import: R("import", {
      startsExpr: N
    }),
    _null: R("null", {
      startsExpr: N
    }),
    _true: R("true", {
      startsExpr: N
    }),
    _false: R("false", {
      startsExpr: N
    }),
    _typeof: R("typeof", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    _void: R("void", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    _delete: R("delete", {
      beforeExpr: H,
      prefix: re,
      startsExpr: N
    }),
    _do: R("do", {
      isLoop: F,
      beforeExpr: H
    }),
    _for: R("for", {
      isLoop: F
    }),
    _while: R("while", {
      isLoop: F
    }),
    _as: Ie("as", {
      startsExpr: N
    }),
    _assert: Ie("assert", {
      startsExpr: N
    }),
    _async: Ie("async", {
      startsExpr: N
    }),
    _await: Ie("await", {
      startsExpr: N
    }),
    _defer: Ie("defer", {
      startsExpr: N
    }),
    _from: Ie("from", {
      startsExpr: N
    }),
    _get: Ie("get", {
      startsExpr: N
    }),
    _let: Ie("let", {
      startsExpr: N
    }),
    _meta: Ie("meta", {
      startsExpr: N
    }),
    _of: Ie("of", {
      startsExpr: N
    }),
    _sent: Ie("sent", {
      startsExpr: N
    }),
    _set: Ie("set", {
      startsExpr: N
    }),
    _source: Ie("source", {
      startsExpr: N
    }),
    _static: Ie("static", {
      startsExpr: N
    }),
    _using: Ie("using", {
      startsExpr: N
    }),
    _yield: Ie("yield", {
      startsExpr: N
    }),
    _asserts: Ie("asserts", {
      startsExpr: N
    }),
    _checks: Ie("checks", {
      startsExpr: N
    }),
    _exports: Ie("exports", {
      startsExpr: N
    }),
    _global: Ie("global", {
      startsExpr: N
    }),
    _implements: Ie("implements", {
      startsExpr: N
    }),
    _intrinsic: Ie("intrinsic", {
      startsExpr: N
    }),
    _infer: Ie("infer", {
      startsExpr: N
    }),
    _is: Ie("is", {
      startsExpr: N
    }),
    _mixins: Ie("mixins", {
      startsExpr: N
    }),
    _proto: Ie("proto", {
      startsExpr: N
    }),
    _require: Ie("require", {
      startsExpr: N
    }),
    _satisfies: Ie("satisfies", {
      startsExpr: N
    }),
    _keyof: Ie("keyof", {
      startsExpr: N
    }),
    _readonly: Ie("readonly", {
      startsExpr: N
    }),
    _unique: Ie("unique", {
      startsExpr: N
    }),
    _abstract: Ie("abstract", {
      startsExpr: N
    }),
    _declare: Ie("declare", {
      startsExpr: N
    }),
    _enum: Ie("enum", {
      startsExpr: N
    }),
    _module: Ie("module", {
      startsExpr: N
    }),
    _namespace: Ie("namespace", {
      startsExpr: N
    }),
    _interface: Ie("interface", {
      startsExpr: N
    }),
    _type: Ie("type", {
      startsExpr: N
    }),
    _opaque: Ie("opaque", {
      startsExpr: N
    }),
    name: we("name", {
      startsExpr: N
    }),
    placeholder: we("%%", {
      startsExpr: !0
    }),
    string: we("string", {
      startsExpr: N
    }),
    num: we("num", {
      startsExpr: N
    }),
    bigint: we("bigint", {
      startsExpr: N
    }),
    decimal: we("decimal", {
      startsExpr: N
    }),
    regexp: we("regexp", {
      startsExpr: N
    }),
    privateName: we("#name", {
      startsExpr: N
    }),
    eof: we("eof"),
    jsxName: we("jsxName"),
    jsxText: we("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: we("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: we("jsxTagEnd")
  };
  function fe(b) {
    return b >= 93 && b <= 133;
  }
  function Te(b) {
    return b <= 92;
  }
  function de(b) {
    return b >= 58 && b <= 133;
  }
  function Ue(b) {
    return b >= 58 && b <= 137;
  }
  function Je(b) {
    return he[b];
  }
  function He(b) {
    return Pe[b];
  }
  function st(b) {
    return b >= 29 && b <= 33;
  }
  function qe(b) {
    return b >= 129 && b <= 131;
  }
  function Ge(b) {
    return b >= 90 && b <= 92;
  }
  function at(b) {
    return b >= 58 && b <= 92;
  }
  function it(b) {
    return b >= 39 && b <= 59;
  }
  function ft(b) {
    return b === 34;
  }
  function Xe(b) {
    return Ne[b];
  }
  function Tt(b) {
    return b >= 121 && b <= 123;
  }
  function be(b) {
    return b >= 124 && b <= 130;
  }
  function ve(b) {
    return ce[b];
  }
  function j(b) {
    return ye[b];
  }
  function D(b) {
    return b === 57;
  }
  function V(b) {
    return b >= 24 && b <= 25;
  }
  function le(b) {
    return ae[b];
  }
  ae[8].updateContext = (b) => {
    b.pop();
  }, ae[5].updateContext = ae[7].updateContext = ae[23].updateContext = (b) => {
    b.push(q.brace);
  }, ae[22].updateContext = (b) => {
    b[b.length - 1] === q.template ? b.pop() : b.push(q.template);
  }, ae[143].updateContext = (b) => {
    b.push(q.j_expr, q.j_oTag);
  };
  let me = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", ge = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const xe = new RegExp("[" + me + "]"), De = new RegExp("[" + me + ge + "]");
  me = ge = null;
  const We = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Ce = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Ye(b, t) {
    let e = 65536;
    for (let r = 0, a = t.length; r < a; r += 2) {
      if (e += t[r], e > b) return !1;
      if (e += t[r + 1], e >= b) return !0;
    }
    return !1;
  }
  function $e(b) {
    return b < 65 ? b === 36 : b <= 90 ? !0 : b < 97 ? b === 95 : b <= 122 ? !0 : b <= 65535 ? b >= 170 && xe.test(String.fromCharCode(b)) : Ye(b, We);
  }
  function et(b) {
    return b < 48 ? b === 36 : b < 58 ? !0 : b < 65 ? !1 : b <= 90 ? !0 : b < 97 ? b === 95 : b <= 122 ? !0 : b <= 65535 ? b >= 170 && De.test(String.fromCharCode(b)) : Ye(b, We) || Ye(b, Ce);
  }
  const oe = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, K = new Set(oe.keyword), Ae = new Set(oe.strict), Be = new Set(oe.strictBind);
  function Ke(b, t) {
    return t && b === "await" || b === "enum";
  }
  function ct(b, t) {
    return Ke(b, t) || Ae.has(b);
  }
  function Lt(b) {
    return Be.has(b);
  }
  function Kt(b, t) {
    return ct(b, t) || Lt(b);
  }
  function Nt(b) {
    return K.has(b);
  }
  function At(b, t, e) {
    return b === 64 && t === 64 && $e(e);
  }
  const xt = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Wt(b) {
    return xt.has(b);
  }
  class $t {
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }
  class Jt {
    constructor(t, e) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = e;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        const {
          flags: e
        } = this.scopeStack[t];
        if (e & 128)
          return !0;
        if (e & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new $t(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, e, r) {
      let a = this.currentScope();
      if (e & 8 || e & 16) {
        this.checkRedeclarationInScope(a, t, e, r);
        let c = a.names.get(t) || 0;
        e & 16 ? c = c | 4 : (a.firstLexicalName || (a.firstLexicalName = t), c = c | 2), a.names.set(t, c), e & 8 && this.maybeExportDefined(a, t);
      } else if (e & 4)
        for (let c = this.scopeStack.length - 1; c >= 0 && (a = this.scopeStack[c], this.checkRedeclarationInScope(a, t, e, r), a.names.set(t, (a.names.get(t) || 0) | 1), this.maybeExportDefined(a, t), !(a.flags & 387)); --c)
          ;
      this.parser.inModule && a.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, e) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(e);
    }
    checkRedeclarationInScope(t, e, r, a) {
      this.isRedeclaredInScope(t, e, r) && this.parser.raise(y.VarRedeclaration, a, {
        identifierName: e
      });
    }
    isRedeclaredInScope(t, e, r) {
      if (!(r & 1)) return !1;
      if (r & 8)
        return t.names.has(e);
      const a = t.names.get(e);
      return r & 16 ? (a & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (a & 1) > 0 : (a & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === e) || !this.treatFunctionsAsVarInScope(t) && (a & 4) > 0;
    }
    checkLocalExport(t) {
      const {
        name: e
      } = t;
      this.scopeStack[0].names.has(e) || this.undefinedExports.set(e, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        const {
          flags: e
        } = this.scopeStack[t];
        if (e & 387)
          return e;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        const {
          flags: e
        } = this.scopeStack[t];
        if (e & 451 && !(e & 4))
          return e;
      }
    }
  }
  class rr extends $t {
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Yr extends Jt {
    createScope(t) {
      return new rr(t);
    }
    declareName(t, e, r) {
      const a = this.currentScope();
      if (e & 2048) {
        this.checkRedeclarationInScope(a, t, e, r), this.maybeExportDefined(a, t), a.declareFunctions.add(t);
        return;
      }
      super.declareName(t, e, r);
    }
    isRedeclaredInScope(t, e, r) {
      if (super.isRedeclaredInScope(t, e, r)) return !0;
      if (r & 2048 && !t.declareFunctions.has(e)) {
        const a = t.names.get(e);
        return (a & 4) > 0 || (a & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }
  class Hr {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(t) {
      return t + this.startIndex;
    }
    offsetToSourcePos(t) {
      return t - this.startIndex;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        const [e, r] = t;
        if (!this.hasPlugin(e))
          return !1;
        const a = this.plugins.get(e);
        for (const c of Object.keys(r))
          if ((a == null ? void 0 : a[c]) !== r[c])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, e) {
      var r;
      return (r = this.plugins.get(t)) == null ? void 0 : r[e];
    }
  }
  function Cr(b, t) {
    b.trailingComments === void 0 ? b.trailingComments = t : b.trailingComments.unshift(...t);
  }
  function Gr(b, t) {
    b.leadingComments === void 0 ? b.leadingComments = t : b.leadingComments.unshift(...t);
  }
  function Gt(b, t) {
    b.innerComments === void 0 ? b.innerComments = t : b.innerComments.unshift(...t);
  }
  function Mt(b, t, e) {
    let r = null, a = t.length;
    for (; r === null && a > 0; )
      r = t[--a];
    r === null || r.start > e.start ? Gt(b, e.comments) : Cr(r, e.comments);
  }
  class zr extends Hr {
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      const {
        commentsLen: e
      } = this.state;
      this.comments.length !== e && (this.comments.length = e), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      const {
        commentStack: e
      } = this.state, r = e.length;
      if (r === 0) return;
      let a = r - 1;
      const c = e[a];
      c.start === t.end && (c.leadingNode = t, a--);
      const {
        start: E
      } = t;
      for (; a >= 0; a--) {
        const M = e[a], Y = M.end;
        if (Y > E)
          M.containingNode = t, this.finalizeComment(M), e.splice(a, 1);
        else {
          Y === E && (M.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      const {
        comments: e
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && Cr(t.leadingNode, e), t.trailingNode !== null && Gr(t.trailingNode, e);
      else {
        const {
          containingNode: r,
          start: a
        } = t;
        if (this.input.charCodeAt(this.offsetToSourcePos(a) - 1) === 44)
          switch (r.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Mt(r, r.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Mt(r, r.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Mt(r, r.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Mt(r, r.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Mt(r, r.specifiers, t);
              break;
            case "TSEnumDeclaration":
              Mt(r, r.members, t);
              break;
            case "TSEnumBody":
              Mt(r, r.members, t);
              break;
            default:
              Gt(r, e);
          }
        else
          Gt(r, e);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: t
      } = this.state;
      for (let e = t.length - 1; e >= 0; e--)
        this.finalizeComment(t[e]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      const {
        commentStack: e
      } = this.state, {
        length: r
      } = e;
      if (r === 0) return;
      const a = e[r - 1];
      a.leadingNode === t && (a.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      const {
        commentStack: e
      } = this.state, {
        length: r
      } = e;
      r !== 0 && (e[r - 1].trailingNode === t ? e[r - 1].trailingNode = null : r >= 2 && e[r - 2].trailingNode === t && (e[r - 2].trailingNode = null));
    }
    takeSurroundingComments(t, e, r) {
      const {
        commentStack: a
      } = this.state, c = a.length;
      if (c === 0) return;
      let E = c - 1;
      for (; E >= 0; E--) {
        const M = a[E], Y = M.end;
        if (M.start === r)
          M.leadingNode = t;
        else if (Y === e)
          M.trailingNode = t;
        else if (Y < e)
          break;
      }
    }
  }
  const Qr = /\r\n|[\r\n\u2028\u2029]/, ir = new RegExp(Qr.source, "g");
  function Xt(b) {
    switch (b) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  function Ir(b, t, e) {
    for (let r = t; r < e; r++)
      if (Xt(b.charCodeAt(r)))
        return !0;
    return !1;
  }
  const hr = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, dr = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function Zr(b) {
    switch (b) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  class mr {
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [q.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: e,
      startIndex: r,
      startLine: a,
      startColumn: c
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : e === "module", this.startIndex = r, this.curLine = a, this.lineStart = -c, this.startLoc = this.endLoc = new l(a, c, r);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(t) {
      t ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new l(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      const t = new mr();
      return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
    }
  }
  var ei = function(t) {
    return t >= 48 && t <= 57;
  };
  const wr = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, nr = {
    bin: (b) => b === 48 || b === 49,
    oct: (b) => b >= 48 && b <= 55,
    dec: (b) => b >= 48 && b <= 57,
    hex: (b) => b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102
  };
  function Or(b, t, e, r, a, c) {
    const E = e, M = r, Y = a;
    let se = "", ue = null, Ee = e;
    const {
      length: _e
    } = t;
    for (; ; ) {
      if (e >= _e) {
        c.unterminated(E, M, Y), se += t.slice(Ee, e);
        break;
      }
      const ke = t.charCodeAt(e);
      if (ti(b, ke, t, e)) {
        se += t.slice(Ee, e);
        break;
      }
      if (ke === 92) {
        se += t.slice(Ee, e);
        const Re = ri(t, e, r, a, b === "template", c);
        Re.ch === null && !ue ? ue = {
          pos: e,
          lineStart: r,
          curLine: a
        } : se += Re.ch, {
          pos: e,
          lineStart: r,
          curLine: a
        } = Re, Ee = e;
      } else ke === 8232 || ke === 8233 ? (++e, ++a, r = e) : ke === 10 || ke === 13 ? b === "template" ? (se += t.slice(Ee, e) + `
`, ++e, ke === 13 && t.charCodeAt(e) === 10 && ++e, ++a, Ee = r = e) : c.unterminated(E, M, Y) : ++e;
    }
    return {
      pos: e,
      str: se,
      firstInvalidLoc: ue,
      lineStart: r,
      curLine: a,
      containsInvalid: !!ue
    };
  }
  function ti(b, t, e, r) {
    return b === "template" ? t === 96 || t === 36 && e.charCodeAt(r + 1) === 123 : t === (b === "double" ? 34 : 39);
  }
  function ri(b, t, e, r, a, c) {
    const E = !a;
    t++;
    const M = (se) => ({
      pos: t,
      ch: se,
      lineStart: e,
      curLine: r
    }), Y = b.charCodeAt(t++);
    switch (Y) {
      case 110:
        return M(`
`);
      case 114:
        return M("\r");
      case 120: {
        let se;
        return {
          code: se,
          pos: t
        } = yr(b, t, e, r, 2, !1, E, c), M(se === null ? null : String.fromCharCode(se));
      }
      case 117: {
        let se;
        return {
          code: se,
          pos: t
        } = _r(b, t, e, r, E, c), M(se === null ? null : String.fromCodePoint(se));
      }
      case 116:
        return M("	");
      case 98:
        return M("\b");
      case 118:
        return M("\v");
      case 102:
        return M("\f");
      case 13:
        b.charCodeAt(t) === 10 && ++t;
      case 10:
        e = t, ++r;
      case 8232:
      case 8233:
        return M("");
      case 56:
      case 57:
        if (a)
          return M(null);
        c.strictNumericEscape(t - 1, e, r);
      default:
        if (Y >= 48 && Y <= 55) {
          const se = t - 1;
          let Ee = /^[0-7]+/.exec(b.slice(se, t + 2))[0], _e = parseInt(Ee, 8);
          _e > 255 && (Ee = Ee.slice(0, -1), _e = parseInt(Ee, 8)), t += Ee.length - 1;
          const ke = b.charCodeAt(t);
          if (Ee !== "0" || ke === 56 || ke === 57) {
            if (a)
              return M(null);
            c.strictNumericEscape(se, e, r);
          }
          return M(String.fromCharCode(_e));
        }
        return M(String.fromCharCode(Y));
    }
  }
  function yr(b, t, e, r, a, c, E, M) {
    const Y = t;
    let se;
    return {
      n: se,
      pos: t
    } = Nr(b, t, e, r, 16, a, c, !1, M, !E), se === null && (E ? M.invalidEscapeSequence(Y, e, r) : t = Y - 1), {
      code: se,
      pos: t
    };
  }
  function Nr(b, t, e, r, a, c, E, M, Y, se) {
    const ue = t, Ee = a === 16 ? wr.hex : wr.decBinOct, _e = a === 16 ? nr.hex : a === 10 ? nr.dec : a === 8 ? nr.oct : nr.bin;
    let ke = !1, Re = 0;
    for (let Qe = 0, mt = c ?? 1 / 0; Qe < mt; ++Qe) {
      const tt = b.charCodeAt(t);
      let ut;
      if (tt === 95 && M !== "bail") {
        const ur = b.charCodeAt(t - 1), Zt = b.charCodeAt(t + 1);
        if (M) {
          if (Number.isNaN(Zt) || !_e(Zt) || Ee.has(ur) || Ee.has(Zt)) {
            if (se) return {
              n: null,
              pos: t
            };
            Y.unexpectedNumericSeparator(t, e, r);
          }
        } else {
          if (se) return {
            n: null,
            pos: t
          };
          Y.numericSeparatorInEscapeSequence(t, e, r);
        }
        ++t;
        continue;
      }
      if (tt >= 97 ? ut = tt - 97 + 10 : tt >= 65 ? ut = tt - 65 + 10 : ei(tt) ? ut = tt - 48 : ut = 1 / 0, ut >= a) {
        if (ut <= 9 && se)
          return {
            n: null,
            pos: t
          };
        if (ut <= 9 && Y.invalidDigit(t, e, r, a))
          ut = 0;
        else if (E)
          ut = 0, ke = !0;
        else
          break;
      }
      ++t, Re = Re * a + ut;
    }
    return t === ue || c != null && t - ue !== c || ke ? {
      n: null,
      pos: t
    } : {
      n: Re,
      pos: t
    };
  }
  function _r(b, t, e, r, a, c) {
    const E = b.charCodeAt(t);
    let M;
    if (E === 123) {
      if (++t, {
        code: M,
        pos: t
      } = yr(b, t, e, r, b.indexOf("}", t) - t, !0, a, c), ++t, M !== null && M > 1114111)
        if (a)
          c.invalidCodePoint(t, e, r);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: M,
        pos: t
      } = yr(b, t, e, r, 4, !1, a, c));
    return {
      code: M,
      pos: t
    };
  }
  function zt(b, t, e) {
    return new l(e, b - t, b);
  }
  const ii = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class _t {
    constructor(t) {
      const e = t.startIndex || 0;
      this.type = t.type, this.value = t.value, this.start = e + t.start, this.end = e + t.end, this.loc = new u(t.startLoc, t.endLoc);
    }
  }
  class ni extends zr {
    constructor(t, e) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: (r, a, c, E) => this.optionFlags & 1024 ? (this.raise(y.InvalidDigit, zt(r, a, c), {
          radix: E
        }), !0) : !1,
        numericSeparatorInEscapeSequence: this.errorBuilder(y.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(y.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(y.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(y.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (r, a, c) => {
          this.recordStrictModeErrors(y.StrictNumericEscape, zt(r, a, c));
        },
        unterminated: (r, a, c) => {
          throw this.raise(y.UnterminatedString, zt(r - 1, a, c));
        }
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(y.StrictNumericEscape),
        unterminated: (r, a, c) => {
          throw this.raise(y.UnterminatedTemplate, zt(r, a, c));
        }
      }), this.state = new mr(), this.state.init(t), this.input = e, this.length = e.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 128 && this.pushToken(new _t(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      const t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const e = this.state;
      return this.state = t, e;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return hr.lastIndex = t, hr.test(this.input) ? hr.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return dr.lastIndex = t, dr.test(this.input) ? dr.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let e = this.input.charCodeAt(t);
      if ((e & 64512) === 55296 && ++t < this.input.length) {
        const r = this.input.charCodeAt(t);
        (r & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (r & 1023));
      }
      return e;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([e, r]) => this.raise(e, r)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let e;
      this.isLookahead || (e = this.state.curPosition());
      const r = this.state.pos, a = this.input.indexOf(t, r + 2);
      if (a === -1)
        throw this.raise(y.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = a + t.length, ir.lastIndex = r + 2; ir.test(this.input) && ir.lastIndex <= a; )
        ++this.state.curLine, this.state.lineStart = ir.lastIndex;
      if (this.isLookahead) return;
      const c = {
        type: "CommentBlock",
        value: this.input.slice(r + 2, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a + t.length),
        loc: new u(e, this.state.curPosition())
      };
      return this.optionFlags & 128 && this.pushToken(c), c;
    }
    skipLineComment(t) {
      const e = this.state.pos;
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let a = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Xt(a) && ++this.state.pos < this.length; )
          a = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const c = this.state.pos, M = {
        type: "CommentLine",
        value: this.input.slice(e + t, c),
        start: this.sourceToOffsetPos(e),
        end: this.sourceToOffsetPos(c),
        loc: new u(r, this.state.curPosition())
      };
      return this.optionFlags & 128 && this.pushToken(M), M;
    }
    skipSpace() {
      const t = this.state.pos, e = this.optionFlags & 2048 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        const r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const a = this.skipBlockComment("*/");
                a !== void 0 && (this.addComment(a), e == null || e.push(a));
                break;
              }
              case 47: {
                const a = this.skipLineComment(2);
                a !== void 0 && (this.addComment(a), e == null || e.push(a));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Zr(r))
              ++this.state.pos;
            else if (r === 45 && !this.inModule && this.optionFlags & 4096) {
              const a = this.state.pos;
              if (this.input.charCodeAt(a + 1) === 45 && this.input.charCodeAt(a + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                const c = this.skipLineComment(3);
                c !== void 0 && (this.addComment(c), e == null || e.push(c));
              } else
                break e;
            } else if (r === 60 && !this.inModule && this.optionFlags & 4096) {
              const a = this.state.pos;
              if (this.input.charCodeAt(a + 1) === 33 && this.input.charCodeAt(a + 2) === 45 && this.input.charCodeAt(a + 3) === 45) {
                const c = this.skipLineComment(4);
                c !== void 0 && (this.addComment(c), e == null || e.push(c));
              } else
                break e;
            } else
              break e;
        }
      }
      if ((e == null ? void 0 : e.length) > 0) {
        const r = this.state.pos, a = {
          start: this.sourceToOffsetPos(t),
          end: this.sourceToOffsetPos(r),
          comments: e,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(a);
      }
    }
    finishToken(t, e) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r = this.state.type;
      this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(r);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const t = this.state.pos + 1, e = this.codePointAtPos(t);
      if (e >= 48 && e <= 57)
        throw this.raise(y.UnexpectedDigitAfterHash, this.state.curPosition());
      if (e === 123 || e === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(e === 123 ? y.RecordExpressionHashIncorrectStartSyntaxType : y.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, e === 123 ? this.finishToken(7) : this.finishToken(1);
      } else $e(e) ? (++this.state.pos, this.finishToken(139, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      const e = this.state.pos;
      for (this.state.pos += 1; !Xt(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      const r = this.input.slice(e + 2, this.state.pos);
      return this.finishToken(28, r), !0;
    }
    readToken_mult_modulo(t) {
      let e = t === 42 ? 55 : 54, r = 1, a = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && a === 42 && (r++, a = this.input.charCodeAt(this.state.pos + 2), e = 57), a === 61 && !this.state.inType && (r++, e = t === 37 ? 33 : 30), this.finishOp(e, r);
    }
    readToken_pipe_amp(t) {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (e === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && e === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(y.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && e === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(y.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (e === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === t) {
        this.finishOp(34, 2);
        return;
      }
      e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: t
      } = this.state, e = this.input.charCodeAt(t + 1);
      if (e === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (e === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: t
      } = this.state, e = this.input.charCodeAt(t + 1);
      if (e === 62) {
        const r = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + r) === 61) {
          this.finishOp(30, r + 1);
          return;
        }
        this.finishOp(52, r);
        return;
      }
      if (e === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && e === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(y.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(y.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const e = this.input.charCodeAt(this.state.pos + 1);
          if (e === 120 || e === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (e === 111 || e === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (e === 98 || e === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if ($e(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(y.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, e) {
      const r = this.input.slice(this.state.pos, this.state.pos + e);
      this.state.pos += e, this.finishToken(t, r);
    }
    readRegexp() {
      const t = this.state.startLoc, e = this.state.start + 1;
      let r, a, {
        pos: c
      } = this.state;
      for (; ; ++c) {
        if (c >= this.length)
          throw this.raise(y.UnterminatedRegExp, o(t, 1));
        const se = this.input.charCodeAt(c);
        if (Xt(se))
          throw this.raise(y.UnterminatedRegExp, o(t, 1));
        if (r)
          r = !1;
        else {
          if (se === 91)
            a = !0;
          else if (se === 93 && a)
            a = !1;
          else if (se === 47 && !a)
            break;
          r = se === 92;
        }
      }
      const E = this.input.slice(e, c);
      ++c;
      let M = "";
      const Y = () => o(t, c + 2 - e);
      for (; c < this.length; ) {
        const se = this.codePointAtPos(c), ue = String.fromCharCode(se);
        if (ii.has(se))
          se === 118 ? M.includes("u") && this.raise(y.IncompatibleRegExpUVFlags, Y()) : se === 117 && M.includes("v") && this.raise(y.IncompatibleRegExpUVFlags, Y()), M.includes(ue) && this.raise(y.DuplicateRegExpFlags, Y());
        else if (et(se) || se === 92)
          this.raise(y.MalformedRegExpFlags, Y());
        else
          break;
        ++c, M += ue;
      }
      this.state.pos = c, this.finishToken(138, {
        pattern: E,
        flags: M
      });
    }
    readInt(t, e, r = !1, a = !0) {
      const {
        n: c,
        pos: E
      } = Nr(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, e, r, a, this.errorHandlers_readInt, !1);
      return this.state.pos = E, c;
    }
    readRadixNumber(t) {
      const e = this.state.pos, r = this.state.curPosition();
      let a = !1;
      this.state.pos += 2;
      const c = this.readInt(t);
      c == null && this.raise(y.InvalidDigit, o(r, 2), {
        radix: t
      });
      const E = this.input.charCodeAt(this.state.pos);
      if (E === 110)
        ++this.state.pos, a = !0;
      else if (E === 109)
        throw this.raise(y.InvalidDecimal, r);
      if ($e(this.codePointAtPos(this.state.pos)))
        throw this.raise(y.NumberIdentifier, this.state.curPosition());
      if (a) {
        const M = this.input.slice(e, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, M);
        return;
      }
      this.finishToken(135, c);
    }
    readNumber(t) {
      const e = this.state.pos, r = this.state.curPosition();
      let a = !1, c = !1, E = !1, M = !1;
      !t && this.readInt(10) === null && this.raise(y.InvalidNumber, this.state.curPosition());
      const Y = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
      if (Y) {
        const ke = this.input.slice(e, this.state.pos);
        if (this.recordStrictModeErrors(y.StrictOctalLiteral, r), !this.state.strict) {
          const Re = ke.indexOf("_");
          Re > 0 && this.raise(y.ZeroDigitNumericSeparator, o(r, Re));
        }
        M = Y && !/[89]/.test(ke);
      }
      let se = this.input.charCodeAt(this.state.pos);
      if (se === 46 && !M && (++this.state.pos, this.readInt(10), a = !0, se = this.input.charCodeAt(this.state.pos)), (se === 69 || se === 101) && !M && (se = this.input.charCodeAt(++this.state.pos), (se === 43 || se === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(y.InvalidOrMissingExponent, r), a = !0, E = !0, se = this.input.charCodeAt(this.state.pos)), se === 110 && ((a || Y) && this.raise(y.InvalidBigIntLiteral, r), ++this.state.pos, c = !0), se === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (E || Y) && this.raise(y.InvalidDecimal, r), ++this.state.pos;
        var ue = !0;
      }
      if ($e(this.codePointAtPos(this.state.pos)))
        throw this.raise(y.NumberIdentifier, this.state.curPosition());
      const Ee = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
      if (c) {
        this.finishToken(136, Ee);
        return;
      }
      if (ue) {
        this.finishToken(137, Ee);
        return;
      }
      const _e = M ? parseInt(Ee, 8) : parseFloat(Ee);
      this.finishToken(135, _e);
    }
    readCodePoint(t) {
      const {
        code: e,
        pos: r
      } = _r(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = r, e;
    }
    readString(t) {
      const {
        str: e,
        pos: r,
        curLine: a,
        lineStart: c
      } = Or(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = r + 1, this.state.lineStart = c, this.state.curLine = a, this.finishToken(134, e);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const t = this.input[this.state.pos], {
        str: e,
        firstInvalidLoc: r,
        pos: a,
        curLine: c,
        lineStart: E
      } = Or("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = a + 1, this.state.lineStart = E, this.state.curLine = c, r && (this.state.firstInvalidTemplateEscapePos = new l(r.curLine, r.pos - r.lineStart, this.sourceToOffsetPos(r.pos))), this.input.codePointAt(a) === 96 ? this.finishToken(24, r ? null : t + e + "`") : (this.state.pos++, this.finishToken(25, r ? null : t + e + "${"));
    }
    recordStrictModeErrors(t, e) {
      const r = e.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(t, e) : this.state.strictErrors.set(r, [t, e]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let e = "";
      const r = this.state.pos;
      let a = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const c = this.codePointAtPos(this.state.pos);
        if (et(c))
          this.state.pos += c <= 65535 ? 1 : 2;
        else if (c === 92) {
          this.state.containsEsc = !0, e += this.input.slice(a, this.state.pos);
          const E = this.state.curPosition(), M = this.state.pos === r ? $e : et;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(y.MissingUnicodeEscape, this.state.curPosition()), a = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const Y = this.readCodePoint(!0);
          Y !== null && (M(Y) || this.raise(y.EscapedCharNotAnIdentifier, E), e += String.fromCodePoint(Y)), a = this.state.pos;
        } else
          break;
      }
      return e + this.input.slice(a, this.state.pos);
    }
    readWord(t) {
      const e = this.readWord1(t), r = ne.get(e);
      r !== void 0 ? this.finishToken(r, ve(r)) : this.finishToken(132, e);
    }
    checkKeywordEscapes() {
      const {
        type: t
      } = this.state;
      at(t) && this.state.containsEsc && this.raise(y.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ve(t)
      });
    }
    raise(t, e, r = {}) {
      const a = e instanceof l ? e : e.loc.start, c = t(a, r);
      if (!(this.optionFlags & 1024)) throw c;
      return this.isLookahead || this.state.errors.push(c), c;
    }
    raiseOverwrite(t, e, r = {}) {
      const a = e instanceof l ? e : e.loc.start, c = a.index, E = this.state.errors;
      for (let M = E.length - 1; M >= 0; M--) {
        const Y = E[M];
        if (Y.loc.index === c)
          return E[M] = t(a, r);
        if (Y.loc.index < c) break;
      }
      return this.raise(t, e, r);
    }
    updateContext(t) {
    }
    unexpected(t, e) {
      throw this.raise(y.UnexpectedToken, t ?? this.state.startLoc, {
        expected: e ? ve(e) : null
      });
    }
    expectPlugin(t, e) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(y.MissingPlugin, e ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((e) => this.hasPlugin(e)))
        throw this.raise(y.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (e, r, a) => {
        this.raise(t, zt(e, r, a));
      };
    }
  }
  class si {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class ai {
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new si());
    }
    exit() {
      const t = this.stack.pop(), e = this.current();
      for (const [r, a] of Array.from(t.undefinedPrivateNames))
        e ? e.undefinedPrivateNames.has(r) || e.undefinedPrivateNames.set(r, a) : this.parser.raise(y.InvalidPrivateFieldResolution, a, {
          identifierName: r
        });
    }
    declarePrivateName(t, e, r) {
      const {
        privateNames: a,
        loneAccessors: c,
        undefinedPrivateNames: E
      } = this.current();
      let M = a.has(t);
      if (e & 3) {
        const Y = M && c.get(t);
        if (Y) {
          const se = Y & 4, ue = e & 4, Ee = Y & 3, _e = e & 3;
          M = Ee === _e || se !== ue, M || c.delete(t);
        } else M || c.set(t, e);
      }
      M && this.parser.raise(y.PrivateNameRedeclaration, r, {
        identifierName: t
      }), a.add(t), E.delete(t);
    }
    usePrivateName(t, e) {
      let r;
      for (r of this.stack)
        if (r.privateNames.has(t)) return;
      r ? r.undefinedPrivateNames.set(t, e) : this.parser.raise(y.InvalidPrivateFieldResolution, e, {
        identifierName: t
      });
    }
  }
  class sr {
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class Dr extends sr {
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, e) {
      const r = e.index;
      this.declarationErrors.set(r, [t, e]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }
  class oi {
    constructor(t) {
      this.parser = void 0, this.stack = [new sr()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, e) {
      const r = e.loc.start, {
        stack: a
      } = this;
      let c = a.length - 1, E = a[c];
      for (; !E.isCertainlyParameterDeclaration(); ) {
        if (E.canBeArrowParameterDeclaration())
          E.recordDeclarationError(t, r);
        else
          return;
        E = a[--c];
      }
      this.parser.raise(t, r);
    }
    recordArrowParameterBindingError(t, e) {
      const {
        stack: r
      } = this, a = r[r.length - 1], c = e.loc.start;
      if (a.isCertainlyParameterDeclaration())
        this.parser.raise(t, c);
      else if (a.canBeArrowParameterDeclaration())
        a.recordDeclarationError(t, c);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      const {
        stack: e
      } = this;
      let r = e.length - 1, a = e[r];
      for (; a.canBeArrowParameterDeclaration(); )
        a.type === 2 && a.recordDeclarationError(y.AwaitBindingIdentifier, t), a = e[--r];
    }
    validateAsPattern() {
      const {
        stack: t
      } = this, e = t[t.length - 1];
      e.canBeArrowParameterDeclaration() && e.iterateErrors(([r, a]) => {
        this.parser.raise(r, a);
        let c = t.length - 2, E = t[c];
        for (; E.canBeArrowParameterDeclaration(); )
          E.clearDeclarationError(a.index), E = t[--c];
      });
    }
  }
  function li() {
    return new sr(3);
  }
  function ui() {
    return new Dr(1);
  }
  function ci() {
    return new Dr(2);
  }
  function kr() {
    return new sr();
  }
  class pi {
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }
  function ar(b, t) {
    return (b ? 2 : 0) | (t ? 1 : 0);
  }
  class fi extends ni {
    addExtra(t, e, r, a = !0) {
      if (!t) return;
      let {
        extra: c
      } = t;
      c == null && (c = {}, t.extra = c), a ? c[e] = r : Object.defineProperty(c, e, {
        enumerable: a,
        value: r
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, e) {
      const r = t + e.length;
      if (this.input.slice(t, r) === e) {
        const a = this.input.charCodeAt(r);
        return !(et(a) || (a & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      const e = this.nextTokenStart();
      return this.isUnparsedContextual(e, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, e) {
      if (!this.eatContextual(t)) {
        if (e != null)
          throw this.raise(e, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Ir(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return Ir(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(y.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, e) {
      this.eat(t) || this.unexpected(e, t);
    }
    tryParse(t, e = this.state.clone()) {
      const r = {
        node: null
      };
      try {
        const a = t((c = null) => {
          throw r.node = c, r;
        });
        if (this.state.errors.length > e.errors.length) {
          const c = this.state;
          return this.state = e, this.state.tokensLength = c.tokensLength, {
            node: a,
            error: c.errors[e.errors.length],
            thrown: !1,
            aborted: !1,
            failState: c
          };
        }
        return {
          node: a,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (a) {
        const c = this.state;
        if (this.state = e, a instanceof SyntaxError)
          return {
            node: null,
            error: a,
            thrown: !0,
            aborted: !1,
            failState: c
          };
        if (a === r)
          return {
            node: r.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: c
          };
        throw a;
      }
    }
    checkExpressionErrors(t, e) {
      if (!t) return !1;
      const {
        shorthandAssignLoc: r,
        doubleProtoLoc: a,
        privateKeyLoc: c,
        optionalParametersLoc: E
      } = t, M = !!r || !!a || !!E || !!c;
      if (!e)
        return M;
      r != null && this.raise(y.InvalidCoverInitializedName, r), a != null && this.raise(y.DuplicateProto, a), c != null && this.raise(y.UnexpectedPrivateField, c), E != null && this.unexpected(E);
    }
    isLiteralPropertyName() {
      return Ue(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      const e = this.state.labels;
      this.state.labels = [];
      const r = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const a = this.inModule;
      this.inModule = t;
      const c = this.scope, E = this.getScopeHandler();
      this.scope = new E(this, t);
      const M = this.prodParam;
      this.prodParam = new pi();
      const Y = this.classScope;
      this.classScope = new ai(this);
      const se = this.expressionScope;
      return this.expressionScope = new oi(this), () => {
        this.state.labels = e, this.exportedIdentifiers = r, this.inModule = a, this.scope = c, this.prodParam = M, this.classScope = Y, this.expressionScope = se;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      const {
        privateKeyLoc: e
      } = t;
      e !== null && this.expectPlugin("destructuringPrivate", e);
    }
  }
  class or {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class lr {
    constructor(t, e, r) {
      this.type = "", this.start = e, this.end = 0, this.loc = new u(r), (t == null ? void 0 : t.optionFlags) & 64 && (this.range = [e, 0]), t != null && t.filename && (this.loc.filename = t.filename);
    }
  }
  const Tr = lr.prototype;
  Tr.__clone = function() {
    const b = new lr(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let e = 0, r = t.length; e < r; e++) {
      const a = t[e];
      a !== "leadingComments" && a !== "trailingComments" && a !== "innerComments" && (b[a] = this[a]);
    }
    return b;
  };
  function hi(b) {
    return wt(b);
  }
  function wt(b) {
    const {
      type: t,
      start: e,
      end: r,
      loc: a,
      range: c,
      extra: E,
      name: M
    } = b, Y = Object.create(Tr);
    return Y.type = t, Y.start = e, Y.end = r, Y.loc = a, Y.range = c, Y.extra = E, Y.name = M, t === "Placeholder" && (Y.expectedNode = b.expectedNode), Y;
  }
  function di(b) {
    const {
      type: t,
      start: e,
      end: r,
      loc: a,
      range: c,
      extra: E
    } = b;
    if (t === "Placeholder")
      return hi(b);
    const M = Object.create(Tr);
    return M.type = t, M.start = e, M.end = r, M.loc = a, M.range = c, b.raw !== void 0 ? M.raw = b.raw : M.extra = E, M.value = b.value, M;
  }
  class mi extends fi {
    startNode() {
      const t = this.state.startLoc;
      return new lr(this, t.index, t);
    }
    startNodeAt(t) {
      return new lr(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, e) {
      return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, e, r) {
      return t.type = e, t.end = r.index, t.loc.end = r, this.optionFlags & 64 && (t.range[1] = r.index), this.optionFlags & 2048 && this.processComment(t), t;
    }
    resetStartLocation(t, e) {
      t.start = e.index, t.loc.start = e, this.optionFlags & 64 && (t.range[0] = e.index);
    }
    resetEndLocation(t, e = this.state.lastTokEndLoc) {
      t.end = e.index, t.loc.end = e, this.optionFlags & 64 && (t.range[1] = e.index);
    }
    resetStartLocationFromNode(t, e) {
      this.resetStartLocation(t, e.loc.start);
    }
  }
  const yi = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Ve = B`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType: b
    }) => `Cannot overwrite reserved type ${b}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName: b,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${b} = true,\` or \`${b} = false,\` in enum \`${t}\`.`,
    EnumDuplicateMemberName: ({
      memberName: b,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${b}\` has already been used before in enum \`${t}\`.`,
    EnumInconsistentMemberValues: ({
      enumName: b
    }) => `Enum \`${b}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType: b,
      enumName: t
    }) => `Enum type \`${b}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName: b
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${b}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName: b,
      memberName: t,
      explicitType: e
    }) => `Enum \`${b}\` has type \`${e}\`, so the initializer of \`${t}\` needs to be a ${e} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName: b,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${b}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName: b,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${b}\`.`,
    EnumInvalidMemberName: ({
      enumName: b,
      memberName: t,
      suggestion: e
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${e}\`, in enum \`${b}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName: b,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${b}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName: b
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${b}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType: b
    }) => `Unexpected reserved type ${b}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind: b,
      suggestion: t
    }) => `\`declare export ${b}\` is not supported. Use \`${t}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function Ti(b) {
    return b.type === "DeclareExportAllDeclaration" || b.type === "DeclareExportDeclaration" && (!b.declaration || b.declaration.type !== "TypeAlias" && b.declaration.type !== "InterfaceDeclaration");
  }
  function Lr(b) {
    return b.importKind === "type" || b.importKind === "typeof";
  }
  const Si = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function gi(b, t) {
    const e = [], r = [];
    for (let a = 0; a < b.length; a++)
      (t(b[a], a, b) ? e : r).push(b[a]);
    return [e, r];
  }
  const bi = /\*?\s*@((?:no)?flow)\b/;
  var Ei = (b) => class extends b {
    constructor(...e) {
      super(...e), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Yr;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(e, r) {
      e !== 134 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, r);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        const r = bi.exec(e.value);
        if (r) if (r[1] === "flow")
          this.flowPragma = "flow";
        else if (r[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      const r = this.state.inType;
      this.state.inType = !0, this.expect(e || 14);
      const a = this.flowParseType();
      return this.state.inType = r, a;
    }
    flowParsePredicate() {
      const e = this.startNode(), r = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > r.index + 1 && this.raise(Ve.UnexpectedSpaceBetweenModuloChecks, r), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let r = null, a = null;
      return this.match(54) ? (this.state.inType = e, a = this.flowParsePredicate()) : (r = this.flowParseType(), this.state.inType = e, this.match(54) && (a = this.flowParsePredicate())), [r, a];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      const r = e.id = this.parseIdentifier(), a = this.startNode(), c = this.startNode();
      this.match(47) ? a.typeParameters = this.flowParseTypeParameterDeclaration() : a.typeParameters = null, this.expect(10);
      const E = this.flowParseFunctionTypeParams();
      return a.params = E.params, a.rest = E.rest, a.this = E._this, this.expect(11), [a.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), c.typeAnnotation = this.finishNode(a, "FunctionTypeAnnotation"), r.typeAnnotation = this.finishNode(c, "TypeAnnotation"), this.resetEndLocation(r), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, r) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (r && this.raise(Ve.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, r);
      this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(0), this.match(134) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
      const r = e.body = this.startNode(), a = r.body = [];
      for (this.expect(5); !this.match(8); ) {
        let M = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ve.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(M)) : (this.expectContextual(125, Ve.UnsupportedStatementInDeclareModule), M = this.flowParseDeclare(M, !0)), a.push(M);
      }
      this.scope.exit(), this.expect(8), this.finishNode(r, "BlockStatement");
      let c = null, E = !1;
      return a.forEach((M) => {
        Ti(M) ? (c === "CommonJS" && this.raise(Ve.AmbiguousDeclareModuleKind, M), c = "ES") : M.type === "DeclareModuleExports" && (E && this.raise(Ve.DuplicateDeclareModuleExports, M), c === "ES" && this.raise(Ve.AmbiguousDeclareModuleKind, M), c = "CommonJS", E = !0);
      }), e.kind = c || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, r) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = !0, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !r) {
        const a = this.state.value;
        throw this.raise(Ve.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: a,
          suggestion: Si[a]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = !1, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = !1, delete e.exportKind), e.type = "Declare" + e.type, e;
      this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(111), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      this.next();
      const r = this.flowParseTypeAlias(e);
      return r.type = "DeclareTypeAlias", r;
    }
    flowParseDeclareOpaqueType(e) {
      this.next();
      const r = this.flowParseOpaqueType(e, !0);
      return r.type = "DeclareOpaqueType", r;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e, r) {
      if (e.id = this.flowParseRestrictedIdentifier(!r, !0), this.scope.declareName(e.id.name, r ? 17 : 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!r && this.eat(12));
      if (r) {
        if (e.implements = [], e.mixins = [], this.eatContextual(117))
          do
            e.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            e.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      e.body = this.flowParseObjectType({
        allowStatic: r,
        allowExact: !1,
        allowSpread: !1,
        allowProto: r,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      const e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e, !1), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(Ve.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(e, r, a) {
      yi.has(e) && this.raise(a ? Ve.AssignReservedType : Ve.UnexpectedReservedType, r, {
        reservedType: e
      });
    }
    flowParseRestrictedIdentifier(e, r) {
      return this.checkReservedType(this.state.value, this.state.startLoc, r), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, r) {
      return this.expectContextual(130), e.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, r || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter(e = !1) {
      const r = this.state.startLoc, a = this.startNode(), c = this.flowParseVariance(), E = this.flowParseTypeAnnotatableIdentifier();
      return a.name = E.name, a.variance = c, a.bound = E.typeAnnotation, this.match(29) ? (this.eat(29), a.default = this.flowParseType()) : e && this.raise(Ve.MissingTypeParamDefault, r), this.finishNode(a, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e = this.state.inType, r = this.startNode();
      r.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let a = !1;
      do {
        const c = this.flowParseTypeParameter(a);
        r.params.push(c), c.default && (a = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(r, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(e) {
      if (this.curContext() !== q.brace) {
        const r = this.state.context;
        this.state.context = [r[0]];
        try {
          return e();
        } finally {
          this.state.context = r;
        }
      } else
        return e();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      const e = this.startNode(), r = this.state.inType;
      return this.state.inType = !0, e.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        const a = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = a;
      }), this.state.inType = r, !this.state.inType && this.curContext() === q.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      const e = this.startNode(), r = this.state.inType;
      for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = r, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e = this.startNode();
      if (this.expectContextual(129), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(e, r, a) {
      return e.static = r, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = a, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, r) {
      return e.static = r, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = !0, e.optional = !1, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = !1, this.eat(17) && (e.optional = !0), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(!0), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, r) {
      const a = this.startNode();
      return e.static = r, e.value = this.flowParseObjectTypeMethodish(a), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: e,
      allowExact: r,
      allowSpread: a,
      allowProto: c,
      allowInexact: E
    }) {
      const M = this.state.inType;
      this.state.inType = !0;
      const Y = this.startNode();
      Y.callProperties = [], Y.properties = [], Y.indexers = [], Y.internalSlots = [];
      let se, ue, Ee = !1;
      for (r && this.match(6) ? (this.expect(6), se = 9, ue = !0) : (this.expect(5), se = 8, ue = !1), Y.exact = ue; !this.match(se); ) {
        let ke = !1, Re = null, Qe = null;
        const mt = this.startNode();
        if (c && this.isContextual(118)) {
          const ut = this.lookahead();
          ut.type !== 14 && ut.type !== 17 && (this.next(), Re = this.state.startLoc, e = !1);
        }
        if (e && this.isContextual(106)) {
          const ut = this.lookahead();
          ut.type !== 14 && ut.type !== 17 && (this.next(), ke = !0);
        }
        const tt = this.flowParseVariance();
        if (this.eat(0))
          Re != null && this.unexpected(Re), this.eat(0) ? (tt && this.unexpected(tt.loc.start), Y.internalSlots.push(this.flowParseObjectTypeInternalSlot(mt, ke))) : Y.indexers.push(this.flowParseObjectTypeIndexer(mt, ke, tt));
        else if (this.match(10) || this.match(47))
          Re != null && this.unexpected(Re), tt && this.unexpected(tt.loc.start), Y.callProperties.push(this.flowParseObjectTypeCallProperty(mt, ke));
        else {
          let ut = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const Zt = this.lookahead();
            Ue(Zt.type) && (ut = this.state.value, this.next());
          }
          const ur = this.flowParseObjectTypeProperty(mt, ke, Re, tt, ut, a, E ?? !ue);
          ur === null ? (Ee = !0, Qe = this.state.lastTokStartLoc) : Y.properties.push(ur);
        }
        this.flowObjectTypeSemicolon(), Qe && !this.match(8) && !this.match(9) && this.raise(Ve.UnexpectedExplicitInexactInObject, Qe);
      }
      this.expect(se), a && (Y.inexact = Ee);
      const _e = this.finishNode(Y, "ObjectTypeAnnotation");
      return this.state.inType = M, _e;
    }
    flowParseObjectTypeProperty(e, r, a, c, E, M, Y) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (M ? Y || this.raise(Ve.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(Ve.InexactInsideNonObject, this.state.lastTokStartLoc), c && this.raise(Ve.InexactVariance, c), null) : (M || this.raise(Ve.UnexpectedSpreadType, this.state.lastTokStartLoc), a != null && this.unexpected(a), c && this.raise(Ve.SpreadVariance, c), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = r, e.proto = a != null, e.kind = E;
        let se = !1;
        return this.match(47) || this.match(10) ? (e.method = !0, a != null && this.unexpected(a), c && this.unexpected(c.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (E === "get" || E === "set") && this.flowCheckGetterSetterParams(e), !M && e.key.name === "constructor" && e.value.this && this.raise(Ve.ThisParamBannedInConstructor, e.value.this)) : (E !== "init" && this.unexpected(), e.method = !1, this.eat(17) && (se = !0), e.value = this.flowParseTypeInitialiser(), e.variance = c), e.optional = se, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      const r = e.kind === "get" ? 0 : 1, a = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? Ve.GetterMayNotHaveThisParam : Ve.SetterMayNotHaveThisParam, e.value.this), a !== r && this.raise(e.kind === "get" ? y.BadGetterArity : y.BadSetterArity, e), e.kind === "set" && e.value.rest && this.raise(y.BadSetterRestParameter, e);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, r) {
      var a;
      (a = e) != null || (e = this.state.startLoc);
      let c = r || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        const E = this.startNodeAt(e);
        E.qualification = c, E.id = this.flowParseRestrictedIdentifier(!0), c = this.finishNode(E, "QualifiedTypeIdentifier");
      }
      return c;
    }
    flowParseGenericType(e, r) {
      const a = this.startNodeAt(e);
      return a.typeParameters = null, a.id = this.flowParseQualifiedTypeIdentifier(e, r), this.match(47) && (a.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(a, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let r = null, a = !1, c = null;
      const E = this.startNode(), M = this.lookahead(), Y = this.state.type === 78;
      return M.type === 14 || M.type === 17 ? (Y && !e && this.raise(Ve.ThisParamMustBeFirst, E), r = this.parseIdentifier(Y), this.eat(17) && (a = !0, Y && this.raise(Ve.ThisParamMayNotBeOptional, E)), c = this.flowParseTypeInitialiser()) : c = this.flowParseType(), E.name = r, E.optional = a, E.typeAnnotation = c, this.finishNode(E, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      const r = this.startNodeAt(e.loc.start);
      return r.name = null, r.optional = !1, r.typeAnnotation = e, this.finishNode(r, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e = []) {
      let r = null, a = null;
      for (this.match(78) && (a = this.flowParseFunctionTypeParam(!0), a.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r = this.flowParseFunctionTypeParam(!1)), {
        params: e,
        rest: r,
        _this: a
      };
    }
    flowIdentToTypeAnnotation(e, r, a) {
      switch (a.name) {
        case "any":
          return this.finishNode(r, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(r, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(r, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(r, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(r, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(r, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(r, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(a.name), this.flowParseGenericType(e, a);
      }
    }
    flowParsePrimaryType() {
      const e = this.state.startLoc, r = this.startNode();
      let a, c, E = !1;
      const M = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, c = this.flowParseTupleType(), this.state.noAnonFunctionType = M, c;
        case 47: {
          const Y = this.startNode();
          return Y.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), a = this.flowParseFunctionTypeParams(), Y.params = a.params, Y.rest = a.rest, Y.this = a._this, this.expect(11), this.expect(19), Y.returnType = this.flowParseType(), this.finishNode(Y, "FunctionTypeAnnotation");
        }
        case 10: {
          const Y = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (fe(this.state.type) || this.match(78)) {
              const se = this.lookahead().type;
              E = se !== 17 && se !== 14;
            } else
              E = !0;
          if (E) {
            if (this.state.noAnonFunctionType = !1, c = this.flowParseType(), this.state.noAnonFunctionType = M, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), c;
            this.eat(12);
          }
          return c ? a = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(c)]) : a = this.flowParseFunctionTypeParams(), Y.params = a.params, Y.rest = a.rest, Y.this = a._this, this.expect(11), this.expect(19), Y.returnType = this.flowParseType(), Y.typeParameters = null, this.finishNode(Y, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
            throw this.raise(Ve.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(r, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(r, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (at(this.state.type)) {
            const Y = ve(this.state.type);
            return this.next(), super.createIdentifier(r, Y);
          } else if (fe(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, r, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const e = this.state.startLoc;
      let r = this.flowParsePrimaryType(), a = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const c = this.startNodeAt(e), E = this.eat(18);
        a = a || E, this.expect(0), !E && this.match(3) ? (c.elementType = r, this.next(), r = this.finishNode(c, "ArrayTypeAnnotation")) : (c.objectType = r, c.indexType = this.flowParseType(), this.expect(3), a ? (c.optional = E, r = this.finishNode(c, "OptionalIndexedAccessType")) : r = this.finishNode(c, "IndexedAccessType"));
      }
      return r;
    }
    flowParsePrefixType() {
      const e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const r = this.startNodeAt(e.loc.start);
        return r.params = [this.reinterpretTypeAsFunctionTypeParam(e)], r.rest = null, r.this = null, r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      const e = this.startNode();
      this.eat(45);
      const r = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [r]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? r : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e = this.startNode();
      this.eat(43);
      const r = this.flowParseIntersectionType();
      for (e.types = [r]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? r : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e = this.state.inType;
      this.state.inType = !0;
      const r = this.flowParseUnionType();
      return this.state.inType = e, r;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const e = this.state.startLoc, r = this.parseIdentifier();
        return this.flowParseGenericType(e, r);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      const r = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r)), r;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
    }
    parseFunctionBody(e, r, a = !1) {
      if (r) {
        this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, a));
        return;
      }
      super.parseFunctionBody(e, !1, a);
    }
    parseFunctionBodyAndFinish(e, r, a = !1) {
      if (this.match(14)) {
        const c = this.startNode();
        [c.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = c.typeAnnotation ? this.finishNode(c, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(e, r, a);
    }
    parseStatementLike(e) {
      if (this.state.strict && this.isContextual(129)) {
        const a = this.lookahead();
        if (de(a.type)) {
          const c = this.startNode();
          return this.next(), this.flowParseInterface(c);
        }
      } else if (this.isContextual(126)) {
        const a = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(a);
      }
      const r = super.parseStatementLike(e);
      return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
    }
    parseExpressionStatement(e, r, a) {
      if (r.type === "Identifier") {
        if (r.name === "declare") {
          if (this.match(80) || fe(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (fe(this.state.type)) {
          if (r.name === "interface")
            return this.flowParseInterface(e);
          if (r.name === "type")
            return this.flowParseTypeAlias(e);
          if (r.name === "opaque")
            return this.flowParseOpaqueType(e, !1);
        }
      }
      return super.parseExpressionStatement(e, r, a);
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      return e === 126 || qe(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      return e === 126 || qe(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        const e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, r, a) {
      if (!this.match(17)) return e;
      if (this.state.maybeInArrowParameters) {
        const _e = this.lookaheadCharCode();
        if (_e === 44 || _e === 61 || _e === 58 || _e === 41)
          return this.setOptionalParametersError(a), e;
      }
      this.expect(17);
      const c = this.state.clone(), E = this.state.noArrowAt, M = this.startNodeAt(r);
      let {
        consequent: Y,
        failed: se
      } = this.tryParseConditionalConsequent(), [ue, Ee] = this.getArrowLikeExpressions(Y);
      if (se || Ee.length > 0) {
        const _e = [...E];
        if (Ee.length > 0) {
          this.state = c, this.state.noArrowAt = _e;
          for (let ke = 0; ke < Ee.length; ke++)
            _e.push(Ee[ke].start);
          ({
            consequent: Y,
            failed: se
          } = this.tryParseConditionalConsequent()), [ue, Ee] = this.getArrowLikeExpressions(Y);
        }
        se && ue.length > 1 && this.raise(Ve.AmbiguousConditionalArrow, c.startLoc), se && ue.length === 1 && (this.state = c, _e.push(ue[0].start), this.state.noArrowAt = _e, {
          consequent: Y,
          failed: se
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(Y, !0), this.state.noArrowAt = E, this.expect(14), M.test = e, M.consequent = Y, M.alternate = this.forwardNoArrowParamsConversionAt(M, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(M, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e = this.parseMaybeAssignAllowIn(), r = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: e,
        failed: r
      };
    }
    getArrowLikeExpressions(e, r) {
      const a = [e], c = [];
      for (; a.length !== 0; ) {
        const E = a.pop();
        E.type === "ArrowFunctionExpression" && E.body.type !== "BlockStatement" ? (E.typeParameters || !E.returnType ? this.finishArrowValidation(E) : c.push(E), a.push(E.body)) : E.type === "ConditionalExpression" && (a.push(E.consequent), a.push(E.alternate));
      }
      return r ? (c.forEach((E) => this.finishArrowValidation(E)), [c, []]) : gi(c, (E) => E.params.every((M) => this.isAssignable(M, !0)));
    }
    finishArrowValidation(e) {
      var r;
      this.toAssignableList(e.params, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, r) {
      let a;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), a = r(), this.state.noArrowParamsConversionAt.pop()) : a = r(), a;
    }
    parseParenItem(e, r) {
      const a = super.parseParenItem(e, r);
      if (this.eat(17) && (a.optional = !0, this.resetEndLocation(e)), this.match(14)) {
        const c = this.startNodeAt(r);
        return c.expression = a, c.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(c, "TypeCastExpression");
      }
      return a;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExportDeclaration(e) {
      if (this.isContextual(130)) {
        e.exportKind = "type";
        const r = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(e), null) : this.flowParseTypeAlias(r);
      } else if (this.isContextual(131)) {
        e.exportKind = "type";
        const r = this.startNode();
        return this.next(), this.flowParseOpaqueType(r, !1);
      } else if (this.isContextual(129)) {
        e.exportKind = "type";
        const r = this.startNode();
        return this.next(), this.flowParseInterface(r);
      } else if (this.isContextual(126)) {
        e.exportKind = "value";
        const r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(e) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      const {
        startLoc: r
      } = this.state, a = super.maybeParseExportNamespaceSpecifier(e);
      return a && e.exportKind === "type" && this.unexpected(r), a;
    }
    parseClassId(e, r, a) {
      super.parseClassId(e, r, a), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, r, a) {
      const {
        startLoc: c
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(e, r))
          return;
        r.declare = !0;
      }
      super.parseClassMember(e, r, a), r.declare && (r.type !== "ClassProperty" && r.type !== "ClassPrivateProperty" && r.type !== "PropertyDefinition" ? this.raise(Ve.DeclareClassElement, c) : r.value && this.raise(Ve.DeclareClassFieldInitializer, r.value));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      const e = super.readWord1(), r = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(y.InvalidIdentifier, this.state.curPosition(), {
        identifierName: r
      }), this.finishToken(132, r);
    }
    getTokenFromCode(e) {
      const r = this.input.charCodeAt(this.state.pos + 1);
      e === 123 && r === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? r === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : At(e, r, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, r) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, r) : super.isAssignable(e, r);
    }
    toAssignable(e, r = !1) {
      !r && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, r);
    }
    toAssignableList(e, r, a) {
      for (let c = 0; c < e.length; c++) {
        const E = e[c];
        (E == null ? void 0 : E.type) === "TypeCastExpression" && (e[c] = this.typeCastToParameter(E));
      }
      super.toAssignableList(e, r, a);
    }
    toReferencedList(e, r) {
      for (let c = 0; c < e.length; c++) {
        var a;
        const E = e[c];
        E && E.type === "TypeCastExpression" && !((a = E.extra) != null && a.parenthesized) && (e.length > 1 || !r) && this.raise(Ve.TypeCastInPattern, E.typeAnnotation);
      }
      return e;
    }
    parseArrayLike(e, r, a, c) {
      const E = super.parseArrayLike(e, r, a, c);
      return r && !this.state.maybeInArrowParameters && this.toReferencedList(E.elements), E;
    }
    isValidLVal(e, r, a) {
      return e === "TypeCastExpression" || super.isValidLVal(e, r, a);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, r, a, c, E, M) {
      if (r.variance && this.unexpected(r.variance.loc.start), delete r.variance, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, r, a, c, E, M), r.params && E) {
        const Y = r.params;
        Y.length > 0 && this.isThisParam(Y[0]) && this.raise(Ve.ThisParamBannedInConstructor, r);
      } else if (r.type === "MethodDefinition" && E && r.value.params) {
        const Y = r.value.params;
        Y.length > 0 && this.isThisParam(Y[0]) && this.raise(Ve.ThisParamBannedInConstructor, r);
      }
    }
    pushClassPrivateMethod(e, r, a, c) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, r, a, c);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
        this.next();
        const r = e.implements = [];
        do {
          const a = this.startNode();
          a.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? a.typeParameters = this.flowParseTypeParameterInstantiation() : a.typeParameters = null, r.push(this.finishNode(a, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      const r = this.getObjectOrClassMethodParams(e);
      if (r.length > 0) {
        const a = r[0];
        this.isThisParam(a) && e.kind === "get" ? this.raise(Ve.GetterMayNotHaveThisParam, a) : this.isThisParam(a) && this.raise(Ve.SetterMayNotHaveThisParam, a);
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, r, a, c, E, M, Y) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let se;
      this.match(47) && !M && (se = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const ue = super.parseObjPropValue(e, r, a, c, E, M, Y);
      return se && ((ue.value || ue).typeParameters = se), ue;
    }
    parseFunctionParamType(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(Ve.PatternIsOptional, e), this.isThisParam(e) && this.raise(Ve.ThisParamMayNotBeOptional, e), e.optional = !0), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(Ve.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(Ve.ThisParamNoDefault, e), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, r) {
      const a = super.parseMaybeDefault(e, r);
      return a.type === "AssignmentPattern" && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(Ve.TypeBeforeInitializer, a.typeAnnotation), a;
    }
    checkImportReflection(e) {
      super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(Ve.ImportReflectionHasImportType, e.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(e, r, a) {
      r.local = Lr(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, a));
    }
    isPotentialImportPhase(e) {
      if (super.isPotentialImportPhase(e)) return !0;
      if (this.isContextual(130)) {
        if (!e) return !0;
        const r = this.lookaheadCharCode();
        return r === 123 || r === 42;
      }
      return !e && this.isContextual(87);
    }
    applyImportPhase(e, r, a, c) {
      if (super.applyImportPhase(e, r, a, c), r) {
        if (!a && this.match(65))
          return;
        e.exportKind = a === "type" ? a : "value";
      } else
        a === "type" && this.match(55) && this.unexpected(), e.importKind = a === "type" || a === "typeof" ? a : "value";
    }
    parseImportSpecifier(e, r, a, c, E) {
      const M = e.imported;
      let Y = null;
      M.type === "Identifier" && (M.name === "type" ? Y = "type" : M.name === "typeof" && (Y = "typeof"));
      let se = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const Ee = this.parseIdentifier(!0);
        Y !== null && !de(this.state.type) ? (e.imported = Ee, e.importKind = Y, e.local = wt(Ee)) : (e.imported = M, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (Y !== null && de(this.state.type))
          e.imported = this.parseIdentifier(!0), e.importKind = Y;
        else {
          if (r)
            throw this.raise(y.ImportBindingIsString, e, {
              importName: M.value
            });
          e.imported = M, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (se = !0, e.local = wt(e.imported));
      }
      const ue = Lr(e);
      return a && ue && this.raise(Ve.ImportTypeShorthandOnlyInPureImport, e), (a || ue) && this.checkReservedType(e.local.name, e.local.loc.start, !0), se && !a && !ue && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, r) {
      const a = e.kind;
      a !== "get" && a !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, r);
    }
    parseVarId(e, r) {
      super.parseVarId(e, r), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, r) {
      if (this.match(14)) {
        const a = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = a;
      }
      return super.parseAsyncArrowFromCallExpression(e, r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, r) {
      var a;
      let c = null, E;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), E = this.tryParse(() => super.parseMaybeAssign(e, r), c), !E.error) return E.node;
        const {
          context: se
        } = this.state, ue = se[se.length - 1];
        (ue === q.j_oTag || ue === q.j_expr) && se.pop();
      }
      if ((a = E) != null && a.error || this.match(47)) {
        var M, Y;
        c = c || this.state.clone();
        let se;
        const ue = this.tryParse((_e) => {
          var ke;
          se = this.flowParseTypeParameterDeclaration();
          const Re = this.forwardNoArrowParamsConversionAt(se, () => {
            const mt = super.parseMaybeAssign(e, r);
            return this.resetStartLocationFromNode(mt, se), mt;
          });
          (ke = Re.extra) != null && ke.parenthesized && _e();
          const Qe = this.maybeUnwrapTypeCastExpression(Re);
          return Qe.type !== "ArrowFunctionExpression" && _e(), Qe.typeParameters = se, this.resetStartLocationFromNode(Qe, se), Re;
        }, c);
        let Ee = null;
        if (ue.node && this.maybeUnwrapTypeCastExpression(ue.node).type === "ArrowFunctionExpression") {
          if (!ue.error && !ue.aborted)
            return ue.node.async && this.raise(Ve.UnexpectedTypeParameterBeforeAsyncArrowFunction, se), ue.node;
          Ee = ue.node;
        }
        if ((M = E) != null && M.node)
          return this.state = E.failState, E.node;
        if (Ee)
          return this.state = ue.failState, Ee;
        throw (Y = E) != null && Y.thrown ? E.error : ue.thrown ? ue.error : this.raise(Ve.UnexpectedTokenAfterTypeParameter, se);
      }
      return super.parseMaybeAssign(e, r);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const r = this.tryParse(() => {
          const a = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const c = this.startNode();
          return [c.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = a, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), c;
        });
        if (r.thrown) return null;
        r.error && (this.state = r.failState), e.returnType = r.node.typeAnnotation ? this.finishNode(r.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, r) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? e.params = r : super.setArrowFunctionParameters(e, r);
    }
    checkParams(e, r, a, c = !0) {
      if (!(a && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)))) {
        for (let E = 0; E < e.params.length; E++)
          this.isThisParam(e.params[E]) && E > 0 && this.raise(Ve.ThisParamMustBeFirst, e.params[E]);
        super.checkParams(e, r, a, c);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(e, r, a) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.includes(r.index)) {
        this.next();
        const c = this.startNodeAt(r);
        c.callee = e, c.arguments = super.parseCallExpressionArguments(11), e = this.finishNode(c, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        const c = this.state.clone(), E = this.tryParse((Y) => this.parseAsyncArrowWithTypeParameters(r) || Y(), c);
        if (!E.error && !E.aborted) return E.node;
        const M = this.tryParse(() => super.parseSubscripts(e, r, a), c);
        if (M.node && !M.error) return M.node;
        if (E.node)
          return this.state = E.failState, E.node;
        if (M.node)
          return this.state = M.failState, M.node;
        throw E.error || M.error;
      }
      return super.parseSubscripts(e, r, a);
    }
    parseSubscript(e, r, a, c) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (c.optionalChainMember = !0, a)
          return c.stop = !0, e;
        this.next();
        const E = this.startNodeAt(r);
        return E.callee = e, E.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), E.arguments = this.parseCallExpressionArguments(11), E.optional = !0, this.finishCallExpression(E, !0);
      } else if (!a && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        const E = this.startNodeAt(r);
        E.callee = e;
        const M = this.tryParse(() => (E.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), E.arguments = super.parseCallExpressionArguments(11), c.optionalChainMember && (E.optional = !1), this.finishCallExpression(E, c.optionalChainMember)));
        if (M.node)
          return M.error && (this.state = M.failState), M.node;
      }
      return super.parseSubscript(e, r, a, c);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let r = null;
      this.shouldParseTypes() && this.match(47) && (r = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = r;
    }
    parseAsyncArrowWithTypeParameters(e) {
      const r = this.startNodeAt(e);
      if (this.parseFunctionParams(r, !1), !!this.parseArrow(r))
        return super.parseArrowExpression(r, void 0, !0);
    }
    readToken_mult_modulo(e) {
      const r = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && r === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      const r = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && r === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, r) {
      const a = super.parseTopLevel(e, r);
      return this.state.hasFlowComment && this.raise(Ve.UnterminatedFlowComment, this.state.curPosition()), a;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ve.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const e = this.skipFlowComment();
        e && (this.state.pos += e, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos: e
      } = this.state;
      let r = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + r)); )
        r++;
      const a = this.input.charCodeAt(r + e), c = this.input.charCodeAt(r + e + 1);
      return a === 58 && c === 58 ? r + 2 : this.input.slice(r + e, r + e + 12) === "flow-include" ? r + 12 : a === 58 && c !== 58 ? r : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(y.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(e, {
      enumName: r,
      memberName: a
    }) {
      this.raise(Ve.EnumBooleanMemberNotInitialized, e, {
        memberName: a,
        enumName: r
      });
    }
    flowEnumErrorInvalidMemberInitializer(e, r) {
      return this.raise(r.explicitType ? r.explicitType === "symbol" ? Ve.EnumInvalidMemberInitializerSymbolType : Ve.EnumInvalidMemberInitializerPrimaryType : Ve.EnumInvalidMemberInitializerUnknownType, e, r);
    }
    flowEnumErrorNumberMemberNotInitialized(e, r) {
      this.raise(Ve.EnumNumberMemberNotInitialized, e, r);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(e, r) {
      this.raise(Ve.EnumStringMemberInconsistentlyInitialized, e, r);
    }
    flowEnumMemberInit() {
      const e = this.state.startLoc, r = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          const a = this.parseNumericLiteral(this.state.value);
          return r() ? {
            type: "number",
            loc: a.loc.start,
            value: a
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 134: {
          const a = this.parseStringLiteral(this.state.value);
          return r() ? {
            type: "string",
            loc: a.loc.start,
            value: a
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 85:
        case 86: {
          const a = this.parseBooleanLiteral(this.match(85));
          return r() ? {
            type: "boolean",
            loc: a.loc.start,
            value: a
          } : {
            type: "invalid",
            loc: e
          };
        }
        default:
          return {
            type: "invalid",
            loc: e
          };
      }
    }
    flowEnumMemberRaw() {
      const e = this.state.startLoc, r = this.parseIdentifier(!0), a = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: e
      };
      return {
        id: r,
        init: a
      };
    }
    flowEnumCheckExplicitTypeMismatch(e, r, a) {
      const {
        explicitType: c
      } = r;
      c !== null && c !== a && this.flowEnumErrorInvalidMemberInitializer(e, r);
    }
    flowEnumMembers({
      enumName: e,
      explicitType: r
    }) {
      const a = /* @__PURE__ */ new Set(), c = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let E = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          E = !0;
          break;
        }
        const M = this.startNode(), {
          id: Y,
          init: se
        } = this.flowEnumMemberRaw(), ue = Y.name;
        if (ue === "")
          continue;
        /^[a-z]/.test(ue) && this.raise(Ve.EnumInvalidMemberName, Y, {
          memberName: ue,
          suggestion: ue[0].toUpperCase() + ue.slice(1),
          enumName: e
        }), a.has(ue) && this.raise(Ve.EnumDuplicateMemberName, Y, {
          memberName: ue,
          enumName: e
        }), a.add(ue);
        const Ee = {
          enumName: e,
          explicitType: r,
          memberName: ue
        };
        switch (M.id = Y, se.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(se.loc, Ee, "boolean"), M.init = se.value, c.booleanMembers.push(this.finishNode(M, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(se.loc, Ee, "number"), M.init = se.value, c.numberMembers.push(this.finishNode(M, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(se.loc, Ee, "string"), M.init = se.value, c.stringMembers.push(this.finishNode(M, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(se.loc, Ee);
          case "none":
            switch (r) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(se.loc, Ee);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(se.loc, Ee);
                break;
              default:
                c.defaultedMembers.push(this.finishNode(M, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: c,
        hasUnknownMembers: E
      };
    }
    flowEnumStringMembers(e, r, {
      enumName: a
    }) {
      if (e.length === 0)
        return r;
      if (r.length === 0)
        return e;
      if (r.length > e.length) {
        for (const c of e)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(c, {
            enumName: a
          });
        return r;
      } else {
        for (const c of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(c, {
            enumName: a
          });
        return e;
      }
    }
    flowEnumParseExplicitType({
      enumName: e
    }) {
      if (!this.eatContextual(102)) return null;
      if (!fe(this.state.type))
        throw this.raise(Ve.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: e
        });
      const {
        value: r
      } = this.state;
      return this.next(), r !== "boolean" && r !== "number" && r !== "string" && r !== "symbol" && this.raise(Ve.EnumInvalidExplicitType, this.state.startLoc, {
        enumName: e,
        invalidEnumType: r
      }), r;
    }
    flowEnumBody(e, r) {
      const a = r.name, c = r.loc.start, E = this.flowEnumParseExplicitType({
        enumName: a
      });
      this.expect(5);
      const {
        members: M,
        hasUnknownMembers: Y
      } = this.flowEnumMembers({
        enumName: a,
        explicitType: E
      });
      switch (e.hasUnknownMembers = Y, E) {
        case "boolean":
          return e.explicitType = !0, e.members = M.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = !0, e.members = M.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = !0, e.members = this.flowEnumStringMembers(M.stringMembers, M.defaultedMembers, {
            enumName: a
          }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = M.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          const se = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = !1;
          const ue = M.booleanMembers.length, Ee = M.numberMembers.length, _e = M.stringMembers.length, ke = M.defaultedMembers.length;
          if (!ue && !Ee && !_e && !ke)
            return se();
          if (!ue && !Ee)
            return e.members = this.flowEnumStringMembers(M.stringMembers, M.defaultedMembers, {
              enumName: a
            }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!Ee && !_e && ue >= ke) {
            for (const Re of M.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(Re.loc.start, {
                enumName: a,
                memberName: Re.id.name
              });
            return e.members = M.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!ue && !_e && Ee >= ke) {
            for (const Re of M.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(Re.loc.start, {
                enumName: a,
                memberName: Re.id.name
              });
            return e.members = M.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(Ve.EnumInconsistentMemberValues, c, {
              enumName: a
            }), se();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      const r = this.parseIdentifier();
      return e.id = r, e.body = this.flowEnumBody(this.startNode(), r), this.finishNode(e, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(e) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e);
    }
    isLookaheadToken_lt() {
      const e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        const r = this.input.charCodeAt(e + 1);
        return r !== 60 && r !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      const {
        type: e
      } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: e
      } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  };
  const Pi = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, Bt = B`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName: b
    }) => `Expected corresponding JSX closing tag for <${b}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected: b,
      HTMLEntity: t
    }) => `Unexpected token \`${b}\`. Did you mean \`${t}\` or \`{'${b}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Dt(b) {
    return b ? b.type === "JSXOpeningFragment" || b.type === "JSXClosingFragment" : !1;
  }
  function Yt(b) {
    if (b.type === "JSXIdentifier")
      return b.name;
    if (b.type === "JSXNamespacedName")
      return b.namespace.name + ":" + b.name.name;
    if (b.type === "JSXMemberExpression")
      return Yt(b.object) + "." + Yt(b.property);
    throw new Error("Node had unexpected type: " + b.type);
  }
  var xi = (b) => class extends b {
    jsxReadToken() {
      let e = "", r = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Bt.UnterminatedJsxContent, this.state.startLoc);
        const a = this.input.charCodeAt(this.state.pos);
        switch (a) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              a === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(a);
              return;
            }
            e += this.input.slice(r, this.state.pos), this.finishToken(142, e);
            return;
          case 38:
            e += this.input.slice(r, this.state.pos), e += this.jsxReadEntity(), r = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Xt(a) ? (e += this.input.slice(r, this.state.pos), e += this.jsxReadNewLine(!0), r = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      const r = this.input.charCodeAt(this.state.pos);
      let a;
      return ++this.state.pos, r === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, a = e ? `
` : `\r
`) : a = String.fromCharCode(r), ++this.state.curLine, this.state.lineStart = this.state.pos, a;
    }
    jsxReadString(e) {
      let r = "", a = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(y.UnterminatedString, this.state.startLoc);
        const c = this.input.charCodeAt(this.state.pos);
        if (c === e) break;
        c === 38 ? (r += this.input.slice(a, this.state.pos), r += this.jsxReadEntity(), a = this.state.pos) : Xt(c) ? (r += this.input.slice(a, this.state.pos), r += this.jsxReadNewLine(!1), a = this.state.pos) : ++this.state.pos;
      }
      r += this.input.slice(a, this.state.pos++), this.finishToken(134, r);
    }
    jsxReadEntity() {
      const e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let r = 10;
        this.codePointAtPos(this.state.pos) === 120 && (r = 16, ++this.state.pos);
        const a = this.readInt(r, void 0, !1, "bail");
        if (a !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(a);
      } else {
        let r = 0, a = !1;
        for (; r++ < 10 && this.state.pos < this.length && !(a = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (a) {
          const c = this.input.slice(e, this.state.pos), E = Pi[c];
          if (++this.state.pos, E)
            return E;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e;
      const r = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (et(e) || e === 45);
      this.finishToken(141, this.input.slice(r, this.state.pos));
    }
    jsxParseIdentifier() {
      const e = this.startNode();
      return this.match(141) ? e.name = this.state.value : at(this.state.type) ? e.name = ve(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e = this.state.startLoc, r = this.jsxParseIdentifier();
      if (!this.eat(14)) return r;
      const a = this.startNodeAt(e);
      return a.namespace = r, a.name = this.jsxParseIdentifier(), this.finishNode(a, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e = this.state.startLoc;
      let r = this.jsxParseNamespacedName();
      if (r.type === "JSXNamespacedName")
        return r;
      for (; this.eat(16); ) {
        const a = this.startNodeAt(e);
        a.object = r, a.property = this.jsxParseIdentifier(), r = this.finishNode(a, "JSXMemberExpression");
      }
      return r;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(q.brace), this.next(), e = this.jsxParseExpressionContainer(e, q.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Bt.AttributeIsEmpty, e), e;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(Bt.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const e = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(q.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, r) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        const a = this.parseExpression();
        e.expression = a;
      }
      return this.setContext(r), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e = this.startNode();
      return this.match(5) ? (this.setContext(q.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(q.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e) {
      const r = this.startNodeAt(e);
      return this.eat(144) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
    }
    jsxParseOpeningElementAfterName(e) {
      const r = [];
      for (; !this.match(56) && !this.match(144); )
        r.push(this.jsxParseAttribute());
      return e.attributes = r, e.selfClosing = this.eat(56), this.expect(144), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e) {
      const r = this.startNodeAt(e);
      return this.eat(144) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(144), this.finishNode(r, "JSXClosingElement"));
    }
    jsxParseElementAt(e) {
      const r = this.startNodeAt(e), a = [], c = this.jsxParseOpeningElementAt(e);
      let E = null;
      if (!c.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (e = this.state.startLoc, this.next(), this.eat(56)) {
                E = this.jsxParseClosingElementAt(e);
                break e;
              }
              a.push(this.jsxParseElementAt(e));
              break;
            case 142:
              a.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              const M = this.startNode();
              this.setContext(q.brace), this.next(), this.match(21) ? a.push(this.jsxParseSpreadChild(M)) : a.push(this.jsxParseExpressionContainer(M, q.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Dt(c) && !Dt(E) && E !== null ? this.raise(Bt.MissingClosingTagFragment, E) : !Dt(c) && Dt(E) ? this.raise(Bt.MissingClosingTagElement, E, {
          openingTagName: Yt(c.name)
        }) : !Dt(c) && !Dt(E) && Yt(E.name) !== Yt(c.name) && this.raise(Bt.MissingClosingTagElement, E, {
          openingTagName: Yt(c.name)
        });
      }
      if (Dt(c) ? (r.openingFragment = c, r.closingFragment = E) : (r.openingElement = c, r.closingElement = E), r.children = a, this.match(47))
        throw this.raise(Bt.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Dt(c) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
    }
    jsxParseElement() {
      const e = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e);
    }
    setContext(e) {
      const {
        context: r
      } = this.state;
      r[r.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      const r = this.curContext();
      if (r === q.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (r === q.j_oTag || r === q.j_cTag) {
        if ($e(e)) {
          this.jsxReadWord();
          return;
        }
        if (e === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((e === 34 || e === 39) && r === q.j_oTag) {
          this.jsxReadString(e);
          return;
        }
      }
      if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(e);
    }
    updateContext(e) {
      const {
        context: r,
        type: a
      } = this.state;
      if (a === 56 && e === 143)
        r.splice(-2, 2, q.j_cTag), this.state.canStartJSXElement = !1;
      else if (a === 143)
        r.push(q.j_oTag);
      else if (a === 144) {
        const c = r[r.length - 1];
        c === q.j_oTag && e === 56 || c === q.j_cTag ? (r.pop(), this.state.canStartJSXElement = r[r.length - 1] === q.j_expr) : (this.setContext(q.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Je(a);
    }
  };
  class vi extends $t {
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class Ai extends Jt {
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new vi(t);
    }
    enter(t) {
      t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      const t = super.exit();
      return t === 256 && this.importsStack.pop(), t;
    }
    hasImport(t, e) {
      const r = this.importsStack.length;
      if (this.importsStack[r - 1].has(t))
        return !0;
      if (!e && r > 1) {
        for (let a = 0; a < r - 1; a++)
          if (this.importsStack[a].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, e, r) {
      if (e & 4096) {
        this.hasImport(t, !0) && this.parser.raise(y.VarRedeclaration, r, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      const a = this.currentScope();
      let c = a.tsNames.get(t) || 0;
      if (e & 1024) {
        this.maybeExportDefined(a, t), a.tsNames.set(t, c | 16);
        return;
      }
      super.declareName(t, e, r), e & 2 && (e & 1 || (this.checkRedeclarationInScope(a, t, e, r), this.maybeExportDefined(a, t)), c = c | 1), e & 256 && (c = c | 2), e & 512 && (c = c | 4), e & 128 && (c = c | 8), c && a.tsNames.set(t, c);
    }
    isRedeclaredInScope(t, e, r) {
      const a = t.tsNames.get(e);
      if ((a & 2) > 0) {
        if (r & 256) {
          const c = !!(r & 512), E = (a & 4) > 0;
          return c !== E;
        }
        return !0;
      }
      return r & 128 && (a & 8) > 0 ? t.names.get(e) & 2 ? !!(r & 1) : !1 : r & 2 && (a & 1) > 0 ? !0 : super.isRedeclaredInScope(t, e, r);
    }
    checkLocalExport(t) {
      const {
        name: e
      } = t;
      if (this.hasImport(e)) return;
      const r = this.scopeStack.length;
      for (let a = r - 1; a >= 0; a--) {
        const E = this.scopeStack[a].tsNames.get(e);
        if ((E & 1) > 0 || (E & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }
  const Mr = (b) => b.type === "ParenthesizedExpression" ? Mr(b.expression) : b;
  class Ci extends mi {
    toAssignable(t, e = !1) {
      var r, a;
      let c;
      switch ((t.type === "ParenthesizedExpression" || (r = t.extra) != null && r.parenthesized) && (c = Mr(t), e ? c.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(y.InvalidParenthesizedAssignment, t) : c.type !== "MemberExpression" && !this.isOptionalMemberExpression(c) && this.raise(y.InvalidParenthesizedAssignment, t) : this.raise(y.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let M = 0, Y = t.properties.length, se = Y - 1; M < Y; M++) {
            var E;
            const ue = t.properties[M], Ee = M === se;
            this.toAssignableObjectExpressionProp(ue, Ee, e), Ee && ue.type === "RestElement" && (E = t.extra) != null && E.trailingCommaLoc && this.raise(y.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const {
            key: M,
            value: Y
          } = t;
          this.isPrivateName(M) && this.classScope.usePrivateName(this.getPrivateNameSV(M), M.loc.start), this.toAssignable(Y, e);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (a = t.extra) == null ? void 0 : a.trailingCommaLoc, e);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(y.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(c, e);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, e, r) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? y.PatternHasAccessor : y.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        const a = t.argument;
        this.checkToRestConversion(a, !1), this.toAssignable(a, r), e || this.raise(y.RestTrailingComma, t);
      } else
        this.toAssignable(t, r);
    }
    toAssignableList(t, e, r) {
      const a = t.length - 1;
      for (let c = 0; c <= a; c++) {
        const E = t[c];
        if (E) {
          if (E.type === "SpreadElement") {
            E.type = "RestElement";
            const M = E.argument;
            this.checkToRestConversion(M, !0), this.toAssignable(M, r);
          } else
            this.toAssignable(E, r);
          E.type === "RestElement" && (c < a ? this.raise(y.RestTrailingComma, E) : e && this.raise(y.RestTrailingComma, e));
        }
      }
    }
    isAssignable(t, e) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          const r = t.properties.length - 1;
          return t.properties.every((a, c) => a.type !== "ObjectMethod" && (c === r || a.type !== "SpreadElement") && this.isAssignable(a));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((r) => r === null || this.isAssignable(r));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !e;
        default:
          return !1;
      }
    }
    toReferencedList(t, e) {
      return t;
    }
    toReferencedListDeep(t, e) {
      this.toReferencedList(t, e);
      for (const r of t)
        (r == null ? void 0 : r.type) === "ArrayExpression" && this.toReferencedListDeep(r.elements);
    }
    parseSpread(t) {
      const e = this.startNode();
      return this.next(), e.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(e, "SpreadElement");
    }
    parseRestBinding() {
      const t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, e, r) {
      const a = r & 1, c = [];
      let E = !0;
      for (; !this.eat(t); )
        if (E ? E = !1 : this.expect(12), a && this.match(12))
          c.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            let M = this.parseRestBinding();
            if ((this.hasPlugin("flow") || r & 2) && (M = this.parseFunctionParamType(M)), c.push(M), !this.checkCommaAfterRest(e)) {
              this.expect(t);
              break;
            }
          } else {
            const M = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(y.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              M.push(this.parseDecorator());
            c.push(this.parseAssignableListItem(r, M));
          }
        }
      return c;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      const {
        type: t,
        startLoc: e
      } = this.state;
      if (t === 21)
        return this.parseBindingRestProperty(this.startNode());
      const r = this.startNode();
      return t === 139 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), r.key = this.parsePrivateName()) : this.parsePropertyName(r), r.method = !1, this.parseObjPropValue(r, e, !1, !1, !0, !1);
    }
    parseAssignableListItem(t, e) {
      const r = this.parseMaybeDefault();
      (this.hasPlugin("flow") || t & 2) && this.parseFunctionParamType(r);
      const a = this.parseMaybeDefault(r.loc.start, r);
      return e.length && (r.decorators = e), a;
    }
    parseFunctionParamType(t) {
      return t;
    }
    parseMaybeDefault(t, e) {
      var r, a;
      if ((r = t) != null || (t = this.state.startLoc), e = (a = e) != null ? a : this.parseBindingAtom(), !this.eat(29)) return e;
      const c = this.startNodeAt(t);
      return c.left = e, c.right = this.parseMaybeAssignAllowIn(), this.finishNode(c, "AssignmentPattern");
    }
    isValidLVal(t, e, r) {
      switch (t) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, e, r = 64, a = !1, c = !1, E = !1) {
      var M;
      const Y = t.type;
      if (this.isObjectMethod(t)) return;
      const se = this.isOptionalMemberExpression(t);
      if (se || Y === "MemberExpression") {
        se && (this.expectPlugin("optionalChainingAssign", t.loc.start), e.type !== "AssignmentExpression" && this.raise(y.InvalidLhsOptionalChaining, t, {
          ancestor: e
        })), r !== 64 && this.raise(y.InvalidPropertyBindingPattern, t);
        return;
      }
      if (Y === "Identifier") {
        this.checkIdentifier(t, r, c);
        const {
          name: Qe
        } = t;
        a && (a.has(Qe) ? this.raise(y.ParamDupe, t) : a.add(Qe));
        return;
      }
      const ue = this.isValidLVal(Y, !(E || (M = t.extra) != null && M.parenthesized) && e.type === "AssignmentExpression", r);
      if (ue === !0) return;
      if (ue === !1) {
        const Qe = r === 64 ? y.InvalidLhs : y.InvalidLhsBinding;
        this.raise(Qe, t, {
          ancestor: e
        });
        return;
      }
      let Ee, _e;
      typeof ue == "string" ? (Ee = ue, _e = Y === "ParenthesizedExpression") : [Ee, _e] = ue;
      const ke = Y === "ArrayPattern" || Y === "ObjectPattern" ? {
        type: Y
      } : e, Re = t[Ee];
      if (Array.isArray(Re))
        for (const Qe of Re)
          Qe && this.checkLVal(Qe, ke, r, a, c, _e);
      else Re && this.checkLVal(Re, ke, r, a, c, _e);
    }
    checkIdentifier(t, e, r = !1) {
      this.state.strict && (r ? Kt(t.name, this.inModule) : Lt(t.name)) && (e === 64 ? this.raise(y.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(y.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), e & 8192 && t.name === "let" && this.raise(y.LetInLexicalBinding, t), e & 64 || this.declareNameFromIdentifier(t, e);
    }
    declareNameFromIdentifier(t, e) {
      this.scope.declareName(t.name, e, t.loc.start);
    }
    checkToRestConversion(t, e) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, e);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (e) break;
        default:
          this.raise(y.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? y.RestTrailingComma : y.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }
  function Ii(b) {
    if (b == null)
      throw new Error(`Unexpected ${b} value.`);
    return b;
  }
  function Br(b) {
    if (!b)
      throw new Error("Assert fail");
  }
  const Fe = B`typescript`({
    AbstractMethodHasImplementation: ({
      methodName: b
    }) => `Method '${b}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName: b
    }) => `Property '${b}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind: b
    }) => `'declare' is not allowed in ${b}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier: b
    }) => "Accessibility modifier already seen.",
    DuplicateModifier: ({
      modifier: b
    }) => `Duplicate modifier: '${b}'.`,
    EmptyHeritageClauseType: ({
      token: b
    }) => `'${b}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers: b
    }) => `'${b[0]}' modifier cannot be used with '${b[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier: b
    }) => `Index signatures cannot have an accessibility modifier ('${b}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier: b
    }) => `'${b}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier: b
    }) => `'${b}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier: b
    }) => `'${b}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers: b
    }) => `'${b[0]}' modifier must precede '${b[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier: b
    }) => `Private elements cannot have an accessibility modifier ('${b}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName: b
    }) => `Single type parameter ${b} should have a trailing comma. Example usage: <${b},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type: b
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${b}.`
  });
  function wi(b) {
    switch (b) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Fr(b) {
    return b === "private" || b === "public" || b === "protected";
  }
  function Oi(b) {
    return b === "in" || b === "out";
  }
  var Ni = (b) => class extends b {
    constructor(...e) {
      super(...e), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Fe.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Fe.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Fe.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Ai;
    }
    tsIsIdentifier() {
      return fe(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(e, r) {
      if (!fe(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      const a = this.state.value;
      if (e.includes(a)) {
        if (r && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return a;
      }
    }
    tsParseModifiers({
      allowedModifiers: e,
      disallowedModifiers: r,
      stopOnStartOfClassStaticBlock: a,
      errorTemplate: c = Fe.InvalidModifierOnTypeMember
    }, E) {
      const M = (se, ue, Ee, _e) => {
        ue === Ee && E[_e] && this.raise(Fe.InvalidModifiersOrder, se, {
          orderedModifiers: [Ee, _e]
        });
      }, Y = (se, ue, Ee, _e) => {
        (E[Ee] && ue === _e || E[_e] && ue === Ee) && this.raise(Fe.IncompatibleModifiers, se, {
          modifiers: [Ee, _e]
        });
      };
      for (; ; ) {
        const {
          startLoc: se
        } = this.state, ue = this.tsParseModifier(e.concat(r ?? []), a);
        if (!ue) break;
        Fr(ue) ? E.accessibility ? this.raise(Fe.DuplicateAccessibilityModifier, se, {
          modifier: ue
        }) : (M(se, ue, ue, "override"), M(se, ue, ue, "static"), M(se, ue, ue, "readonly"), E.accessibility = ue) : Oi(ue) ? (E[ue] && this.raise(Fe.DuplicateModifier, se, {
          modifier: ue
        }), E[ue] = !0, M(se, ue, "in", "out")) : (hasOwnProperty.call(E, ue) ? this.raise(Fe.DuplicateModifier, se, {
          modifier: ue
        }) : (M(se, ue, "static", "readonly"), M(se, ue, "static", "override"), M(se, ue, "override", "readonly"), M(se, ue, "abstract", "override"), Y(se, ue, "declare", "override"), Y(se, ue, "static", "abstract")), E[ue] = !0), r != null && r.includes(ue) && this.raise(c, se, {
          modifier: ue
        });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(e, r) {
      const a = [];
      for (; !this.tsIsListTerminator(e); )
        a.push(r());
      return a;
    }
    tsParseDelimitedList(e, r, a) {
      return Ii(this.tsParseDelimitedListWorker(e, r, !0, a));
    }
    tsParseDelimitedListWorker(e, r, a, c) {
      const E = [];
      let M = -1;
      for (; !this.tsIsListTerminator(e); ) {
        M = -1;
        const Y = r();
        if (Y == null)
          return;
        if (E.push(Y), this.eat(12)) {
          M = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        a && this.expect(12);
        return;
      }
      return c && (c.value = M), E;
    }
    tsParseBracketedList(e, r, a, c, E) {
      c || (a ? this.expect(0) : this.expect(47));
      const M = this.tsParseDelimitedList(e, r, E);
      return a ? this.expect(3) : this.expect(48), M;
    }
    tsParseImportType() {
      const e = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? e.argument = this.parseStringLiteral(this.state.value) : (this.raise(Fe.UnsupportedImportTypeArgument, this.state.startLoc), e.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (e.options = super.parseMaybeAssignAllowIn(), this.eat(12)) : e.options = null, this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName(e) {
      let r;
      if (e & 1 && this.match(78))
        if (e & 2)
          r = this.parseIdentifier(!0);
        else {
          const a = this.startNode();
          this.next(), r = this.finishNode(a, "ThisExpression");
        }
      else
        r = this.parseIdentifier(!!(e & 1));
      for (; this.eat(16); ) {
        const a = this.startNodeAtNode(r);
        a.left = r, a.right = this.parseIdentifier(!!(e & 1)), r = this.finishNode(a, "TSQualifiedName");
      }
      return r;
    }
    tsParseTypeReference() {
      const e = this.startNode();
      return e.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      const r = this.startNodeAtNode(e);
      return r.parameterName = e, r.typeAnnotation = this.tsParseTypeAnnotation(!1), r.asserts = !1, this.finishNode(r, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      const e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseTypeParameter(e) {
      const r = this.startNode();
      return e(r), r.name = this.tsParseTypeParameterName(), r.constraint = this.tsEatThenParseType(81), r.default = this.tsEatThenParseType(29), this.finishNode(r, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      const r = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      const a = {
        value: -1
      };
      return r.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), !1, !0, a), r.params.length === 0 && this.raise(Fe.EmptyTypeParameters, r), a.value !== -1 && this.addExtra(r, "trailingComma", a.value), this.finishNode(r, "TSTypeParameterDeclaration");
    }
    tsFillSignature(e, r) {
      const a = e === 19, c = "parameters", E = "typeAnnotation";
      r.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), r[c] = this.tsParseBindingListForSignature(), a ? r[E] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (r[E] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      const e = super.parseBindingList(11, 41, 2);
      for (const r of e) {
        const {
          type: a
        } = r;
        (a === "AssignmentPattern" || a === "TSParameterProperty") && this.raise(Fe.UnsupportedSignatureParameterKind, r, {
          type: a
        });
      }
      return e;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, r) {
      return this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon(), this.finishNode(r, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), fe(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const r = this.parseIdentifier();
      r.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(r), this.expect(3), e.parameters = [r];
      const a = this.tsTryParseTypeAnnotation();
      return a && (e.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, r) {
      this.eat(17) && (e.optional = !0);
      const a = e;
      if (this.match(10) || this.match(47)) {
        r && this.raise(Fe.ReadonlyForMethodSignature, e);
        const c = a;
        c.kind && this.match(47) && this.raise(Fe.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, c), this.tsParseTypeMemberSemicolon();
        const E = "parameters", M = "typeAnnotation";
        if (c.kind === "get")
          c[E].length > 0 && (this.raise(y.BadGetterArity, this.state.curPosition()), this.isThisParam(c[E][0]) && this.raise(Fe.AccessorCannotDeclareThisParameter, this.state.curPosition()));
        else if (c.kind === "set") {
          if (c[E].length !== 1)
            this.raise(y.BadSetterArity, this.state.curPosition());
          else {
            const Y = c[E][0];
            this.isThisParam(Y) && this.raise(Fe.AccessorCannotDeclareThisParameter, this.state.curPosition()), Y.type === "Identifier" && Y.optional && this.raise(Fe.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), Y.type === "RestElement" && this.raise(Fe.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          c[M] && this.raise(Fe.SetAccessorCannotHaveReturnType, c[M]);
        } else
          c.kind = "method";
        return this.finishNode(c, "TSMethodSignature");
      } else {
        const c = a;
        r && (c.readonly = !0);
        const E = this.tsTryParseTypeAnnotation();
        return E && (c.typeAnnotation = E), this.tsParseTypeMemberSemicolon(), this.finishNode(c, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        const a = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(a, "new"), this.tsParsePropertyOrMethodSignature(e, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, e);
      const r = this.tsTryParseIndexSignature(e);
      return r || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      const e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      const e = this.startNode();
      this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0);
      {
        const r = this.startNode();
        r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), e.typeParameter = this.finishNode(r, "TSTypeParameter");
      }
      return e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      const e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let r = !1;
      return e.elementTypes.forEach((a) => {
        const {
          type: c
        } = a;
        r && c !== "TSRestType" && c !== "TSOptionalType" && !(c === "TSNamedTupleMember" && a.optional) && this.raise(Fe.OptionalTypeBeforeRequired, a), r || (r = c === "TSNamedTupleMember" && a.optional || c === "TSOptionalType");
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      const e = this.state.startLoc, r = this.eat(21), {
        startLoc: a
      } = this.state;
      let c, E, M, Y;
      const ue = de(this.state.type) ? this.lookaheadCharCode() : null;
      if (ue === 58)
        c = !0, M = !1, E = this.parseIdentifier(!0), this.expect(14), Y = this.tsParseType();
      else if (ue === 63) {
        M = !0;
        const Ee = this.state.value, _e = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (c = !0, E = this.createIdentifier(this.startNodeAt(a), Ee), this.expect(17), this.expect(14), Y = this.tsParseType()) : (c = !1, Y = _e, this.expect(17));
      } else
        Y = this.tsParseType(), M = this.eat(17), c = this.eat(14);
      if (c) {
        let Ee;
        E ? (Ee = this.startNodeAt(a), Ee.optional = M, Ee.label = E, Ee.elementType = Y, this.eat(17) && (Ee.optional = !0, this.raise(Fe.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (Ee = this.startNodeAt(a), Ee.optional = M, this.raise(Fe.InvalidTupleMemberLabel, Y), Ee.label = Y, Ee.elementType = this.tsParseType()), Y = this.finishNode(Ee, "TSNamedTupleMember");
      } else if (M) {
        const Ee = this.startNodeAt(a);
        Ee.typeAnnotation = Y, Y = this.finishNode(Ee, "TSOptionalType");
      }
      if (r) {
        const Ee = this.startNodeAt(e);
        Ee.typeAnnotation = Y, Y = this.finishNode(Ee, "TSRestType");
      }
      return Y;
    }
    tsParseParenthesizedType() {
      const e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, r) {
      const a = this.startNode();
      return e === "TSConstructorType" && (a.abstract = !!r, r && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, a)), this.finishNode(a, e);
    }
    tsParseLiteralTypeNode() {
      const e = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          e.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        const e = this.startNode();
        return e.literal = super.parseTemplate(!1), this.finishNode(e, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const e = this.startNode(), r = this.lookahead();
            return r.type !== 135 && r.type !== 136 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: e
          } = this.state;
          if (fe(e) || e === 88 || e === 84) {
            const r = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : wi(this.state.value);
            if (r !== void 0 && this.lookaheadCharCode() !== 46) {
              const a = this.startNode();
              return this.next(), this.finishNode(a, r);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      const {
        startLoc: e
      } = this.state;
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const a = this.startNodeAt(e);
          a.elementType = r, this.expect(3), r = this.finishNode(a, "TSArrayType");
        } else {
          const a = this.startNodeAt(e);
          a.objectType = r, a.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(a, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      const e = this.startNode(), r = this.state.value;
      return this.next(), e.operator = r, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), r === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Fe.UnexpectedReadonly, e);
      }
    }
    tsParseInferType() {
      const e = this.startNode();
      this.expectContextual(115);
      const r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(r, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Tt(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, r, a) {
      const c = this.startNode(), E = this.eat(a), M = [];
      do
        M.push(r());
      while (this.eat(a));
      return M.length === 1 && !E ? M[0] : (c.types = M, this.finishNode(c, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (fe(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        const {
          errors: e
        } = this.state, r = e.length;
        try {
          return this.parseObjectLike(8, !0), e.length === r;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: e
        } = this.state, r = e.length;
        try {
          return super.parseBindingList(3, 93, 1), e.length === r;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        const r = this.startNode();
        this.expect(e);
        const a = this.startNode(), c = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (c && this.match(78)) {
          let Y = this.tsParseThisTypeOrThisTypePredicate();
          return Y.type === "TSThisType" ? (a.parameterName = Y, a.asserts = !0, a.typeAnnotation = null, Y = this.finishNode(a, "TSTypePredicate")) : (this.resetStartLocationFromNode(Y, a), Y.asserts = !0), r.typeAnnotation = Y, this.finishNode(r, "TSTypeAnnotation");
        }
        const E = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!E)
          return c ? (a.parameterName = this.parseIdentifier(), a.asserts = c, a.typeAnnotation = null, r.typeAnnotation = this.finishNode(a, "TSTypePredicate"), this.finishNode(r, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, r);
        const M = this.tsParseTypeAnnotation(!1);
        return a.parameterName = E, a.typeAnnotation = M, a.asserts = c, r.typeAnnotation = this.finishNode(a, "TSTypePredicate"), this.finishNode(r, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      const e = this.state.containsEsc;
      return this.next(), !fe(this.state.type) && !this.match(78) ? !1 : (e && this.raise(y.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(e = !0, r = this.startNode()) {
      return this.tsInType(() => {
        e && this.expect(14), r.typeAnnotation = this.tsParseType();
      }), this.finishNode(r, "TSTypeAnnotation");
    }
    tsParseType() {
      Br(this.state.inType);
      const e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      const r = this.startNodeAtNode(e);
      return r.checkType = e, r.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), r.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), r.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(r, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Fe.ReservedTypeAssertion, this.state.startLoc);
      const e = this.startNode();
      return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      const r = this.state.startLoc, a = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const c = this.startNode();
        return c.expression = this.tsParseEntityName(3), this.match(47) && (c.typeParameters = this.tsParseTypeArguments()), this.finishNode(c, "TSExpressionWithTypeArguments");
      });
      return a.length || this.raise(Fe.EmptyHeritageClauseType, r, {
        token: e
      }), a;
    }
    tsParseInterfaceDeclaration(e, r = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), r.declare && (e.declare = !0), fe(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 130)) : (e.id = null, this.raise(Fe.MissingInterfaceName, this.state.startLoc)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      const a = this.startNode();
      return a.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(a, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 2), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          const r = this.startNode();
          return this.next(), this.finishNode(r, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(e) {
      if (this.curContext() !== q.brace) {
        const r = this.state.context;
        this.state.context = [r[0]];
        try {
          return e();
        } finally {
          this.state.context = r;
        }
      } else
        return e();
    }
    tsInType(e) {
      const r = this.state.inType;
      this.state.inType = !0;
      try {
        return e();
      } finally {
        this.state.inType = r;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      const r = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = r;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      const r = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = r;
      }
    }
    tsEatThenParseType(e) {
      if (this.match(e))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(e) {
      return this.tsInType(() => (this.expect(e), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e = this.startNode();
      return e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e, r = {}) {
      return r.const && (e.const = !0), r.declare && (e.declare = !0), this.expectContextual(126), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      const e = this.startNode();
      return this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumBody");
    }
    tsParseModuleBlock() {
      const e = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e, r = !1) {
      if (e.id = this.parseIdentifier(), r || this.checkIdentifier(e.id, 1024), this.eat(16)) {
        const a = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(a, !0), e.body = a;
      } else
        this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(112) ? (e.kind = "global", e.global = !0, e.id = this.parseIdentifier()) : this.match(134) ? (e.kind = "module", e.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, r, a) {
      e.isExport = a || !1, e.id = r || this.parseIdentifier(), this.checkIdentifier(e.id, 4096), this.expect(29);
      const c = this.tsParseModuleReference();
      return e.importKind === "type" && c.type !== "TSExternalModuleReference" && this.raise(Fe.ImportAliasHasImportType, c), e.moduleReference = c, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      const e = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      const r = this.state.clone(), a = e();
      return this.state = r, a;
    }
    tsTryParseAndCatch(e) {
      const r = this.tryParse((a) => e() || a());
      if (!(r.aborted || !r.node))
        return r.error && (this.state = r.failState), r.node;
    }
    tsTryParse(e) {
      const r = this.state.clone(), a = e();
      if (a !== void 0 && a !== !1)
        return a;
      this.state = r;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let r = this.state.type, a;
      return this.isContextual(100) && (r = 74, a = "let"), this.tsInAmbientContext(() => {
        switch (r) {
          case 68:
            return e.declare = !0, super.parseFunctionStatement(e, !1, !1);
          case 80:
            return e.declare = !0, this.parseClass(e, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(e, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(e);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = !0, this.parseVarStatement(e, a || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(e, {
              const: !0,
              declare: !0
            }));
          case 129: {
            const c = this.tsParseInterfaceDeclaration(e, {
              declare: !0
            });
            if (c) return c;
          }
          default:
            if (fe(r))
              return this.tsParseDeclaration(e, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(e, r, a) {
      switch (r.name) {
        case "declare": {
          const c = this.tsTryParseDeclare(e);
          return c && (c.declare = !0), c;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const c = e;
            return c.kind = "global", e.global = !0, c.id = r, c.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(c, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, r.name, !1, a);
      }
    }
    tsParseDeclaration(e, r, a, c) {
      switch (r) {
        case "abstract":
          if (this.tsCheckLineTerminator(a) && (this.match(80) || fe(this.state.type)))
            return this.tsParseAbstractDeclaration(e, c);
          break;
        case "module":
          if (this.tsCheckLineTerminator(a)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (fe(this.state.type))
              return e.kind = "module", this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(a) && fe(this.state.type))
            return e.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(a) && fe(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e) {
      if (!this.match(47)) return;
      const r = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const a = this.tsTryParseAndCatch(() => {
        const c = this.startNodeAt(e);
        return c.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(c), c.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), c;
      });
      if (this.state.maybeInArrowParameters = r, !!a)
        return super.parseArrowExpression(a, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e = this.startNode();
      return e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 ? this.raise(Fe.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === q.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return be(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, r) {
      const a = this.state.startLoc, c = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, c);
      const E = c.accessibility, M = c.override, Y = c.readonly;
      !(e & 4) && (E || Y || M) && this.raise(Fe.UnexpectedParameterModifier, a);
      const se = this.parseMaybeDefault();
      e & 2 && this.parseFunctionParamType(se);
      const ue = this.parseMaybeDefault(se.loc.start, se);
      if (E || Y || M) {
        const Ee = this.startNodeAt(a);
        return r.length && (Ee.decorators = r), E && (Ee.accessibility = E), Y && (Ee.readonly = Y), M && (Ee.override = M), ue.type !== "Identifier" && ue.type !== "AssignmentPattern" && this.raise(Fe.UnsupportedParameterPropertyKind, Ee), Ee.parameter = ue, this.finishNode(Ee, "TSParameterProperty");
      }
      return r.length && (se.decorators = r), ue;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    tsDisallowOptionalPattern(e) {
      for (const r of e.params)
        r.type !== "Identifier" && r.optional && !this.state.isAmbientContext && this.raise(Fe.PatternIsOptional, r);
    }
    setArrowFunctionParameters(e, r, a) {
      super.setArrowFunctionParameters(e, r, a), this.tsDisallowOptionalPattern(e);
    }
    parseFunctionBodyAndFinish(e, r, a = !1) {
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const c = r === "FunctionDeclaration" ? "TSDeclareFunction" : r === "ClassMethod" || r === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return c && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, c) : c === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(Fe.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, c, a) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, r, a));
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((r) => {
        (r == null ? void 0 : r.type) === "TSTypeCastExpression" && this.raise(Fe.UnexpectedTypeAnnotation, r.typeAnnotation);
      });
    }
    toReferencedList(e, r) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike(e, r, a, c) {
      const E = super.parseArrayLike(e, r, a, c);
      return E.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(E.elements), E;
    }
    parseSubscript(e, r, a, c) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const M = this.startNodeAt(r);
        return M.expression = e, this.finishNode(M, "TSNonNullExpression");
      }
      let E = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (a)
          return c.stop = !0, e;
        c.optionalChainMember = E = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let M;
        const Y = this.tsTryParseAndCatch(() => {
          if (!a && this.atPossibleAsyncArrow(e)) {
            const _e = this.tsTryParseGenericAsyncArrowFunction(r);
            if (_e)
              return _e;
          }
          const se = this.tsParseTypeArgumentsInExpression();
          if (!se) return;
          if (E && !this.match(10)) {
            M = this.state.curPosition();
            return;
          }
          if (V(this.state.type)) {
            const _e = super.parseTaggedTemplateExpression(e, r, c);
            return _e.typeParameters = se, _e;
          }
          if (!a && this.eat(10)) {
            const _e = this.startNodeAt(r);
            return _e.callee = e, _e.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(_e.arguments), _e.typeParameters = se, c.optionalChainMember && (_e.optional = E), this.finishCallExpression(_e, c.optionalChainMember);
          }
          const ue = this.state.type;
          if (ue === 48 || ue === 52 || ue !== 10 && He(ue) && !this.hasPrecedingLineBreak())
            return;
          const Ee = this.startNodeAt(r);
          return Ee.expression = e, Ee.typeParameters = se, this.finishNode(Ee, "TSInstantiationExpression");
        });
        if (M && this.unexpected(M, 10), Y)
          return Y.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(Fe.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), Y;
      }
      return super.parseSubscript(e, r, a, c);
    }
    parseNewCallee(e) {
      var r;
      super.parseNewCallee(e);
      const {
        callee: a
      } = e;
      a.type === "TSInstantiationExpression" && !((r = a.extra) != null && r.parenthesized) && (e.typeParameters = a.typeParameters, e.callee = a.expression);
    }
    parseExprOp(e, r, a) {
      let c;
      if (j(58) > a && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (c = this.isContextual(120)))) {
        const E = this.startNodeAt(r);
        return E.expression = e, E.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (c && this.raise(y.UnexpectedKeyword, this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(E, c ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(E, r, a);
      }
      return super.parseExprOp(e, r, a);
    }
    checkReservedWord(e, r, a, c) {
      this.state.isAmbientContext || super.checkReservedWord(e, r, a, c);
    }
    checkImportReflection(e) {
      super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(Fe.ImportReflectionHasImportType, e.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(e) {
      if (super.isPotentialImportPhase(e)) return !0;
      if (this.isContextual(130)) {
        const r = this.lookaheadCharCode();
        return e ? r === 123 || r === 42 : r !== 61;
      }
      return !e && this.isContextual(87);
    }
    applyImportPhase(e, r, a, c) {
      super.applyImportPhase(e, r, a, c), r ? e.exportKind = a === "type" ? "type" : "value" : e.importKind = a === "type" || a === "typeof" ? a : "value";
    }
    parseImport(e) {
      if (this.match(134))
        return e.importKind = "value", super.parseImport(e);
      let r;
      if (fe(this.state.type) && this.lookaheadCharCode() === 61)
        return e.importKind = "value", this.tsParseImportEqualsDeclaration(e);
      if (this.isContextual(130)) {
        const a = this.parseMaybeImportPhase(e, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(e, a);
        r = super.parseImportSpecifiersAndAfter(e, a);
      } else
        r = super.parseImport(e);
      return r.importKind === "type" && r.specifiers.length > 1 && r.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Fe.TypeImportCannotSpecifyDefaultAndNamed, r), r;
    }
    parseExport(e, r) {
      if (this.match(83)) {
        const a = e;
        this.next();
        let c = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? c = this.parseMaybeImportPhase(a, !1) : a.importKind = "value", this.tsParseImportEqualsDeclaration(a, c, !0);
      } else if (this.eat(29)) {
        const a = e;
        return a.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(a, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const a = e;
        return this.expectContextual(128), a.id = this.parseIdentifier(), this.semicolon(), this.finishNode(a, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(e, r);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e = this.startNode();
        return this.next(), e.abstract = !0, this.parseClass(e, !0, !0);
      }
      if (this.match(129)) {
        const e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e) return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, r, a = !1) {
      const {
        isAmbientContext: c
      } = this.state, E = super.parseVarStatement(e, r, a || c);
      if (!c) return E;
      for (const {
        id: M,
        init: Y
      } of E.declarations)
        Y && (r !== "const" || M.typeAnnotation ? this.raise(Fe.InitializerNotAllowedInAmbientContext, Y) : Di(Y, this.hasPlugin("estree")) || this.raise(Fe.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, Y));
      return E;
    }
    parseStatementContent(e, r) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const a = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(a, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const a = this.tsParseInterfaceDeclaration(this.startNode());
        if (a) return a;
      }
      return super.parseStatementContent(e, r);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, r) {
      return r.some((a) => Fr(a) ? e.accessibility === a : !!e[a]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, r, a) {
      const c = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: c,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Fe.InvalidModifierOnTypeParameterPositions
      }, r);
      const E = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(r, c) && this.raise(Fe.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, r)) : this.parseClassMemberWithIsStatic(e, r, a, !!r.static);
      };
      r.declare ? this.tsInAmbientContext(E) : E();
    }
    parseClassMemberWithIsStatic(e, r, a, c) {
      const E = this.tsTryParseIndexSignature(r);
      if (E) {
        e.body.push(E), r.abstract && this.raise(Fe.IndexSignatureHasAbstract, r), r.accessibility && this.raise(Fe.IndexSignatureHasAccessibility, r, {
          modifier: r.accessibility
        }), r.declare && this.raise(Fe.IndexSignatureHasDeclare, r), r.override && this.raise(Fe.IndexSignatureHasOverride, r);
        return;
      }
      !this.state.inAbstractClass && r.abstract && this.raise(Fe.NonAbstractClassHasAbstractMethod, r), r.override && (a.hadSuperClass || this.raise(Fe.OverrideNotInSubClass, r)), super.parseClassMemberWithIsStatic(e, r, a, c);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(Fe.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(Fe.ClassMethodHasDeclare, e);
    }
    parseExpressionStatement(e, r, a) {
      return (r.type === "Identifier" ? this.tsParseExpressionStatement(e, r, a) : void 0) || super.parseExpressionStatement(e, r, a);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(e, r, a) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, r, a);
      const c = this.tryParse(() => super.parseConditional(e, r));
      return c.node ? (c.error && (this.state = c.failState), c.node) : (c.error && super.setOptionalParametersError(a, c.error), e);
    }
    parseParenItem(e, r) {
      const a = super.parseParenItem(e, r);
      if (this.eat(17) && (a.optional = !0, this.resetEndLocation(e)), this.match(14)) {
        const c = this.startNodeAt(r);
        return c.expression = e, c.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(c, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      const r = this.state.startLoc, a = this.eatContextual(125);
      if (a && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Fe.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const E = fe(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return E ? ((E.type === "TSInterfaceDeclaration" || E.type === "TSTypeAliasDeclaration" || a) && (e.exportKind = "type"), a && E.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(E, r), E.declare = !0), E) : null;
    }
    parseClassId(e, r, a, c) {
      if ((!r || a) && this.isContextual(113))
        return;
      super.parseClassId(e, r, a, e.declare ? 1024 : 8331);
      const E = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      E && (e.typeParameters = E);
    }
    parseClassPropertyAnnotation(e) {
      e.optional || (this.eat(35) ? e.definite = !0 : this.eat(17) && (e.optional = !0));
      const r = this.tsTryParseTypeAnnotation();
      r && (e.typeAnnotation = r);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(Fe.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29)) {
        const {
          key: r
        } = e;
        this.raise(Fe.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: r.type === "Identifier" && !e.computed ? r.name : `[${this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end))}]`
        });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(Fe.PrivateElementHasAbstract, e), e.accessibility && this.raise(Fe.PrivateElementHasAccessibility, e, {
        modifier: e.accessibility
      }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    parseClassAccessorProperty(e) {
      return this.parseClassPropertyAnnotation(e), e.optional && this.raise(Fe.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
    }
    pushClassMethod(e, r, a, c, E, M) {
      const Y = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      Y && E && this.raise(Fe.ConstructorHasTypeParameters, Y);
      const {
        declare: se = !1,
        kind: ue
      } = r;
      se && (ue === "get" || ue === "set") && this.raise(Fe.DeclareAccessor, r, {
        kind: ue
      }), Y && (r.typeParameters = Y), super.pushClassMethod(e, r, a, c, E, M);
    }
    pushClassPrivateMethod(e, r, a, c) {
      const E = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      E && (r.typeParameters = E), super.pushClassPrivateMethod(e, r, a, c);
    }
    declareClassPrivateMethodInScope(e, r) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !hasOwnProperty.call(e.value, "body") || super.declareClassPrivateMethodInScope(e, r));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e, r, a, c, E, M, Y) {
      const se = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return se && (e.typeParameters = se), super.parseObjPropValue(e, r, a, c, E, M, Y);
    }
    parseFunctionParams(e, r) {
      const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      a && (e.typeParameters = a), super.parseFunctionParams(e, r);
    }
    parseVarId(e, r) {
      super.parseVarId(e, r), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
      const a = this.tsTryParseTypeAnnotation();
      a && (e.id.typeAnnotation = a, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, r) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, r);
    }
    parseMaybeAssign(e, r) {
      var a, c, E, M, Y;
      let se, ue, Ee;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (se = this.state.clone(), ue = this.tryParse(() => super.parseMaybeAssign(e, r), se), !ue.error) return ue.node;
        const {
          context: Re
        } = this.state, Qe = Re[Re.length - 1];
        (Qe === q.j_oTag || Qe === q.j_expr) && Re.pop();
      }
      if (!((a = ue) != null && a.error) && !this.match(47))
        return super.parseMaybeAssign(e, r);
      (!se || se === this.state) && (se = this.state.clone());
      let _e;
      const ke = this.tryParse((Re) => {
        var Qe, mt;
        _e = this.tsParseTypeParameters(this.tsParseConstModifier);
        const tt = super.parseMaybeAssign(e, r);
        return (tt.type !== "ArrowFunctionExpression" || (Qe = tt.extra) != null && Qe.parenthesized) && Re(), ((mt = _e) == null ? void 0 : mt.params.length) !== 0 && this.resetStartLocationFromNode(tt, _e), tt.typeParameters = _e, tt;
      }, se);
      if (!ke.error && !ke.aborted)
        return _e && this.reportReservedArrowTypeParam(_e), ke.node;
      if (!ue && (Br(!this.hasPlugin("jsx")), Ee = this.tryParse(() => super.parseMaybeAssign(e, r), se), !Ee.error))
        return Ee.node;
      if ((c = ue) != null && c.node)
        return this.state = ue.failState, ue.node;
      if (ke.node)
        return this.state = ke.failState, _e && this.reportReservedArrowTypeParam(_e), ke.node;
      if ((E = Ee) != null && E.node)
        return this.state = Ee.failState, Ee.node;
      throw ((M = ue) == null ? void 0 : M.error) || ke.error || ((Y = Ee) == null ? void 0 : Y.error);
    }
    reportReservedArrowTypeParam(e) {
      var r;
      e.params.length === 1 && !e.params[0].constraint && !((r = e.extra) != null && r.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Fe.ReservedArrowTypeParam, e);
    }
    parseMaybeUnary(e, r) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, r);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const r = this.tryParse((a) => {
          const c = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && a(), c;
        });
        if (r.aborted) return;
        r.thrown || (r.error && (this.state = r.failState), e.returnType = r.node);
      }
      return super.parseArrow(e);
    }
    parseFunctionParamType(e) {
      this.eat(17) && (e.optional = !0);
      const r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r), this.resetEndLocation(e), e;
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, r);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(e, r);
      }
    }
    toAssignable(e, r = !1) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, r);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          r ? this.expressionScope.recordArrowParameterBindingError(Fe.UnexpectedTypeCastInParameter, e) : this.raise(Fe.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, r);
          break;
        case "AssignmentExpression":
          !r && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, r);
      }
    }
    toAssignableParenthesizedExpression(e, r) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, r);
          break;
        default:
          super.toAssignable(e, r);
      }
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, !1);
          break;
        default:
          super.checkToRestConversion(e, r);
      }
    }
    isValidLVal(e, r, a) {
      switch (e) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
        case "TSInstantiationExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (a !== 64 || !r) && ["expression", !0];
        default:
          return super.isValidLVal(e, r, a);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(e, r) {
      if (this.match(47) || this.match(51)) {
        const a = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const c = super.parseMaybeDecoratorArguments(e, r);
          return c.typeParameters = a, c;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e, r);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(e, r) {
      const a = super.parseMaybeDefault(e, r);
      return a.type === "AssignmentPattern" && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(Fe.TypeAnnotationAfterAssign, a.typeAnnotation), a;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (e === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      const {
        type: e
      } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: e
      } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e, r, a) {
      for (let c = 0; c < e.length; c++) {
        const E = e[c];
        (E == null ? void 0 : E.type) === "TSTypeCastExpression" && (e[c] = this.typeCastToParameter(E));
      }
      super.toAssignableList(e, r, a);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((r) => this.isAssignable(r, !0)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        const r = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        r && (e.typeParameters = r);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      const r = super.getGetterSetterExpectedParamCount(e), c = this.getObjectOrClassMethodParams(e)[0];
      return c && this.isThisParam(c) ? r + 1 : r;
    }
    parseCatchClauseParam() {
      const e = super.parseCatchClauseParam(), r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      const {
        isAmbientContext: r,
        strict: a
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = r, this.state.strict = a;
      }
    }
    parseClass(e, r, a) {
      const c = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        return super.parseClass(e, r, a);
      } finally {
        this.state.inAbstractClass = c;
      }
    }
    tsParseAbstractDeclaration(e, r) {
      if (this.match(80))
        return e.abstract = !0, this.maybeTakeDecorators(r, this.parseClass(e, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = !0, this.raise(Fe.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(e, r, a, c, E, M, Y) {
      const se = super.parseMethod(e, r, a, c, E, M, Y);
      if (se.abstract && (this.hasPlugin("estree") ? se.value : se).body) {
        const {
          key: _e
        } = se;
        this.raise(Fe.AbstractMethodHasImplementation, se, {
          methodName: _e.type === "Identifier" && !se.computed ? _e.name : `[${this.input.slice(this.offsetToSourcePos(_e.start), this.offsetToSourcePos(_e.end))}]`
        });
      }
      return se;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(e, r, a, c) {
      return !r && c ? (this.parseTypeOnlyImportExportSpecifier(e, !1, a), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, r, a, c));
    }
    parseImportSpecifier(e, r, a, c, E) {
      return !r && c ? (this.parseTypeOnlyImportExportSpecifier(e, !0, a), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, r, a, c, a ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(e, r, a) {
      const c = r ? "imported" : "local", E = r ? "local" : "exported";
      let M = e[c], Y, se = !1, ue = !0;
      const Ee = M.loc.start;
      if (this.isContextual(93)) {
        const ke = this.parseIdentifier();
        if (this.isContextual(93)) {
          const Re = this.parseIdentifier();
          de(this.state.type) ? (se = !0, M = ke, Y = r ? this.parseIdentifier() : this.parseModuleExportName(), ue = !1) : (Y = Re, ue = !1);
        } else de(this.state.type) ? (ue = !1, Y = r ? this.parseIdentifier() : this.parseModuleExportName()) : (se = !0, M = ke);
      } else de(this.state.type) && (se = !0, r ? (M = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(M.name, M.loc.start, !0, !0)) : M = this.parseModuleExportName());
      se && a && this.raise(r ? Fe.TypeModifierIsUsedInTypeImports : Fe.TypeModifierIsUsedInTypeExports, Ee), e[c] = M, e[E] = Y;
      const _e = r ? "importKind" : "exportKind";
      e[_e] = se ? "type" : "value", ue && this.eatContextual(93) && (e[E] = r ? this.parseIdentifier() : this.parseModuleExportName()), e[E] || (e[E] = wt(e[c])), r && this.checkIdentifier(e[E], se ? 4098 : 4096);
    }
  };
  function _i(b) {
    if (b.type !== "MemberExpression") return !1;
    const {
      computed: t,
      property: e
    } = b;
    return t && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? !1 : jr(b.object);
  }
  function Di(b, t) {
    var e;
    const {
      type: r
    } = b;
    if ((e = b.extra) != null && e.parenthesized)
      return !1;
    if (t) {
      if (r === "Literal") {
        const {
          value: a
        } = b;
        if (typeof a == "string" || typeof a == "boolean")
          return !0;
      }
    } else if (r === "StringLiteral" || r === "BooleanLiteral")
      return !0;
    return !!(Rr(b, t) || ki(b, t) || r === "TemplateLiteral" && b.expressions.length === 0 || _i(b));
  }
  function Rr(b, t) {
    return t ? b.type === "Literal" && (typeof b.value == "number" || "bigint" in b) : b.type === "NumericLiteral" || b.type === "BigIntLiteral";
  }
  function ki(b, t) {
    if (b.type === "UnaryExpression") {
      const {
        operator: e,
        argument: r
      } = b;
      if (e === "-" && Rr(r, t))
        return !0;
    }
    return !1;
  }
  function jr(b) {
    return b.type === "Identifier" ? !0 : b.type !== "MemberExpression" || b.computed ? !1 : jr(b.object);
  }
  const qr = B`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var Li = (b) => class extends b {
    parsePlaceholder(e) {
      if (this.match(133)) {
        const r = this.startNode();
        return this.next(), this.assertNoSpace(), r.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(r, e);
      }
    }
    finishPlaceholder(e, r) {
      let a = e;
      return (!a.expectedNode || !a.type) && (a = this.finishNode(a, "Placeholder")), a.expectedNode = r, a;
    }
    getTokenFromCode(e) {
      e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(e);
    }
    parseExprAtom(e) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
    }
    parseIdentifier(e) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
    }
    checkReservedWord(e, r, a, c) {
      e !== void 0 && super.checkReservedWord(e, r, a, c);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(e, r, a) {
      return e === "Placeholder" || super.isValidLVal(e, r, a);
    }
    toAssignable(e, r) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, r);
    }
    chStartsBindingIdentifier(e, r) {
      return !!(super.chStartsBindingIdentifier(e, r) || this.lookahead().type === 133);
    }
    verifyBreakContinue(e, r) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, r);
    }
    parseExpressionStatement(e, r) {
      var a;
      if (r.type !== "Placeholder" || (a = r.extra) != null && a.parenthesized)
        return super.parseExpressionStatement(e, r);
      if (this.match(14)) {
        const E = e;
        return E.label = this.finishPlaceholder(r, "Identifier"), this.next(), E.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(E, "LabeledStatement");
      }
      this.semicolon();
      const c = e;
      return c.name = r.name, this.finishPlaceholder(c, "Statement");
    }
    parseBlock(e, r, a) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, r, a);
    }
    parseFunctionId(e) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
    }
    parseClass(e, r, a) {
      const c = r ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const E = this.state.strict, M = this.parsePlaceholder("Identifier");
      if (M)
        if (this.match(81) || this.match(133) || this.match(5))
          e.id = M;
        else {
          if (a || !r)
            return e.id = null, e.body = this.finishPlaceholder(M, "ClassBody"), this.finishNode(e, c);
          throw this.raise(qr.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(e, r, a);
      return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, E), this.finishNode(e, c);
    }
    parseExport(e, r) {
      const a = this.parsePlaceholder("Identifier");
      if (!a) return super.parseExport(e, r);
      const c = e;
      if (!this.isContextual(98) && !this.match(12))
        return c.specifiers = [], c.source = null, c.declaration = this.finishPlaceholder(a, "Declaration"), this.finishNode(c, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const E = this.startNode();
      return E.exported = a, c.specifiers = [this.finishNode(E, "ExportDefaultSpecifier")], super.parseExport(c, r);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith(ve(133), this.nextTokenStartSince(e + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e, r) {
      var a;
      return (a = e.specifiers) != null && a.length ? !0 : super.maybeParseExportDefaultSpecifier(e, r);
    }
    checkExport(e) {
      const {
        specifiers: r
      } = e;
      r != null && r.length && (e.specifiers = r.filter((a) => a.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = r;
    }
    parseImport(e) {
      const r = this.parsePlaceholder("Identifier");
      if (!r) return super.parseImport(e);
      if (e.specifiers = [], !this.isContextual(98) && !this.match(12))
        return e.source = this.finishPlaceholder(r, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      const a = this.startNodeAtNode(r);
      return a.local = r, e.specifiers.push(this.finishNode(a, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(qr.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, Mi = (b) => class extends b {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e = this.state.startLoc, r = this.startNode();
        if (this.next(), fe(this.state.type)) {
          const a = this.parseIdentifierName(), c = this.createIdentifier(r, a);
          if (c.type = "V8IntrinsicIdentifier", this.match(10))
            return c;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom(e) {
      return this.parseV8Intrinsic() || super.parseExprAtom(e);
    }
  };
  const Ur = ["minimal", "fsharp", "hack", "smart"], Vr = ["^^", "@@", "^", "%", "#"];
  function Bi(b) {
    if (b.has("decorators")) {
      if (b.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const e = b.get("decorators").decoratorsBeforeExport;
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      const r = b.get("decorators").allowCallParenthesized;
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (b.has("flow") && b.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (b.has("placeholders") && b.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (b.has("pipelineOperator")) {
      var t;
      const e = b.get("pipelineOperator").proposal;
      if (!Ur.includes(e)) {
        const a = Ur.map((c) => `"${c}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${a}.`);
      }
      const r = ((t = b.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash";
      if (e === "hack") {
        if (b.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (b.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const a = b.get("pipelineOperator").topicToken;
        if (!Vr.includes(a)) {
          const c = Vr.map((E) => `"${E}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${c}.`);
        }
        if (a === "#" && r)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", b.get("recordAndTuple")])}\`.`);
      } else if (e === "smart" && r)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", b.get("recordAndTuple")])}\`.`);
    }
    if (b.has("moduleAttributes")) {
      if (b.has("deprecatedImportAssert") || b.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (b.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (b.has("importAssertions") && b.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!b.has("deprecatedImportAssert") && b.has("importAttributes") && b.get("importAttributes").deprecatedAssertSyntax && b.set("deprecatedImportAssert", {}), b.has("recordAndTuple")) {
      const e = b.get("recordAndTuple").syntaxType;
      if (e != null) {
        const r = ["hash", "bar"];
        if (!r.includes(e))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((a) => `'${a}'`).join(", "));
      }
    }
    if (b.has("asyncDoExpressions") && !b.has("doExpressions")) {
      const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (b.has("optionalChainingAssign") && b.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  const Kr = {
    estree: ee,
    jsx: xi,
    flow: Ei,
    typescript: Ni,
    v8intrinsic: Mi,
    placeholders: Li
  }, Fi = Object.keys(Kr);
  class Ri extends Ci {
    checkProto(t, e, r, a) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      const c = t.key;
      if ((c.type === "Identifier" ? c.name : c.value) === "__proto__") {
        if (e) {
          this.raise(y.RecordNoProto, c);
          return;
        }
        r.used && (a ? a.doubleProtoLoc === null && (a.doubleProtoLoc = c.loc.start) : this.raise(y.DuplicateProto, c)), r.used = !0;
      }
    }
    shouldExitDescending(t, e) {
      return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === e;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const t = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.optionFlags & 128 && (t.tokens = this.tokens), t;
    }
    parseExpression(t, e) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
    }
    parseExpressionBase(t) {
      const e = this.state.startLoc, r = this.parseMaybeAssign(t);
      if (this.match(12)) {
        const a = this.startNodeAt(e);
        for (a.expressions = [r]; this.eat(12); )
          a.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(a.expressions), this.finishNode(a, "SequenceExpression");
      }
      return r;
    }
    parseMaybeAssignDisallowIn(t, e) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
    }
    parseMaybeAssignAllowIn(t, e) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, e));
    }
    setOptionalParametersError(t, e) {
      var r;
      t.optionalParametersLoc = (r = e == null ? void 0 : e.loc) != null ? r : this.state.startLoc;
    }
    parseMaybeAssign(t, e) {
      const r = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let M = this.parseYield();
        return e && (M = e.call(this, M, r)), M;
      }
      let a;
      t ? a = !1 : (t = new or(), a = !0);
      const {
        type: c
      } = this.state;
      (c === 10 || fe(c)) && (this.state.potentialArrowAt = this.state.start);
      let E = this.parseMaybeConditional(t);
      if (e && (E = e.call(this, E, r)), st(this.state.type)) {
        const M = this.startNodeAt(r), Y = this.state.value;
        if (M.operator = Y, this.match(29)) {
          this.toAssignable(E, !0), M.left = E;
          const se = r.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= se && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= se && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= se && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
        } else
          M.left = E;
        return this.next(), M.right = this.parseMaybeAssign(), this.checkLVal(E, this.finishNode(M, "AssignmentExpression")), M;
      } else a && this.checkExpressionErrors(t, !0);
      return E;
    }
    parseMaybeConditional(t) {
      const e = this.state.startLoc, r = this.state.potentialArrowAt, a = this.parseExprOps(t);
      return this.shouldExitDescending(a, r) ? a : this.parseConditional(a, e, t);
    }
    parseConditional(t, e, r) {
      if (this.eat(17)) {
        const a = this.startNodeAt(e);
        return a.test = t, a.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), a.alternate = this.parseMaybeAssign(), this.finishNode(a, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      const e = this.state.startLoc, r = this.state.potentialArrowAt, a = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(a, r) ? a : this.parseExprOp(a, e, -1);
    }
    parseExprOp(t, e, r) {
      if (this.isPrivateName(t)) {
        const c = this.getPrivateNameSV(t);
        (r >= j(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(y.PrivateInExpectedIn, t, {
          identifierName: c
        }), this.classScope.usePrivateName(c, t.loc.start);
      }
      const a = this.state.type;
      if (it(a) && (this.prodParam.hasIn || !this.match(58))) {
        let c = j(a);
        if (c > r) {
          if (a === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, e);
          }
          const E = this.startNodeAt(e);
          E.left = t, E.operator = this.state.value;
          const M = a === 41 || a === 42, Y = a === 40;
          if (Y && (c = j(42)), this.next(), a === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(y.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          E.right = this.parseExprOpRightExpr(a, c);
          const se = this.finishNode(E, M || Y ? "LogicalExpression" : "BinaryExpression"), ue = this.state.type;
          if (Y && (ue === 41 || ue === 42) || M && ue === 40)
            throw this.raise(y.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(se, e, r);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, e) {
      const r = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(y.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, e), r);
            });
        default:
          return this.parseExprOpBaseRightExpr(t, e);
      }
    }
    parseExprOpBaseRightExpr(t, e) {
      const r = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, D(t) ? e - 1 : e);
    }
    parseHackPipeBody() {
      var t;
      const {
        startLoc: e
      } = this.state, r = this.parseMaybeAssign();
      return g.has(r.type) && !((t = r.extra) != null && t.parenthesized) && this.raise(y.PipeUnparenthesizedBody, e, {
        type: r.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipeTopicUnused, e), r;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(y.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, e) {
      const r = this.state.startLoc, a = this.isContextual(96);
      if (a && this.recordAwaitIfAllowed()) {
        this.next();
        const Y = this.parseAwait(r);
        return e || this.checkExponentialAfterUnary(Y), Y;
      }
      const c = this.match(34), E = this.startNode();
      if (Xe(this.state.type)) {
        E.operator = this.state.value, E.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        const Y = this.match(89);
        if (this.next(), E.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && Y) {
          const se = E.argument;
          se.type === "Identifier" ? this.raise(y.StrictDelete, E) : this.hasPropertyAsPrivateName(se) && this.raise(y.DeletePrivateField, E);
        }
        if (!c)
          return e || this.checkExponentialAfterUnary(E), this.finishNode(E, "UnaryExpression");
      }
      const M = this.parseUpdate(E, c, t);
      if (a) {
        const {
          type: Y
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? He(Y) : He(Y) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(y.AwaitNotInAsyncContext, r), this.parseAwait(r);
      }
      return M;
    }
    parseUpdate(t, e, r) {
      if (e) {
        const E = t;
        return this.checkLVal(E.argument, this.finishNode(E, "UpdateExpression")), t;
      }
      const a = this.state.startLoc;
      let c = this.parseExprSubscripts(r);
      if (this.checkExpressionErrors(r, !1)) return c;
      for (; ft(this.state.type) && !this.canInsertSemicolon(); ) {
        const E = this.startNodeAt(a);
        E.operator = this.state.value, E.prefix = !1, E.argument = c, this.next(), this.checkLVal(c, c = this.finishNode(E, "UpdateExpression"));
      }
      return c;
    }
    parseExprSubscripts(t) {
      const e = this.state.startLoc, r = this.state.potentialArrowAt, a = this.parseExprAtom(t);
      return this.shouldExitDescending(a, r) ? a : this.parseSubscripts(a, e);
    }
    parseSubscripts(t, e, r) {
      const a = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, e, r, a), a.maybeAsyncArrow = !1;
      while (!a.stop);
      return t;
    }
    parseSubscript(t, e, r, a) {
      const {
        type: c
      } = this.state;
      if (!r && c === 15)
        return this.parseBind(t, e, r, a);
      if (V(c))
        return this.parseTaggedTemplateExpression(t, e, a);
      let E = !1;
      if (c === 18) {
        if (r && (this.raise(y.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return a.stop = !0, t;
        a.optionalChainMember = E = !0, this.next();
      }
      if (!r && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, e, a, E);
      {
        const M = this.eat(0);
        return M || E || this.eat(16) ? this.parseMember(t, e, a, M, E) : (a.stop = !0, t);
      }
    }
    parseMember(t, e, r, a, c) {
      const E = this.startNodeAt(e);
      return E.object = t, E.computed = a, a ? (E.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" && this.raise(y.SuperPrivateField, e), this.classScope.usePrivateName(this.state.value, this.state.startLoc), E.property = this.parsePrivateName()) : E.property = this.parseIdentifier(!0), r.optionalChainMember ? (E.optional = c, this.finishNode(E, "OptionalMemberExpression")) : this.finishNode(E, "MemberExpression");
    }
    parseBind(t, e, r, a) {
      const c = this.startNodeAt(e);
      return c.object = t, this.next(), c.callee = this.parseNoCallExpr(), a.stop = !0, this.parseSubscripts(this.finishNode(c, "BindExpression"), e, r);
    }
    parseCoverCallAndAsyncArrowHead(t, e, r, a) {
      const c = this.state.maybeInArrowParameters;
      let E = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const M = this.startNodeAt(e);
      M.callee = t;
      const {
        maybeAsyncArrow: Y,
        optionalChainMember: se
      } = r;
      Y && (this.expressionScope.enter(ci()), E = new or()), se && (M.optional = a), a ? M.arguments = this.parseCallExpressionArguments(11) : M.arguments = this.parseCallExpressionArguments(11, t.type !== "Super", M, E);
      let ue = this.finishCallExpression(M, se);
      return Y && this.shouldParseAsyncArrow() && !a ? (r.stop = !0, this.checkDestructuringPrivate(E), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), ue = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e), ue)) : (Y && (this.checkExpressionErrors(E, !0), this.expressionScope.exit()), this.toReferencedArguments(ue)), this.state.maybeInArrowParameters = c, ue;
    }
    toReferencedArguments(t, e) {
      this.toReferencedListDeep(t.arguments, e);
    }
    parseTaggedTemplateExpression(t, e, r) {
      const a = this.startNodeAt(e);
      return a.tag = t, a.quasi = this.parseTemplate(!0), r.optionalChainMember && this.raise(y.OptionalChainingNoTemplate, e), this.finishNode(a, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(t, e) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(y.ImportCallArity, t);
        else
          for (const r of t.arguments)
            r.type === "SpreadElement" && this.raise(y.ImportCallSpreadArgument, r);
      return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, e, r, a) {
      const c = [];
      let E = !0;
      const M = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (E)
          E = !1;
        else if (this.expect(12), this.match(t)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        c.push(this.parseExprListItem(!1, a, e));
      }
      return this.state.inFSharpPipelineDirectBody = M, c;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, e) {
      var r;
      return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, !0, (r = e.extra) == null ? void 0 : r.trailingCommaLoc), e.innerComments && Gt(t, e.innerComments), e.callee.trailingComments && Gt(t, e.callee.trailingComments), t;
    }
    parseNoCallExpr() {
      const t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let e, r = null;
      const {
        type: a
      } = this.state;
      switch (a) {
        case 79:
          return this.parseSuper();
        case 83:
          return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e) : this.match(10) ? this.optionFlags & 256 ? this.parseImportCall(e) : this.finishNode(e, "Import") : (this.raise(y.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e, "Import"));
        case 78:
          return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const c = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(c);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          r = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          e = this.startNode(), this.next(), e.object = null;
          const c = e.callee = this.parseNoCallExpr();
          if (c.type === "MemberExpression")
            return this.finishNode(e, "BindExpression");
          throw this.raise(y.UnsupportedBind, c);
        }
        case 139:
          return this.raise(y.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const c = this.getPluginOption("pipelineOperator", "proposal");
          if (c)
            return this.parseTopicReference(c);
          this.unexpected();
          break;
        }
        case 47: {
          const c = this.input.codePointAt(this.nextTokenStart());
          $e(c) || c === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (a === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (fe(a)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            const c = this.state.potentialArrowAt === this.state.start, E = this.state.containsEsc, M = this.parseIdentifier();
            if (!E && M.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: Y
              } = this.state;
              if (Y === 68)
                return this.resetPreviousNodeTrailingComments(M), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(M));
              if (fe(Y))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(M)) : M;
              if (Y === 90)
                return this.resetPreviousNodeTrailingComments(M), this.parseDo(this.startNodeAtNode(M), !0);
            }
            return c && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(M), [M], !1)) : M;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, e) {
      const r = this.getPluginOption("pipelineOperator", "proposal");
      if (r)
        return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = o(this.state.endLoc, -1), this.parseTopicReference(r);
      this.unexpected();
    }
    parseTopicReference(t) {
      const e = this.startNode(), r = this.state.startLoc, a = this.state.type;
      return this.next(), this.finishTopicReference(e, r, t, a);
    }
    finishTopicReference(t, e, r, a) {
      if (this.testTopicReferenceConfiguration(r, e, a))
        return r === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PipeTopicUnbound, e), this.registerTopicReference(), this.finishNode(t, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PrimaryTopicNotAllowed, e), this.registerTopicReference(), this.finishNode(t, "PipelinePrimaryTopicReference"));
      throw this.raise(y.PipeTopicUnconfiguredToken, e, {
        token: ve(a)
      });
    }
    testTopicReferenceConfiguration(t, e, r) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ve(r)
          }]);
        case "smart":
          return r === 27;
        default:
          throw this.raise(y.PipeTopicRequiresHackPipes, e);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(ar(!0, this.prodParam.hasYield));
      const e = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(y.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, e, !0);
    }
    parseDo(t, e) {
      this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
      const r = this.state.labels;
      return this.state.labels = [], e ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = r, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      const t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(y.SuperNotAllowed, t) : !this.scope.allowSuper && !(this.optionFlags & 16) && this.raise(y.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(y.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      const t = this.startNode(), e = this.startNodeAt(o(this.state.startLoc, 1)), r = this.state.value;
      return this.next(), t.id = this.createIdentifier(e, r), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const e = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, e, r) {
      t.meta = e;
      const a = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== r || a) && this.raise(y.UnsupportedMetaProperty, t.property, {
        target: e.name,
        onlyValidPropertyName: r
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      const e = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(y.ImportMetaOutsideModule, e), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        const r = this.isContextual(105);
        if (this.expectPlugin(r ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 256))
          throw this.raise(y.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = r ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, e, "meta");
    }
    parseLiteralAtNode(t, e, r) {
      return this.addExtra(r, "rawValue", t), this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.value = t, this.next(), this.finishNode(r, e);
    }
    parseLiteral(t, e) {
      const r = this.startNode();
      return this.parseLiteralAtNode(t, e, r);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      const e = this.startNode();
      return this.addExtra(e, "raw", this.input.slice(this.offsetToSourcePos(e.start), this.state.end)), e.pattern = t.pattern, e.flags = t.flags, this.next(), this.finishNode(e, "RegExpLiteral");
    }
    parseBooleanLiteral(t) {
      const e = this.startNode();
      return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
    }
    parseNullLiteral() {
      const t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      const e = this.state.startLoc;
      let r;
      this.next(), this.expressionScope.enter(ui());
      const a = this.state.maybeInArrowParameters, c = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const E = this.state.startLoc, M = [], Y = new or();
      let se = !0, ue, Ee;
      for (; !this.match(11); ) {
        if (se)
          se = !1;
        else if (this.expect(12, Y.optionalParametersLoc === null ? null : Y.optionalParametersLoc), this.match(11)) {
          Ee = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const Re = this.state.startLoc;
          if (ue = this.state.startLoc, M.push(this.parseParenItem(this.parseRestBinding(), Re)), !this.checkCommaAfterRest(41))
            break;
        } else
          M.push(this.parseMaybeAssignAllowIn(Y, this.parseParenItem));
      }
      const _e = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = a, this.state.inFSharpPipelineDirectBody = c;
      let ke = this.startNodeAt(e);
      return t && this.shouldParseArrow(M) && (ke = this.parseArrow(ke)) ? (this.checkDestructuringPrivate(Y), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(ke, M, !1), ke) : (this.expressionScope.exit(), M.length || this.unexpected(this.state.lastTokStartLoc), Ee && this.unexpected(Ee), ue && this.unexpected(ue), this.checkExpressionErrors(Y, !0), this.toReferencedListDeep(M, !0), M.length > 1 ? (r = this.startNodeAt(E), r.expressions = M, this.finishNode(r, "SequenceExpression"), this.resetEndLocation(r, _e)) : r = M[0], this.wrapParenthesis(e, r));
    }
    wrapParenthesis(t, e) {
      if (!(this.optionFlags & 512))
        return this.addExtra(e, "parenthesized", !0), this.addExtra(e, "parenStart", t.index), this.takeSurroundingComments(e, t.index, this.state.lastTokEndLoc.index), e;
      const r = this.startNodeAt(t);
      return r.expression = e, this.finishNode(r, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, e) {
      return t;
    }
    parseNewOrNewTarget() {
      const t = this.startNode();
      if (this.next(), this.match(16)) {
        const e = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        const r = this.parseMetaProperty(t, e, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(y.UnexpectedNewTarget, r), r;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        const e = this.parseExprList(11);
        this.toReferencedList(e), t.arguments = e;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      const e = this.match(83), r = this.parseNoCallExpr();
      t.callee = r, e && (r.type === "Import" || r.type === "ImportExpression") && this.raise(y.ImportCallNotNewExpression, r);
    }
    parseTemplateElement(t) {
      const {
        start: e,
        startLoc: r,
        end: a,
        value: c
      } = this.state, E = e + 1, M = this.startNodeAt(o(r, 1));
      c === null && (t || this.raise(y.InvalidEscapeSequenceTemplate, o(this.state.firstInvalidTemplateEscapePos, 1)));
      const Y = this.match(24), se = Y ? -1 : -2, ue = a + se;
      M.value = {
        raw: this.input.slice(E, ue).replace(/\r\n?/g, `
`),
        cooked: c === null ? null : c.slice(1, se)
      }, M.tail = Y, this.next();
      const Ee = this.finishNode(M, "TemplateElement");
      return this.resetEndLocation(Ee, o(this.state.lastTokEndLoc, se)), Ee;
    }
    parseTemplate(t) {
      const e = this.startNode();
      let r = this.parseTemplateElement(t);
      const a = [r], c = [];
      for (; !r.tail; )
        c.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), a.push(r = this.parseTemplateElement(t));
      return e.expressions = c, e.quasis = a, this.finishNode(e, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, e, r, a) {
      r && this.expectPlugin("recordAndTuple");
      const c = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const E = /* @__PURE__ */ Object.create(null);
      let M = !0;
      const Y = this.startNode();
      for (Y.properties = [], this.next(); !this.match(t); ) {
        if (M)
          M = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(Y);
          break;
        }
        let ue;
        e ? ue = this.parseBindingProperty() : (ue = this.parsePropertyDefinition(a), this.checkProto(ue, r, E, a)), r && !this.isObjectProperty(ue) && ue.type !== "SpreadElement" && this.raise(y.InvalidRecordProperty, ue), ue.shorthand && this.addExtra(ue, "shorthand", !0), Y.properties.push(ue);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = c;
      let se = "ObjectExpression";
      return e ? se = "ObjectPattern" : r && (se = "RecordExpression"), this.finishNode(Y, se);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let e = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(y.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          e.push(this.parseDecorator());
      const r = this.startNode();
      let a = !1, c = !1, E;
      if (this.match(21))
        return e.length && this.unexpected(), this.parseSpread();
      e.length && (r.decorators = e, e = []), r.method = !1, t && (E = this.state.startLoc);
      let M = this.eat(55);
      this.parsePropertyNamePrefixOperator(r);
      const Y = this.state.containsEsc;
      if (this.parsePropertyName(r, t), !M && !Y && this.maybeAsyncOrAccessorProp(r)) {
        const {
          key: se
        } = r, ue = se.name;
        ue === "async" && !this.hasPrecedingLineBreak() && (a = !0, this.resetPreviousNodeTrailingComments(se), M = this.eat(55), this.parsePropertyName(r)), (ue === "get" || ue === "set") && (c = !0, this.resetPreviousNodeTrailingComments(se), r.kind = ue, this.match(55) && (M = !0, this.raise(y.AccessorIsGenerator, this.state.curPosition(), {
          kind: ue
        }), this.next()), this.parsePropertyName(r));
      }
      return this.parseObjPropValue(r, E, M, a, !1, c, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var e;
      const r = this.getGetterSetterExpectedParamCount(t), a = this.getObjectOrClassMethodParams(t);
      a.length !== r && this.raise(t.kind === "get" ? y.BadGetterArity : y.BadSetterArity, t), t.kind === "set" && ((e = a[a.length - 1]) == null ? void 0 : e.type) === "RestElement" && this.raise(y.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, e, r, a, c) {
      if (c) {
        const E = this.parseMethod(t, e, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(E), E;
      }
      if (r || e || this.match(10))
        return a && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, e, r, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, e, r, a) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(a), this.finishNode(t, "ObjectProperty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), r)
          t.value = this.parseMaybeDefault(e, wt(t.key));
        else if (this.match(29)) {
          const c = this.state.startLoc;
          a != null ? a.shorthandAssignLoc === null && (a.shorthandAssignLoc = c) : this.raise(y.InvalidCoverInitializedName, c), t.value = this.parseMaybeDefault(e, wt(t.key));
        } else
          t.value = wt(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, e, r, a, c, E, M) {
      const Y = this.parseObjectMethod(t, r, a, c, E) || this.parseObjectProperty(t, e, c, M);
      return Y || this.unexpected(), Y;
    }
    parsePropertyName(t, e) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: r,
          value: a
        } = this.state;
        let c;
        if (de(r))
          c = this.parseIdentifier(!0);
        else
          switch (r) {
            case 135:
              c = this.parseNumericLiteral(a);
              break;
            case 134:
              c = this.parseStringLiteral(a);
              break;
            case 136:
              c = this.parseBigIntLiteral(a);
              break;
            case 139: {
              const E = this.state.startLoc;
              e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = E) : this.raise(y.UnexpectedPrivateField, E), c = this.parsePrivateName();
              break;
            }
            default:
              if (r === 137) {
                c = this.parseDecimalLiteral(a);
                break;
              }
              this.unexpected();
          }
        t.key = c, r !== 139 && (t.computed = !1);
      }
    }
    initFunction(t, e) {
      t.id = null, t.generator = !1, t.async = e;
    }
    parseMethod(t, e, r, a, c, E, M = !1) {
      this.initFunction(t, r), t.generator = e, this.scope.enter(18 | (M ? 64 : 0) | (c ? 32 : 0)), this.prodParam.enter(ar(r, t.generator)), this.parseFunctionParams(t, a);
      const Y = this.parseFunctionBodyAndFinish(t, E, !0);
      return this.prodParam.exit(), this.scope.exit(), Y;
    }
    parseArrayLike(t, e, r, a) {
      r && this.expectPlugin("recordAndTuple");
      const c = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const E = this.startNode();
      return this.next(), E.elements = this.parseExprList(t, !r, a, E), this.state.inFSharpPipelineDirectBody = c, this.finishNode(E, r ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, e, r, a) {
      this.scope.enter(6);
      let c = ar(r, !1);
      !this.match(5) && this.prodParam.hasIn && (c |= 8), this.prodParam.enter(c), this.initFunction(t, r);
      const E = this.state.maybeInArrowParameters;
      return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, a)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = E, this.finishNode(t, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(t, e, r) {
      this.toAssignableList(e, r, !1), t.params = e;
    }
    parseFunctionBodyAndFinish(t, e, r = !1) {
      return this.parseFunctionBody(t, !1, r), this.finishNode(t, e);
    }
    parseFunctionBody(t, e, r = !1) {
      const a = e && !this.match(5);
      if (this.expressionScope.enter(kr()), a)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1);
      else {
        const c = this.state.strict, E = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (M) => {
          const Y = !this.isSimpleParamList(t.params);
          M && Y && this.raise(y.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          const se = !c && this.state.strict;
          this.checkParams(t, !this.state.strict && !e && !r && !Y, e, se), this.state.strict && t.id && this.checkIdentifier(t.id, 65, se);
        }), this.prodParam.exit(), this.state.labels = E;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let e = 0, r = t.length; e < r; e++)
        if (!this.isSimpleParameter(t[e])) return !1;
      return !0;
    }
    checkParams(t, e, r, a = !0) {
      const c = !e && /* @__PURE__ */ new Set(), E = {
        type: "FormalParameters"
      };
      for (const M of t.params)
        this.checkLVal(M, E, 5, c, a);
    }
    parseExprList(t, e, r, a) {
      const c = [];
      let E = !0;
      for (; !this.eat(t); ) {
        if (E)
          E = !1;
        else if (this.expect(12), this.match(t)) {
          a && this.addTrailingCommaExtraToNode(a), this.next();
          break;
        }
        c.push(this.parseExprListItem(e, r));
      }
      return c;
    }
    parseExprListItem(t, e, r) {
      let a;
      if (this.match(12))
        t || this.raise(y.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), a = null;
      else if (this.match(21)) {
        const c = this.state.startLoc;
        a = this.parseParenItem(this.parseSpread(e), c);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r || this.raise(y.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const c = this.startNode();
        this.next(), a = this.finishNode(c, "ArgumentPlaceholder");
      } else
        a = this.parseMaybeAssignAllowIn(e, this.parseParenItem);
      return a;
    }
    parseIdentifier(t) {
      const e = this.startNode(), r = this.parseIdentifierName(t);
      return this.createIdentifier(e, r);
    }
    createIdentifier(t, e) {
      return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let e;
      const {
        startLoc: r,
        type: a
      } = this.state;
      de(a) ? e = this.state.value : this.unexpected();
      const c = Te(a);
      return t ? c && this.replaceToken(132) : this.checkReservedWord(e, r, c, !1), this.next(), e;
    }
    checkReservedWord(t, e, r, a) {
      if (t.length > 10 || !Wt(t))
        return;
      if (r && Nt(t)) {
        this.raise(y.UnexpectedKeyword, e, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? a ? Kt : ct : Ke)(t, this.inModule)) {
        this.raise(y.UnexpectedReservedWord, e, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(y.YieldBindingIdentifier, e);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(y.AwaitBindingIdentifier, e);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(y.AwaitBindingIdentifierInStaticBlock, e);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(e);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(y.ArgumentsInClass, e);
        return;
      }
    }
    recordAwaitIfAllowed() {
      const t = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
    }
    parseAwait(t) {
      const e = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(y.AwaitExpressionFormalParameter, e), this.eat(55) && this.raise(y.ObsoleteAwaitStar, e), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (e.argument = this.parseMaybeUnary(null, !0)), this.finishNode(e, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      const {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || V(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
    }
    parseYield() {
      const t = this.startNode();
      this.expressionScope.recordParameterInitializerError(y.YieldInParameter, t), this.next();
      let e = !1, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (e = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!e) break;
          default:
            r = this.parseMaybeAssign();
        }
      return t.delegate = e, t.argument = r, this.finishNode(t, "YieldExpression");
    }
    parseImportCall(t) {
      if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12) && !this.match(11) && (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(y.ImportCallArity, t);
      }
      return this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, e) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(y.PipelineHeadSequenceExpression, e);
    }
    parseSmartPipelineBodyInStyle(t, e) {
      if (this.isSimpleReference(t)) {
        const r = this.startNodeAt(e);
        return r.callee = t, this.finishNode(r, "PipelineBareFunction");
      } else {
        const r = this.startNodeAt(e);
        return this.checkSmartPipeTopicBodyEarlyErrors(e), r.expression = t, this.finishNode(r, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(y.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      const e = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = e;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const e = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = e;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      const e = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = e;
      }
    }
    allowInAnd(t) {
      const e = this.prodParam.currentFlags();
      if (8 & ~e) {
        this.prodParam.enter(e | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      const e = this.prodParam.currentFlags();
      if (8 & e) {
        this.prodParam.enter(e & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      const e = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const r = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const a = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, t);
      return this.state.inFSharpPipelineDirectBody = r, a;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const e = this.startNodeAt(this.state.endLoc);
      this.next();
      const r = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(e, 8, "module");
      } finally {
        r();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }
  const Sr = {
    kind: 1
  }, ji = {
    kind: 2
  }, qi = /[\uD800-\uDFFF]/u, gr = /in(?:stanceof)?/y;
  function Ui(b, t, e) {
    for (let r = 0; r < b.length; r++) {
      const a = b[r], {
        type: c
      } = a;
      if (typeof c == "number") {
        {
          if (c === 139) {
            const {
              loc: E,
              start: M,
              value: Y,
              end: se
            } = a, ue = M + 1, Ee = o(E.start, 1);
            b.splice(r, 1, new _t({
              type: le(27),
              value: "#",
              start: M,
              end: ue,
              startLoc: E.start,
              endLoc: Ee
            }), new _t({
              type: le(132),
              value: Y,
              start: ue,
              end: se,
              startLoc: Ee,
              endLoc: E.end
            })), r++;
            continue;
          }
          if (V(c)) {
            const {
              loc: E,
              start: M,
              value: Y,
              end: se
            } = a, ue = M + 1, Ee = o(E.start, 1);
            let _e;
            t.charCodeAt(M - e) === 96 ? _e = new _t({
              type: le(22),
              value: "`",
              start: M,
              end: ue,
              startLoc: E.start,
              endLoc: Ee
            }) : _e = new _t({
              type: le(8),
              value: "}",
              start: M,
              end: ue,
              startLoc: E.start,
              endLoc: Ee
            });
            let ke, Re, Qe, mt;
            c === 24 ? (Re = se - 1, Qe = o(E.end, -1), ke = Y === null ? null : Y.slice(1, -1), mt = new _t({
              type: le(22),
              value: "`",
              start: Re,
              end: se,
              startLoc: Qe,
              endLoc: E.end
            })) : (Re = se - 2, Qe = o(E.end, -2), ke = Y === null ? null : Y.slice(1, -2), mt = new _t({
              type: le(23),
              value: "${",
              start: Re,
              end: se,
              startLoc: Qe,
              endLoc: E.end
            })), b.splice(r, 1, _e, new _t({
              type: le(20),
              value: ke,
              start: ue,
              end: Re,
              startLoc: Ee,
              endLoc: Qe
            }), mt), r += 2;
            continue;
          }
        }
        a.type = le(c);
      }
    }
    return b;
  }
  class Vi extends Ri {
    parseTopLevel(t, e) {
      return t.program = this.parseProgram(e), t.comments = this.comments, this.optionFlags & 128 && (t.tokens = Ui(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
    }
    parseProgram(t, e = 140, r = this.options.sourceType) {
      if (t.sourceType = r, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, e), this.inModule) {
        if (!(this.optionFlags & 32) && this.scope.undefinedExports.size > 0)
          for (const [c, E] of Array.from(this.scope.undefinedExports))
            this.raise(y.ModuleExportUndefined, E, {
              localName: c
            });
        this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let a;
      return e === 140 ? a = this.finishNode(t, "Program") : a = this.finishNodeAt(t, "Program", o(this.state.startLoc, -1)), a;
    }
    stmtToDirective(t) {
      const e = t;
      e.type = "Directive", e.value = e.expression, delete e.expression;
      const r = e.value, a = r.value, c = this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end)), E = r.value = c.slice(1, -1);
      return this.addExtra(r, "raw", c), this.addExtra(r, "rawValue", E), this.addExtra(r, "expressionValue", a), r.type = "DirectiveLiteral", e;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, e) {
      if ($e(t)) {
        if (gr.lastIndex = e, gr.test(this.input)) {
          const r = this.codePointAtPos(gr.lastIndex);
          if (!et(r) && r !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      const t = this.nextTokenStart(), e = this.codePointAtPos(t);
      return this.chStartsBindingPattern(e) || this.chStartsBindingIdentifier(e, t);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      const t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
      return e === 123 || this.chStartsBindingIdentifier(e, t);
    }
    startsUsingForOf() {
      const {
        type: t,
        containsEsc: e
      } = this.lookahead();
      if (t === 102 && !e)
        return !1;
      if (fe(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        const e = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(e, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let e = 0;
      return this.options.annexB && !this.state.strict && (e |= 4, t && (e |= 8)), this.parseStatementLike(e);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let e = null;
      return this.match(26) && (e = this.parseDecorators(!0)), this.parseStatementContent(t, e);
    }
    parseStatementContent(t, e) {
      const r = this.state.type, a = this.startNode(), c = !!(t & 2), E = !!(t & 4), M = t & 1;
      switch (r) {
        case 60:
          return this.parseBreakContinueStatement(a, !0);
        case 63:
          return this.parseBreakContinueStatement(a, !1);
        case 64:
          return this.parseDebuggerStatement(a);
        case 90:
          return this.parseDoWhileStatement(a);
        case 91:
          return this.parseForStatement(a);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return E || this.raise(this.state.strict ? y.StrictFunction : this.options.annexB ? y.SloppyFunctionAnnexB : y.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(a, !1, !c && E);
        case 80:
          return c || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e, a), !0);
        case 69:
          return this.parseIfStatement(a);
        case 70:
          return this.parseReturnStatement(a);
        case 71:
          return this.parseSwitchStatement(a);
        case 72:
          return this.parseThrowStatement(a);
        case 73:
          return this.parseTryStatement(a);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? c || this.raise(y.UnexpectedLexicalDeclaration, a) : this.raise(y.AwaitUsingNotInAsyncContext, a), this.next(), this.parseVarStatement(a, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(y.UnexpectedUsingDeclaration, this.state.startLoc) : c || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(a, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          const ue = this.nextTokenStart(), Ee = this.codePointAtPos(ue);
          if (Ee !== 91 && (!c && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(Ee, ue) && Ee !== 123))
            break;
        }
        case 75:
          c || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const ue = this.state.value;
          return this.parseVarStatement(a, ue);
        }
        case 92:
          return this.parseWhileStatement(a);
        case 76:
          return this.parseWithStatement(a);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(a);
        case 83: {
          const ue = this.lookaheadCharCode();
          if (ue === 40 || ue === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !M && this.raise(y.UnexpectedImportExport, this.state.startLoc), this.next();
          let ue;
          return r === 83 ? (ue = this.parseImport(a), ue.type === "ImportDeclaration" && (!ue.importKind || ue.importKind === "value") && (this.sawUnambiguousESM = !0)) : (ue = this.parseExport(a, e), (ue.type === "ExportNamedDeclaration" && (!ue.exportKind || ue.exportKind === "value") || ue.type === "ExportAllDeclaration" && (!ue.exportKind || ue.exportKind === "value") || ue.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(ue), ue;
        }
        default:
          if (this.isAsyncFunction())
            return c || this.raise(y.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(a, !0, !c && E);
      }
      const Y = this.state.value, se = this.parseExpression();
      return fe(r) && se.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(a, Y, se, t) : this.parseExpressionStatement(a, se, e);
    }
    assertModuleNodeAllowed(t) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(y.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(t, e, r) {
      if (t) {
        var a;
        (a = e.decorators) != null && a.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(y.DecoratorsBeforeAfterExport, e.decorators[0]), e.decorators.unshift(...t)) : e.decorators = t, this.resetStartLocationFromNode(e, t[0]), r && this.resetStartLocationFromNode(r, e);
      }
      return e;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      const e = [];
      do
        e.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(y.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(y.UnexpectedLeadingDecorator, this.state.startLoc);
      return e;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const e = this.state.startLoc;
        let r;
        if (this.match(10)) {
          const a = this.state.startLoc;
          this.next(), r = this.parseExpression(), this.expect(11), r = this.wrapParenthesis(a, r);
          const c = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(r, a), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== r && this.raise(y.DecoratorArgumentsOutsideParentheses, c);
        } else {
          for (r = this.parseIdentifier(!1); this.eat(16); ) {
            const a = this.startNodeAt(e);
            a.object = r, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), a.computed = !1, r = this.finishNode(a, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(r, e);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t, e) {
      if (this.eat(10)) {
        const r = this.startNodeAt(e);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, e) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, e) {
      let r;
      for (r = 0; r < this.state.labels.length; ++r) {
        const a = this.state.labels[r];
        if ((t.label == null || a.name === t.label.name) && (a.kind != null && (e || a.kind === 1) || t.label && e))
          break;
      }
      if (r === this.state.labels.length) {
        const a = e ? "BreakStatement" : "ContinueStatement";
        this.raise(y.IllegalBreakContinue, t, {
          type: a
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(Sr), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(Sr);
      let e = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (e = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13))
        return e !== null && this.unexpected(e), this.parseFor(t, null);
      const r = this.isContextual(100);
      {
        const Y = this.isContextual(96) && this.startsAwaitUsing(), se = Y || this.isContextual(107) && this.startsUsingForOf(), ue = r && this.hasFollowingBindingAtom() || se;
        if (this.match(74) || this.match(75) || ue) {
          const Ee = this.startNode();
          let _e;
          Y ? (_e = "await using", this.recordAwaitIfAllowed() || this.raise(y.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : _e = this.state.value, this.next(), this.parseVar(Ee, !0, _e);
          const ke = this.finishNode(Ee, "VariableDeclaration"), Re = this.match(58);
          return Re && se && this.raise(y.ForInUsing, ke), (Re || this.isContextual(102)) && ke.declarations.length === 1 ? this.parseForIn(t, ke, e) : (e !== null && this.unexpected(e), this.parseFor(t, ke));
        }
      }
      const a = this.isContextual(95), c = new or(), E = this.parseExpression(!0, c), M = this.isContextual(102);
      if (M && (r && this.raise(y.ForOfLet, E), e === null && a && E.type === "Identifier" && this.raise(y.ForOfAsync, E)), M || this.match(58)) {
        this.checkDestructuringPrivate(c), this.toAssignable(E, !0);
        const Y = M ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(E, {
          type: Y
        }), this.parseForIn(t, E, e);
      } else
        this.checkExpressionErrors(c, !0);
      return e !== null && this.unexpected(e), this.parseFor(t, E);
    }
    parseFunctionStatement(t, e, r) {
      return this.next(), this.parseFunction(t, 1 | (r ? 2 : 0) | (e ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(y.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      const e = t.cases = [];
      this.expect(5), this.state.labels.push(ji), this.scope.enter(0);
      let r;
      for (let a; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const c = this.match(61);
          r && this.finishNode(r, "SwitchCase"), e.push(r = this.startNode()), r.consequent = [], this.next(), c ? r.test = this.parseExpression() : (a && this.raise(y.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), a = !0, r.test = null), this.expect(14);
        } else
          r ? r.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), r && this.finishNode(r, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(y.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        type: "CatchClause"
      }, 9), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        const e = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(0)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(y.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
    }
    parseVarStatement(t, e, r = !1) {
      return this.next(), this.parseVar(t, !1, e, r), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Sr), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(y.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, e, r, a) {
      for (const E of this.state.labels)
        E.name === e && this.raise(y.LabelRedeclaration, r, {
          labelName: e
        });
      const c = Ge(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let E = this.state.labels.length - 1; E >= 0; E--) {
        const M = this.state.labels[E];
        if (M.statementStart === t.start)
          M.statementStart = this.sourceToOffsetPos(this.state.start), M.kind = c;
        else
          break;
      }
      return this.state.labels.push({
        name: e,
        kind: c,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), t.body = a & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = r, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, e, r) {
      return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, e = !0, r) {
      const a = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(0), this.parseBlockBody(a, t, !1, 8, r), e && this.scope.exit(), this.finishNode(a, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, e, r, a, c) {
      const E = t.body = [], M = t.directives = [];
      this.parseBlockOrModuleBlockBody(E, e ? M : void 0, r, a, c);
    }
    parseBlockOrModuleBlockBody(t, e, r, a, c) {
      const E = this.state.strict;
      let M = !1, Y = !1;
      for (; !this.match(a); ) {
        const se = r ? this.parseModuleItem() : this.parseStatementListItem();
        if (e && !Y) {
          if (this.isValidDirective(se)) {
            const ue = this.stmtToDirective(se);
            e.push(ue), !M && ue.value.value === "use strict" && (M = !0, this.setStrict(!0));
            continue;
          }
          Y = !0, this.state.strictErrors.clear();
        }
        t.push(se);
      }
      c == null || c.call(this, M), E || this.setStrict(!1), this.next();
    }
    parseFor(t, e) {
      return t.init = e, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, e, r) {
      const a = this.match(58);
      return this.next(), a ? r !== null && this.unexpected(r) : t.await = r !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!a || !this.options.annexB || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(y.ForInOfLoopInitializer, e, {
        type: a ? "ForInStatement" : "ForOfStatement"
      }), e.type === "AssignmentPattern" && this.raise(y.InvalidLhs, e, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = e, t.right = a ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, a ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, e, r, a = !1) {
      const c = t.declarations = [];
      for (t.kind = r; ; ) {
        const E = this.startNode();
        if (this.parseVarId(E, r), E.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, E.init === null && !a && (E.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(102))) ? this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (r === "const" || r === "using" || r === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: r
        })), c.push(this.finishNode(E, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, e) {
      const r = this.parseBindingAtom();
      (e === "using" || e === "await using") && (r.type === "ArrayPattern" || r.type === "ObjectPattern") && this.raise(y.UsingDeclarationHasBindingPattern, r.loc.start), this.checkLVal(r, {
        type: "VariableDeclarator"
      }, e === "var" ? 5 : 8201), t.id = r;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, e = 0) {
      const r = e & 2, a = !!(e & 1), c = a && !(e & 4), E = !!(e & 8);
      this.initFunction(t, E), this.match(55) && (r && this.raise(y.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = !0), a && (t.id = this.parseFunctionId(c));
      const M = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ar(E, t.generator)), a || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, a ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), a && !r && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = M, t;
    }
    parseFunctionId(t) {
      return t || fe(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, e) {
      this.expect(10), this.expressionScope.enter(li()), t.params = this.parseBindingList(11, 41, 2 | (e ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, e, r) {
      this.next();
      const a = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, e, r), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, a), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(t) {
      return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && this.nameIsConstructor(t.key);
    }
    parseClassBody(t, e) {
      this.classScope.enter();
      const r = {
        hadConstructor: !1,
        hadSuperClass: t
      };
      let a = [];
      const c = this.startNode();
      if (c.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (a.length > 0)
              throw this.raise(y.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            a.push(this.parseDecorator());
            continue;
          }
          const E = this.startNode();
          a.length && (E.decorators = a, this.resetStartLocationFromNode(E, a[0]), a = []), this.parseClassMember(c, E, r), E.kind === "constructor" && E.decorators && E.decorators.length > 0 && this.raise(y.DecoratorConstructor, E);
        }
      }), this.state.strict = e, this.next(), a.length)
        throw this.raise(y.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(c, "ClassBody");
    }
    parseClassMemberFromModifier(t, e) {
      const r = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const a = e;
        return a.kind = "method", a.computed = !1, a.key = r, a.static = !1, this.pushClassMethod(t, a, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        const a = e;
        return a.computed = !1, a.key = r, a.static = !1, t.body.push(this.parseClassProperty(a)), !0;
      }
      return this.resetPreviousNodeTrailingComments(r), !1;
    }
    parseClassMember(t, e, r) {
      const a = this.isContextual(106);
      if (a) {
        if (this.parseClassMemberFromModifier(t, e))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, e);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, e, r, a);
    }
    parseClassMemberWithIsStatic(t, e, r, a) {
      const c = e, E = e, M = e, Y = e, se = e, ue = c, Ee = c;
      if (e.static = a, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
        ue.kind = "method";
        const tt = this.match(139);
        if (this.parseClassElementName(ue), tt) {
          this.pushClassPrivateMethod(t, E, !0, !1);
          return;
        }
        this.isNonstaticConstructor(c) && this.raise(y.ConstructorIsGenerator, c.key), this.pushClassMethod(t, c, !0, !1, !1, !1);
        return;
      }
      const _e = !this.state.containsEsc && fe(this.state.type), ke = this.parseClassElementName(e), Re = _e ? ke.name : null, Qe = this.isPrivateName(ke), mt = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(Ee), this.isClassMethod()) {
        if (ue.kind = "method", Qe) {
          this.pushClassPrivateMethod(t, E, !1, !1);
          return;
        }
        const tt = this.isNonstaticConstructor(c);
        let ut = !1;
        tt && (c.kind = "constructor", r.hadConstructor && !this.hasPlugin("typescript") && this.raise(y.DuplicateConstructor, ke), tt && this.hasPlugin("typescript") && e.override && this.raise(y.OverrideOnConstructor, ke), r.hadConstructor = !0, ut = r.hadSuperClass), this.pushClassMethod(t, c, !1, !1, tt, ut);
      } else if (this.isClassProperty())
        Qe ? this.pushClassPrivateProperty(t, Y) : this.pushClassProperty(t, M);
      else if (Re === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(ke);
        const tt = this.eat(55);
        Ee.optional && this.unexpected(mt), ue.kind = "method";
        const ut = this.match(139);
        this.parseClassElementName(ue), this.parsePostMemberNameModifiers(Ee), ut ? this.pushClassPrivateMethod(t, E, tt, !0) : (this.isNonstaticConstructor(c) && this.raise(y.ConstructorIsAsync, c.key), this.pushClassMethod(t, c, tt, !0, !1, !1));
      } else if ((Re === "get" || Re === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(ke), ue.kind = Re;
        const tt = this.match(139);
        this.parseClassElementName(c), tt ? this.pushClassPrivateMethod(t, E, !1, !1) : (this.isNonstaticConstructor(c) && this.raise(y.ConstructorIsAccessor, c.key), this.pushClassMethod(t, c, !1, !1, !1, !1)), this.checkGetterSetterParams(c);
      } else if (Re === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(ke);
        const tt = this.match(139);
        this.parseClassElementName(M), this.pushClassAccessorProperty(t, se, tt);
      } else this.isLineTerminator() ? Qe ? this.pushClassPrivateProperty(t, Y) : this.pushClassProperty(t, M) : this.unexpected();
    }
    parseClassElementName(t) {
      const {
        type: e,
        value: r
      } = this.state;
      if ((e === 132 || e === 134) && t.static && r === "prototype" && this.raise(y.StaticPrototype, this.state.startLoc), e === 139) {
        r === "constructor" && this.raise(y.ConstructorClassPrivateField, this.state.startLoc);
        const a = this.parsePrivateName();
        return t.key = a, a;
      }
      return this.parsePropertyName(t), t.key;
    }
    parseClassStaticBlock(t, e) {
      var r;
      this.scope.enter(208);
      const a = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const c = e.body = [];
      this.parseBlockOrModuleBlockBody(c, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = a, t.body.push(this.finishNode(e, "StaticBlock")), (r = e.decorators) != null && r.length && this.raise(y.DecoratorStaticBlock, e);
    }
    pushClassProperty(t, e) {
      !e.computed && this.nameIsConstructor(e.key) && this.raise(y.ConstructorClassField, e.key), t.body.push(this.parseClassProperty(e));
    }
    pushClassPrivateProperty(t, e) {
      const r = this.parseClassPrivateProperty(e);
      t.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
    }
    pushClassAccessorProperty(t, e, r) {
      !r && !e.computed && this.nameIsConstructor(e.key) && this.raise(y.ConstructorClassField, e.key);
      const a = this.parseClassAccessorProperty(e);
      t.body.push(a), r && this.classScope.declarePrivateName(this.getPrivateNameSV(a.key), 0, a.key.loc.start);
    }
    pushClassMethod(t, e, r, a, c, E) {
      t.body.push(this.parseMethod(e, r, a, c, E, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, e, r, a) {
      const c = this.parseMethod(e, r, a, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(c);
      const E = c.kind === "get" ? c.static ? 6 : 2 : c.kind === "set" ? c.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(c, E);
    }
    declareClassPrivateMethodInScope(t, e) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(kr()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, e, r, a = 8331) {
      if (fe(this.state.type))
        t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, a);
      else if (r || !e)
        t.id = null;
      else
        throw this.raise(y.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, e) {
      const r = this.parseMaybeImportPhase(t, !0), a = this.maybeParseExportDefaultSpecifier(t, r), c = !a || this.eat(12), E = c && this.eatExportStar(t), M = E && this.maybeParseExportNamespaceSpecifier(t), Y = c && (!M || this.eat(12)), se = a || E;
      if (E && !M) {
        if (a && this.unexpected(), e)
          throw this.raise(y.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
      }
      const ue = this.maybeParseExportNamedSpecifiers(t);
      a && c && !E && !ue && this.unexpected(null, 5), M && Y && this.unexpected(null, 98);
      let Ee;
      if (se || ue) {
        if (Ee = !1, e)
          throw this.raise(y.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, se);
      } else
        Ee = this.maybeParseExportDeclaration(t);
      if (se || ue || Ee) {
        var _e;
        const ke = t;
        if (this.checkExport(ke, !0, !1, !!ke.source), ((_e = ke.declaration) == null ? void 0 : _e.type) === "ClassDeclaration")
          this.maybeTakeDecorators(e, ke.declaration, ke);
        else if (e)
          throw this.raise(y.UnsupportedDecoratorExport, t);
        return this.finishNode(ke, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const ke = t, Re = this.parseExportDefaultExpression();
        if (ke.declaration = Re, Re.type === "ClassDeclaration")
          this.maybeTakeDecorators(e, Re, ke);
        else if (e)
          throw this.raise(y.UnsupportedDecoratorExport, t);
        return this.checkExport(ke, !0, !0), this.finishNode(ke, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, e) {
      if (e || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", e == null ? void 0 : e.loc.start);
        const r = e || this.parseIdentifier(!0), a = this.startNodeAtNode(r);
        return a.exported = r, t.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        var e, r;
        (r = (e = t).specifiers) != null || (e.specifiers = []);
        const a = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), a.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(a, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        const e = t;
        e.specifiers || (e.specifiers = []);
        const r = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(r)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      const t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      const t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(y.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(y.UnsupportedDefaultExport, this.state.startLoc);
      const e = this.parseMaybeAssignAllowIn();
      return this.semicolon(), e;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type: t
      } = this.state;
      if (fe(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          const {
            type: a
          } = this.lookahead();
          if (fe(a) && a !== 98 || a === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      const e = this.nextTokenStart(), r = this.isUnparsedContextual(e, "from");
      if (this.input.charCodeAt(e) === 44 || fe(this.state.type) && r)
        return !0;
      if (this.match(65) && r) {
        const a = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
        return a === 34 || a === 39;
      }
      return !1;
    }
    parseExportFrom(t, e) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : e && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(y.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(y.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(y.UsingDeclarationExport, this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, e, r, a) {
      if (e) {
        var c;
        if (r) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var E;
            const M = t.declaration;
            M.type === "Identifier" && M.name === "from" && M.end - M.start === 4 && !((E = M.extra) != null && E.parenthesized) && this.raise(y.ExportDefaultFromAsIdentifier, M);
          }
        } else if ((c = t.specifiers) != null && c.length)
          for (const M of t.specifiers) {
            const {
              exported: Y
            } = M, se = Y.type === "Identifier" ? Y.name : Y.value;
            if (this.checkDuplicateExports(M, se), !a && M.local) {
              const {
                local: ue
              } = M;
              ue.type !== "Identifier" ? this.raise(y.ExportBindingIsString, M, {
                localName: ue.value,
                exportName: se
              }) : (this.checkReservedWord(ue.name, ue.loc.start, !0, !1), this.scope.checkLocalExport(ue));
            }
          }
        else if (t.declaration) {
          const M = t.declaration;
          if (M.type === "FunctionDeclaration" || M.type === "ClassDeclaration") {
            const {
              id: Y
            } = M;
            if (!Y) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, Y.name);
          } else if (M.type === "VariableDeclaration")
            for (const Y of M.declarations)
              this.checkDeclaration(Y.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (const e of t.properties)
          this.checkDeclaration(e);
      else if (t.type === "ArrayPattern")
        for (const e of t.elements)
          e && this.checkDeclaration(e);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, e) {
      this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(y.DuplicateDefaultExport, t) : this.raise(y.DuplicateExport, t, {
        exportName: e
      })), this.exportedIdentifiers.add(e);
    }
    parseExportSpecifiers(t) {
      const e = [];
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else if (this.expect(12), this.eat(8)) break;
        const a = this.isContextual(130), c = this.match(134), E = this.startNode();
        E.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(E, c, t, a));
      }
      return e;
    }
    parseExportSpecifier(t, e, r, a) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = di(t.local) : t.exported || (t.exported = wt(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        const t = this.parseStringLiteral(this.state.value), e = qi.exec(t.value);
        return e && this.raise(y.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: e[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: e,
        value: r
      }) => r.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type")) : !1;
    }
    checkImportReflection(t) {
      const {
        specifiers: e
      } = t, r = e.length === 1 ? e[0].type : null;
      if (t.phase === "source")
        r !== "ImportDefaultSpecifier" && this.raise(y.SourcePhaseImportRequiresDefault, e[0].loc.start);
      else if (t.phase === "defer")
        r !== "ImportNamespaceSpecifier" && this.raise(y.DeferImportRequiresNamespace, e[0].loc.start);
      else if (t.module) {
        var a;
        r !== "ImportDefaultSpecifier" && this.raise(y.ImportReflectionNotBinding, e[0].loc.start), ((a = t.assertions) == null ? void 0 : a.length) > 0 && this.raise(y.ImportReflectionHasAssertion, e[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        const {
          specifiers: e
        } = t;
        if (e != null) {
          const r = e.find((a) => {
            let c;
            if (a.type === "ExportSpecifier" ? c = a.local : a.type === "ImportSpecifier" && (c = a.imported), c !== void 0)
              return c.type === "Identifier" ? c.name !== "default" : c.value !== "default";
          });
          r !== void 0 && this.raise(y.ImportJSONBindingNotDefault, r.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, e, r, a) {
      e || (r === "module" ? (this.expectPlugin("importReflection", a), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1), r === "source" ? (this.expectPlugin("sourcePhaseImports", a), t.phase = "source") : r === "defer" ? (this.expectPlugin("deferredImportEvaluation", a), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, e) {
      if (!this.isPotentialImportPhase(e))
        return this.applyImportPhase(t, e, null), null;
      const r = this.parseIdentifier(!0), {
        type: a
      } = this.state;
      return (de(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12) ? (this.resetPreviousIdentifierLeadingComments(r), this.applyImportPhase(t, e, r.name, r.loc.start), null) : (this.applyImportPhase(t, e, null), r);
    }
    isPrecedingIdImportPhase(t) {
      const {
        type: e
      } = this.state;
      return fe(e) ? e !== 98 || this.lookaheadCharCode() === 102 : e !== 12;
    }
    parseImport(t) {
      return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, e) {
      t.specifiers = [];
      const a = !this.maybeParseDefaultImportSpecifier(t, e) || this.eat(12), c = a && this.maybeParseStarImportSpecifier(t);
      return a && !c && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var e;
      return (e = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, e, r) {
      e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, r));
    }
    finishImportSpecifier(t, e, r = 8201) {
      return this.checkLVal(t.local, {
        type: e
      }, r), this.finishNode(t, e);
    }
    parseImportAttributes() {
      this.expect(5);
      const t = [], e = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const r = this.startNode(), a = this.state.value;
        if (e.has(a) && this.raise(y.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: a
        }), e.add(a), this.match(134) ? r.key = this.parseStringLiteral(a) : r.key = this.parseIdentifier(!0), this.expect(14), !this.match(134))
          throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
        r.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(r, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      const t = [], e = /* @__PURE__ */ new Set();
      do {
        const r = this.startNode();
        if (r.key = this.parseIdentifier(!0), r.key.name !== "type" && this.raise(y.ModuleAttributeDifferentFromType, r.key), e.has(r.key.name) && this.raise(y.ModuleAttributesWithDuplicateKeys, r.key, {
          key: r.key.name
        }), e.add(r.key.name), this.expect(14), !this.match(134))
          throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
        r.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(r, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let e;
      var r = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? e = this.parseModuleAttributes() : e = this.parseImportAttributes(), r = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(y.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(t, "deprecatedAssertSyntax", !0), this.next(), e = this.parseImportAttributes()) : e = [];
      !r && this.hasPlugin("importAssertions") ? t.assertions = e : t.attributes = e;
    }
    maybeParseDefaultImportSpecifier(t, e) {
      if (e) {
        const r = this.startNodeAtNode(e);
        return r.local = e, t.specifiers.push(this.finishImportSpecifier(r, "ImportDefaultSpecifier")), !0;
      } else if (de(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        const e = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let e = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (e)
          e = !1;
        else {
          if (this.eat(14))
            throw this.raise(y.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const r = this.startNode(), a = this.match(134), c = this.isContextual(130);
        r.imported = this.parseModuleExportName();
        const E = this.parseImportSpecifier(r, a, t.importKind === "type" || t.importKind === "typeof", c, void 0);
        t.specifiers.push(E);
      }
    }
    parseImportSpecifier(t, e, r, a, c) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        const {
          imported: E
        } = t;
        if (e)
          throw this.raise(y.ImportBindingIsString, t, {
            importName: E.value
          });
        this.checkReservedWord(E.name, t.loc.start, !0, !0), t.local || (t.local = wt(E));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", c);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }
  class Wr extends Vi {
    constructor(t, e, r) {
      t = Z(t), super(t, e), this.options = t, this.initializeScopes(), this.plugins = r, this.filename = t.sourceFilename, this.startIndex = t.startIndex;
      let a = 0;
      t.allowAwaitOutsideFunction && (a |= 1), t.allowReturnOutsideFunction && (a |= 2), t.allowImportExportEverywhere && (a |= 8), t.allowSuperOutsideMethod && (a |= 16), t.allowUndeclaredExports && (a |= 32), t.allowNewTargetOutsideFunction && (a |= 4), t.ranges && (a |= 64), t.tokens && (a |= 128), t.createImportExpressions && (a |= 256), t.createParenthesizedExpressions && (a |= 512), t.errorRecovery && (a |= 1024), t.attachComment && (a |= 2048), t.annexB && (a |= 4096), this.optionFlags = a;
    }
    getScopeHandler() {
      return Jt;
    }
    parse() {
      this.enterInitialScopes();
      const t = this.startNode(), e = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, e), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
    }
  }
  function Ki(b, t) {
    var e;
    if (((e = t) == null ? void 0 : e.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        const r = Qt(t, b), a = r.parse();
        if (r.sawUnambiguousESM)
          return a;
        if (r.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Qt(t, b).parse();
          } catch {
          }
        else
          a.program.sourceType = "script";
        return a;
      } catch (r) {
        try {
          return t.sourceType = "script", Qt(t, b).parse();
        } catch {
        }
        throw r;
      }
    } else
      return Qt(t, b).parse();
  }
  function Wi(b, t) {
    const e = Qt(t, b);
    return e.options.strictMode && (e.state.strict = !0), e.getExpression();
  }
  function $i(b) {
    const t = {};
    for (const e of Object.keys(b))
      t[e] = le(b[e]);
    return t;
  }
  const Ji = $i(Le);
  function Qt(b, t) {
    let e = Wr;
    const r = /* @__PURE__ */ new Map();
    if (b != null && b.plugins) {
      for (const a of b.plugins) {
        let c, E;
        typeof a == "string" ? c = a : [c, E] = a, r.has(c) || r.set(c, E || {});
      }
      Bi(r), e = Xi(r);
    }
    return new e(b, t, r);
  }
  const $r = /* @__PURE__ */ new Map();
  function Xi(b) {
    const t = [];
    for (const a of Fi)
      b.has(a) && t.push(a);
    const e = t.join("|");
    let r = $r.get(e);
    if (!r) {
      r = Wr;
      for (const a of t)
        r = Kr[a](r);
      $r.set(e, r);
    }
    return r;
  }
  return tn.parse = Ki, tn.parseExpression = Wi, tn.tokTypes = Ji, tn;
}
var ef = il(), Ko = {}, dt = {}, Fs = {}, os = {}, er = {}, rt = {}, ml;
function Ep() {
  return ml || (ml = 1, Object.defineProperty(rt, "__esModule", {
    value: !0
  }), rt.Var = rt.User = rt.Statement = rt.SpreadProperty = rt.Scope = rt.RestProperty = rt.ReferencedMemberExpression = rt.ReferencedIdentifier = rt.Referenced = rt.Pure = rt.NumericLiteralTypeAnnotation = rt.Generated = rt.ForAwaitStatement = rt.Flow = rt.Expression = rt.ExistentialTypeParam = rt.BlockScoped = rt.BindingIdentifier = void 0, rt.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], rt.ReferencedMemberExpression = ["MemberExpression"], rt.BindingIdentifier = ["Identifier"], rt.Statement = ["Statement"], rt.Expression = ["Expression"], rt.Scope = ["Scopable", "Pattern"], rt.Referenced = null, rt.BlockScoped = null, rt.Var = ["VariableDeclaration"], rt.User = null, rt.Generated = null, rt.Pure = null, rt.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], rt.RestProperty = ["RestElement"], rt.SpreadProperty = ["RestElement"], rt.ExistentialTypeParam = ["ExistsTypeAnnotation"], rt.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], rt.ForAwaitStatement = ["ForOfStatement"]), rt;
}
var Rs = { exports: {} }, Wo, yl;
function tf() {
  if (yl) return Wo;
  yl = 1;
  var i = 1e3, l = i * 60, u = l * 60, o = u * 24, f = o * 7, p = o * 365.25;
  Wo = function(g, I) {
    I = I || {};
    var v = typeof g;
    if (v === "string" && g.length > 0)
      return P(g);
    if (v === "number" && isFinite(g))
      return I.long ? x(g) : w(g);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(g)
    );
  };
  function P(g) {
    if (g = String(g), !(g.length > 100)) {
      var I = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        g
      );
      if (I) {
        var v = parseFloat(I[1]), S = (I[2] || "ms").toLowerCase();
        switch (S) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return v * p;
          case "weeks":
          case "week":
          case "w":
            return v * f;
          case "days":
          case "day":
          case "d":
            return v * o;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return v * u;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return v * l;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return v * i;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return v;
          default:
            return;
        }
      }
    }
  }
  function w(g) {
    var I = Math.abs(g);
    return I >= o ? Math.round(g / o) + "d" : I >= u ? Math.round(g / u) + "h" : I >= l ? Math.round(g / l) + "m" : I >= i ? Math.round(g / i) + "s" : g + "ms";
  }
  function x(g) {
    var I = Math.abs(g);
    return I >= o ? A(g, I, o, "day") : I >= u ? A(g, I, u, "hour") : I >= l ? A(g, I, l, "minute") : I >= i ? A(g, I, i, "second") : g + " ms";
  }
  function A(g, I, v, S) {
    var _ = I >= v * 1.5;
    return Math.round(g / v) + " " + S + (_ ? "s" : "");
  }
  return Wo;
}
var $o, Tl;
function rf() {
  if (Tl) return $o;
  Tl = 1;
  function i(l) {
    o.debug = o, o.default = o, o.coerce = A, o.disable = w, o.enable = p, o.enabled = x, o.humanize = tf(), o.destroy = g, Object.keys(l).forEach((I) => {
      o[I] = l[I];
    }), o.names = [], o.skips = [], o.formatters = {};
    function u(I) {
      let v = 0;
      for (let S = 0; S < I.length; S++)
        v = (v << 5) - v + I.charCodeAt(S), v |= 0;
      return o.colors[Math.abs(v) % o.colors.length];
    }
    o.selectColor = u;
    function o(I) {
      let v, S = null, _, B;
      function y(...X) {
        if (!y.enabled)
          return;
        const Z = y, J = Number(/* @__PURE__ */ new Date()), G = J - (v || J);
        Z.diff = G, Z.prev = v, Z.curr = J, v = J, X[0] = o.coerce(X[0]), typeof X[0] != "string" && X.unshift("%O");
        let O = 0;
        X[0] = X[0].replace(/%([a-zA-Z%])/g, (L, q) => {
          if (L === "%%")
            return "%";
          O++;
          const H = o.formatters[q];
          if (typeof H == "function") {
            const N = X[O];
            L = H.call(Z, N), X.splice(O, 1), O--;
          }
          return L;
        }), o.formatArgs.call(Z, X), (Z.log || o.log).apply(Z, X);
      }
      return y.namespace = I, y.useColors = o.useColors(), y.color = o.selectColor(I), y.extend = f, y.destroy = o.destroy, Object.defineProperty(y, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => S !== null ? S : (_ !== o.namespaces && (_ = o.namespaces, B = o.enabled(I)), B),
        set: (X) => {
          S = X;
        }
      }), typeof o.init == "function" && o.init(y), y;
    }
    function f(I, v) {
      const S = o(this.namespace + (typeof v > "u" ? ":" : v) + I);
      return S.log = this.log, S;
    }
    function p(I) {
      o.save(I), o.namespaces = I, o.names = [], o.skips = [];
      const v = (typeof I == "string" ? I : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const S of v)
        S[0] === "-" ? o.skips.push(S.slice(1)) : o.names.push(S);
    }
    function P(I, v) {
      let S = 0, _ = 0, B = -1, y = 0;
      for (; S < I.length; )
        if (_ < v.length && (v[_] === I[S] || v[_] === "*"))
          v[_] === "*" ? (B = _, y = S, _++) : (S++, _++);
        else if (B !== -1)
          _ = B + 1, y++, S = y;
        else
          return !1;
      for (; _ < v.length && v[_] === "*"; )
        _++;
      return _ === v.length;
    }
    function w() {
      const I = [
        ...o.names,
        ...o.skips.map((v) => "-" + v)
      ].join(",");
      return o.enable(""), I;
    }
    function x(I) {
      for (const v of o.skips)
        if (P(I, v))
          return !1;
      for (const v of o.names)
        if (P(I, v))
          return !0;
      return !1;
    }
    function A(I) {
      return I instanceof Error ? I.stack || I.message : I;
    }
    function g() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return o.enable(o.load()), o;
  }
  return $o = i, $o;
}
var Sl;
function nf() {
  return Sl || (Sl = 1, function(i, l) {
    l.formatArgs = o, l.save = f, l.load = p, l.useColors = u, l.storage = P(), l.destroy = /* @__PURE__ */ (() => {
      let x = !1;
      return () => {
        x || (x = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), l.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function u() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let x;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (x = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(x[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function o(x) {
      if (x[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + x[0] + (this.useColors ? "%c " : " ") + "+" + i.exports.humanize(this.diff), !this.useColors)
        return;
      const A = "color: " + this.color;
      x.splice(1, 0, A, "color: inherit");
      let g = 0, I = 0;
      x[0].replace(/%[a-zA-Z%]/g, (v) => {
        v !== "%%" && (g++, v === "%c" && (I = g));
      }), x.splice(I, 0, A);
    }
    l.log = console.debug || console.log || (() => {
    });
    function f(x) {
      try {
        x ? l.storage.setItem("debug", x) : l.storage.removeItem("debug");
      } catch {
      }
    }
    function p() {
      let x;
      try {
        x = l.storage.getItem("debug");
      } catch {
      }
      return !x && typeof process < "u" && "env" in process && (x = process.env.DEBUG), x;
    }
    function P() {
      try {
        return localStorage;
      } catch {
      }
    }
    i.exports = rf()(l);
    const { formatters: w } = i.exports;
    w.j = function(x) {
      try {
        return JSON.stringify(x);
      } catch (A) {
        return "[UnexpectedJSONParseError]: " + A.message;
      }
    };
  }(Rs, Rs.exports)), Rs.exports;
}
var ls = {}, us = {}, Jo = {}, cs = {}, js = {}, qs = {}, W = {}, Us = {}, gl;
function nl() {
  if (gl) return Us;
  gl = 1, Object.defineProperty(Us, "__esModule", {
    value: !0
  }), Us.default = i;
  function i(l, u) {
    const o = Object.keys(u);
    for (const f of o)
      if (l[f] !== u[f])
        return !1;
    return !0;
  }
  return Us;
}
var Vs = {}, bl;
function eo() {
  if (bl) return Vs;
  bl = 1, Object.defineProperty(Vs, "__esModule", {
    value: !0
  }), Vs.default = l;
  const i = /* @__PURE__ */ new Set();
  function l(o, f, p = "") {
    if (i.has(o)) return;
    i.add(o);
    const {
      internal: P,
      trace: w
    } = u(1, 2);
    P || console.warn(`${p}\`${o}\` has been deprecated, please migrate to \`${f}\`
${w}`);
  }
  function u(o, f) {
    const {
      stackTraceLimit: p,
      prepareStackTrace: P
    } = Error;
    let w;
    if (Error.stackTraceLimit = 1 + o + f, Error.prepareStackTrace = function(A, g) {
      w = g;
    }, new Error().stack, Error.stackTraceLimit = p, Error.prepareStackTrace = P, !w) return {
      internal: !1,
      trace: ""
    };
    const x = w.slice(1 + o, 1 + o + f);
    return {
      internal: /[\\/]@babel[\\/]/.test(x[1].getFileName()),
      trace: x.map((A) => `    at ${A}`).join(`
`)
    };
  }
  return Vs;
}
var El;
function bt() {
  if (El) return W;
  El = 1, Object.defineProperty(W, "__esModule", {
    value: !0
  }), W.isAccessor = xo, W.isAnyTypeAnnotation = Hr, W.isArgumentPlaceholder = Ri, W.isArrayExpression = u, W.isArrayPattern = at, W.isArrayTypeAnnotation = Cr, W.isArrowFunctionExpression = it, W.isAssignmentExpression = o, W.isAssignmentPattern = Ge, W.isAwaitExpression = Ke, W.isBigIntLiteral = Lt, W.isBinary = rs, W.isBinaryExpression = f, W.isBindExpression = Sr, W.isBlock = ss, W.isBlockParent = ns, W.isBlockStatement = x, W.isBooleanLiteral = re, W.isBooleanLiteralTypeAnnotation = Gt, W.isBooleanTypeAnnotation = Gr, W.isBreakStatement = A, W.isCallExpression = g, W.isCatchClause = I, W.isClass = bo, W.isClassAccessorProperty = Wt, W.isClassBody = ft, W.isClassDeclaration = Tt, W.isClassExpression = Xe, W.isClassImplements = zr, W.isClassMethod = Ce, W.isClassPrivateMethod = Jt, W.isClassPrivateProperty = $t, W.isClassProperty = xt, W.isCompletionStatement = d, W.isConditional = T, W.isConditionalExpression = v, W.isContinueStatement = S, W.isDebuggerStatement = _, W.isDecimalLiteral = Ki, W.isDeclaration = oo, W.isDeclareClass = Qr, W.isDeclareExportAllDeclaration = wr, W.isDeclareExportDeclaration = ei, W.isDeclareFunction = ir, W.isDeclareInterface = Xt, W.isDeclareModule = Ir, W.isDeclareModuleExports = hr, W.isDeclareOpaqueType = Zr, W.isDeclareTypeAlias = dr, W.isDeclareVariable = mr, W.isDeclaredPredicate = nr, W.isDecorator = qi, W.isDirective = P, W.isDirectiveLiteral = w, W.isDoExpression = gr, W.isDoWhileStatement = B, W.isEmptyStatement = y, W.isEmptyTypeAnnotation = si, W.isEnumBody = No, W.isEnumBooleanBody = Bt, W.isEnumBooleanMember = vi, W.isEnumDeclaration = Pi, W.isEnumDefaultedMember = Ci, W.isEnumMember = _o, W.isEnumNumberBody = Dt, W.isEnumNumberMember = Ai, W.isEnumStringBody = Yt, W.isEnumStringMember = Mr, W.isEnumSymbolBody = xi, W.isExistsTypeAnnotation = Or, W.isExportAllDeclaration = be, W.isExportDeclaration = Eo, W.isExportDefaultDeclaration = ve, W.isExportDefaultSpecifier = Ui, W.isExportNamedDeclaration = j, W.isExportNamespaceSpecifier = Kt, W.isExportSpecifier = D, W.isExpression = ts, W.isExpressionStatement = X, W.isExpressionWrapper = Se, W.isFile = Z, W.isFlow = Ao, W.isFlowBaseAnnotation = Io, W.isFlowDeclaration = wo, W.isFlowPredicate = Oo, W.isFlowType = Co, W.isFor = je, W.isForInStatement = J, W.isForOfStatement = V, W.isForStatement = G, W.isForXStatement = pt, W.isFunction = St, W.isFunctionDeclaration = O, W.isFunctionExpression = ee, W.isFunctionParent = Ht, W.isFunctionTypeAnnotation = ti, W.isFunctionTypeParam = ri, W.isGenericTypeAnnotation = yr, W.isIdentifier = L, W.isIfStatement = q, W.isImmutable = fo, W.isImport = ct, W.isImportAttribute = ji, W.isImportDeclaration = le, W.isImportDefaultSpecifier = me, W.isImportExpression = De, W.isImportNamespaceSpecifier = ge, W.isImportOrExportDeclaration = Bs, W.isImportSpecifier = xe, W.isIndexedAccessType = Ii, W.isInferredPredicate = Nr, W.isInterfaceDeclaration = zt, W.isInterfaceExtends = _r, W.isInterfaceTypeAnnotation = ii, W.isInterpreterDirective = p, W.isIntersectionTypeAnnotation = _t, W.isJSX = Do, W.isJSXAttribute = Fe, W.isJSXClosingElement = wi, W.isJSXClosingFragment = Vr, W.isJSXElement = Fr, W.isJSXEmptyExpression = Oi, W.isJSXExpressionContainer = Ni, W.isJSXFragment = Mi, W.isJSXIdentifier = Di, W.isJSXMemberExpression = Rr, W.isJSXNamespacedName = ki, W.isJSXOpeningElement = jr, W.isJSXOpeningFragment = Ur, W.isJSXSpreadAttribute = qr, W.isJSXSpreadChild = _i, W.isJSXText = Li, W.isLVal = uo, W.isLabeledStatement = H, W.isLiteral = po, W.isLogicalExpression = pe, W.isLoop = k, W.isMemberExpression = ne, W.isMetaProperty = We, W.isMethod = mo, W.isMiscellaneous = ko, W.isMixedTypeAnnotation = ni, W.isModuleDeclaration = Vo, W.isModuleExpression = Wi, W.isModuleSpecifier = Po, W.isNewExpression = R, W.isNoop = Bi, W.isNullLiteral = ie, W.isNullLiteralTypeAnnotation = Mt, W.isNullableTypeAnnotation = ai, W.isNumberLiteral = Ro, W.isNumberLiteralTypeAnnotation = sr, W.isNumberTypeAnnotation = Dr, W.isNumericLiteral = F, W.isObjectExpression = z, W.isObjectMember = yo, W.isObjectMethod = ae, W.isObjectPattern = Ye, W.isObjectProperty = ce, W.isObjectTypeAnnotation = oi, W.isObjectTypeCallProperty = ui, W.isObjectTypeIndexer = ci, W.isObjectTypeInternalSlot = li, W.isObjectTypeProperty = kr, W.isObjectTypeSpreadProperty = pi, W.isOpaqueType = ar, W.isOptionalCallExpression = At, W.isOptionalIndexedAccessType = Br, W.isOptionalMemberExpression = Nt, W.isParenthesizedExpression = Ne, W.isPattern = go, W.isPatternLike = lo, W.isPipelineBareFunction = Qt, W.isPipelinePrimaryTopicReference = $r, W.isPipelineTopicExpression = Ji, W.isPlaceholder = Kr, W.isPrivate = vo, W.isPrivateName = rr, W.isProgram = C, W.isProperty = To, W.isPureish = ao, W.isQualifiedTypeIdentifier = fi, W.isRecordExpression = Vi, W.isRegExpLiteral = Q, W.isRegexLiteral = jo, W.isRestElement = ye, W.isRestProperty = qo, W.isReturnStatement = he, W.isScopable = is, W.isSequenceExpression = Pe, W.isSpreadElement = $e, W.isSpreadProperty = Uo, W.isStandardized = es, W.isStatement = as, W.isStaticBlock = Yr, W.isStringLiteral = N, W.isStringLiteralTypeAnnotation = or, W.isStringTypeAnnotation = lr, W.isSuper = et, W.isSwitchCase = we, W.isSwitchStatement = Ie, W.isSymbolTypeAnnotation = Tr, W.isTSAnyKeyword = Y, W.isTSArrayType = yn, W.isTSAsExpression = Bn, W.isTSBaseType = Fo, W.isTSBigIntKeyword = ue, W.isTSBooleanKeyword = se, W.isTSCallSignatureDeclaration = r, W.isTSConditionalType = xn, W.isTSConstructSignatureDeclaration = a, W.isTSConstructorType = pn, W.isTSDeclareFunction = b, W.isTSDeclareMethod = t, W.isTSEntityName = co, W.isTSEnumBody = jn, W.isTSEnumDeclaration = qn, W.isTSEnumMember = Un, W.isTSExportAssignment = Yn, W.isTSExpressionWithTypeArguments = _n, W.isTSExternalModuleReference = Jn, W.isTSFunctionType = cn, W.isTSImportEqualsDeclaration = $n, W.isTSImportType = Wn, W.isTSIndexSignature = M, W.isTSIndexedAccessType = In, W.isTSInferType = vn, W.isTSInstantiationExpression = Mn, W.isTSInterfaceBody = kn, W.isTSInterfaceDeclaration = Dn, W.isTSIntersectionType = Pn, W.isTSIntrinsicKeyword = Ee, W.isTSLiteralType = Nn, W.isTSMappedType = wn, W.isTSMethodSignature = E, W.isTSModuleBlock = Kn, W.isTSModuleDeclaration = Vn, W.isTSNamedTupleMember = bn, W.isTSNamespaceExportDeclaration = Hn, W.isTSNeverKeyword = _e, W.isTSNonNullExpression = Xn, W.isTSNullKeyword = ke, W.isTSNumberKeyword = Re, W.isTSObjectKeyword = Qe, W.isTSOptionalType = Sn, W.isTSParameterProperty = Xi, W.isTSParenthesizedType = An, W.isTSPropertySignature = c, W.isTSQualifiedName = e, W.isTSRestType = gn, W.isTSSatisfiesExpression = Fn, W.isTSStringKeyword = mt, W.isTSSymbolKeyword = tt, W.isTSTemplateLiteralType = On, W.isTSThisType = un, W.isTSTupleType = Tn, W.isTSType = Bo, W.isTSTypeAliasDeclaration = Ln, W.isTSTypeAnnotation = Gn, W.isTSTypeAssertion = Rn, W.isTSTypeElement = Mo, W.isTSTypeLiteral = mn, W.isTSTypeOperator = Cn, W.isTSTypeParameter = Zn, W.isTSTypeParameterDeclaration = Qn, W.isTSTypeParameterInstantiation = zn, W.isTSTypePredicate = hn, W.isTSTypeQuery = dn, W.isTSTypeReference = fn, W.isTSUndefinedKeyword = ut, W.isTSUnionType = En, W.isTSUnknownKeyword = ur, W.isTSVoidKeyword = Zt, W.isTaggedTemplateExpression = oe, W.isTemplateElement = K, W.isTemplateLiteral = Ae, W.isTerminatorless = h, W.isThisExpression = Le, W.isThisTypeAnnotation = hi, W.isThrowStatement = fe, W.isTopicReference = $i, W.isTryStatement = Te, W.isTupleExpression = Wr, W.isTupleTypeAnnotation = wt, W.isTypeAlias = mi, W.isTypeAnnotation = yi, W.isTypeCastExpression = Ve, W.isTypeParameter = Ti, W.isTypeParameterDeclaration = Lr, W.isTypeParameterInstantiation = Si, W.isTypeScript = Lo, W.isTypeofTypeAnnotation = di, W.isUnaryExpression = de, W.isUnaryLike = So, W.isUnionTypeAnnotation = gi, W.isUpdateExpression = Ue, W.isUserWhitespacable = ho, W.isV8IntrinsicIdentifier = Fi, W.isVariableDeclaration = Je, W.isVariableDeclarator = He, W.isVariance = bi, W.isVoidTypeAnnotation = Ei, W.isWhile = te, W.isWhileStatement = st, W.isWithStatement = qe, W.isYieldExpression = Be;
  var i = nl(), l = eo();
  function u(s, n) {
    return !s || s.type !== "ArrayExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function o(s, n) {
    return !s || s.type !== "AssignmentExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function f(s, n) {
    return !s || s.type !== "BinaryExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function p(s, n) {
    return !s || s.type !== "InterpreterDirective" ? !1 : n == null || (0, i.default)(s, n);
  }
  function P(s, n) {
    return !s || s.type !== "Directive" ? !1 : n == null || (0, i.default)(s, n);
  }
  function w(s, n) {
    return !s || s.type !== "DirectiveLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function x(s, n) {
    return !s || s.type !== "BlockStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function A(s, n) {
    return !s || s.type !== "BreakStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function g(s, n) {
    return !s || s.type !== "CallExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function I(s, n) {
    return !s || s.type !== "CatchClause" ? !1 : n == null || (0, i.default)(s, n);
  }
  function v(s, n) {
    return !s || s.type !== "ConditionalExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function S(s, n) {
    return !s || s.type !== "ContinueStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _(s, n) {
    return !s || s.type !== "DebuggerStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function B(s, n) {
    return !s || s.type !== "DoWhileStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function y(s, n) {
    return !s || s.type !== "EmptyStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function X(s, n) {
    return !s || s.type !== "ExpressionStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Z(s, n) {
    return !s || s.type !== "File" ? !1 : n == null || (0, i.default)(s, n);
  }
  function J(s, n) {
    return !s || s.type !== "ForInStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function G(s, n) {
    return !s || s.type !== "ForStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function O(s, n) {
    return !s || s.type !== "FunctionDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ee(s, n) {
    return !s || s.type !== "FunctionExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function L(s, n) {
    return !s || s.type !== "Identifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function q(s, n) {
    return !s || s.type !== "IfStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function H(s, n) {
    return !s || s.type !== "LabeledStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function N(s, n) {
    return !s || s.type !== "StringLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function F(s, n) {
    return !s || s.type !== "NumericLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ie(s, n) {
    return !s || s.type !== "NullLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function re(s, n) {
    return !s || s.type !== "BooleanLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Q(s, n) {
    return !s || s.type !== "RegExpLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function pe(s, n) {
    return !s || s.type !== "LogicalExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ne(s, n) {
    return !s || s.type !== "MemberExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function R(s, n) {
    return !s || s.type !== "NewExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function C(s, n) {
    return !s || s.type !== "Program" ? !1 : n == null || (0, i.default)(s, n);
  }
  function z(s, n) {
    return !s || s.type !== "ObjectExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ae(s, n) {
    return !s || s.type !== "ObjectMethod" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ce(s, n) {
    return !s || s.type !== "ObjectProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ye(s, n) {
    return !s || s.type !== "RestElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function he(s, n) {
    return !s || s.type !== "ReturnStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Pe(s, n) {
    return !s || s.type !== "SequenceExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ne(s, n) {
    return !s || s.type !== "ParenthesizedExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function we(s, n) {
    return !s || s.type !== "SwitchCase" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ie(s, n) {
    return !s || s.type !== "SwitchStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Le(s, n) {
    return !s || s.type !== "ThisExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function fe(s, n) {
    return !s || s.type !== "ThrowStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Te(s, n) {
    return !s || s.type !== "TryStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function de(s, n) {
    return !s || s.type !== "UnaryExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ue(s, n) {
    return !s || s.type !== "UpdateExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Je(s, n) {
    return !s || s.type !== "VariableDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function He(s, n) {
    return !s || s.type !== "VariableDeclarator" ? !1 : n == null || (0, i.default)(s, n);
  }
  function st(s, n) {
    return !s || s.type !== "WhileStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function qe(s, n) {
    return !s || s.type !== "WithStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ge(s, n) {
    return !s || s.type !== "AssignmentPattern" ? !1 : n == null || (0, i.default)(s, n);
  }
  function at(s, n) {
    return !s || s.type !== "ArrayPattern" ? !1 : n == null || (0, i.default)(s, n);
  }
  function it(s, n) {
    return !s || s.type !== "ArrowFunctionExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ft(s, n) {
    return !s || s.type !== "ClassBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Xe(s, n) {
    return !s || s.type !== "ClassExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Tt(s, n) {
    return !s || s.type !== "ClassDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function be(s, n) {
    return !s || s.type !== "ExportAllDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ve(s, n) {
    return !s || s.type !== "ExportDefaultDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function j(s, n) {
    return !s || s.type !== "ExportNamedDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function D(s, n) {
    return !s || s.type !== "ExportSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function V(s, n) {
    return !s || s.type !== "ForOfStatement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function le(s, n) {
    return !s || s.type !== "ImportDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function me(s, n) {
    return !s || s.type !== "ImportDefaultSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ge(s, n) {
    return !s || s.type !== "ImportNamespaceSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function xe(s, n) {
    return !s || s.type !== "ImportSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function De(s, n) {
    return !s || s.type !== "ImportExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function We(s, n) {
    return !s || s.type !== "MetaProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ce(s, n) {
    return !s || s.type !== "ClassMethod" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ye(s, n) {
    return !s || s.type !== "ObjectPattern" ? !1 : n == null || (0, i.default)(s, n);
  }
  function $e(s, n) {
    return !s || s.type !== "SpreadElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function et(s, n) {
    return !s || s.type !== "Super" ? !1 : n == null || (0, i.default)(s, n);
  }
  function oe(s, n) {
    return !s || s.type !== "TaggedTemplateExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function K(s, n) {
    return !s || s.type !== "TemplateElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ae(s, n) {
    return !s || s.type !== "TemplateLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Be(s, n) {
    return !s || s.type !== "YieldExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ke(s, n) {
    return !s || s.type !== "AwaitExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ct(s, n) {
    return !s || s.type !== "Import" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Lt(s, n) {
    return !s || s.type !== "BigIntLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Kt(s, n) {
    return !s || s.type !== "ExportNamespaceSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Nt(s, n) {
    return !s || s.type !== "OptionalMemberExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function At(s, n) {
    return !s || s.type !== "OptionalCallExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function xt(s, n) {
    return !s || s.type !== "ClassProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Wt(s, n) {
    return !s || s.type !== "ClassAccessorProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function $t(s, n) {
    return !s || s.type !== "ClassPrivateProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Jt(s, n) {
    return !s || s.type !== "ClassPrivateMethod" ? !1 : n == null || (0, i.default)(s, n);
  }
  function rr(s, n) {
    return !s || s.type !== "PrivateName" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Yr(s, n) {
    return !s || s.type !== "StaticBlock" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Hr(s, n) {
    return !s || s.type !== "AnyTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Cr(s, n) {
    return !s || s.type !== "ArrayTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Gr(s, n) {
    return !s || s.type !== "BooleanTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Gt(s, n) {
    return !s || s.type !== "BooleanLiteralTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Mt(s, n) {
    return !s || s.type !== "NullLiteralTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function zr(s, n) {
    return !s || s.type !== "ClassImplements" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Qr(s, n) {
    return !s || s.type !== "DeclareClass" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ir(s, n) {
    return !s || s.type !== "DeclareFunction" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Xt(s, n) {
    return !s || s.type !== "DeclareInterface" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ir(s, n) {
    return !s || s.type !== "DeclareModule" ? !1 : n == null || (0, i.default)(s, n);
  }
  function hr(s, n) {
    return !s || s.type !== "DeclareModuleExports" ? !1 : n == null || (0, i.default)(s, n);
  }
  function dr(s, n) {
    return !s || s.type !== "DeclareTypeAlias" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Zr(s, n) {
    return !s || s.type !== "DeclareOpaqueType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function mr(s, n) {
    return !s || s.type !== "DeclareVariable" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ei(s, n) {
    return !s || s.type !== "DeclareExportDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function wr(s, n) {
    return !s || s.type !== "DeclareExportAllDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function nr(s, n) {
    return !s || s.type !== "DeclaredPredicate" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Or(s, n) {
    return !s || s.type !== "ExistsTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ti(s, n) {
    return !s || s.type !== "FunctionTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ri(s, n) {
    return !s || s.type !== "FunctionTypeParam" ? !1 : n == null || (0, i.default)(s, n);
  }
  function yr(s, n) {
    return !s || s.type !== "GenericTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Nr(s, n) {
    return !s || s.type !== "InferredPredicate" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _r(s, n) {
    return !s || s.type !== "InterfaceExtends" ? !1 : n == null || (0, i.default)(s, n);
  }
  function zt(s, n) {
    return !s || s.type !== "InterfaceDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ii(s, n) {
    return !s || s.type !== "InterfaceTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _t(s, n) {
    return !s || s.type !== "IntersectionTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ni(s, n) {
    return !s || s.type !== "MixedTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function si(s, n) {
    return !s || s.type !== "EmptyTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ai(s, n) {
    return !s || s.type !== "NullableTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function sr(s, n) {
    return !s || s.type !== "NumberLiteralTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Dr(s, n) {
    return !s || s.type !== "NumberTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function oi(s, n) {
    return !s || s.type !== "ObjectTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function li(s, n) {
    return !s || s.type !== "ObjectTypeInternalSlot" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ui(s, n) {
    return !s || s.type !== "ObjectTypeCallProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ci(s, n) {
    return !s || s.type !== "ObjectTypeIndexer" ? !1 : n == null || (0, i.default)(s, n);
  }
  function kr(s, n) {
    return !s || s.type !== "ObjectTypeProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function pi(s, n) {
    return !s || s.type !== "ObjectTypeSpreadProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ar(s, n) {
    return !s || s.type !== "OpaqueType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function fi(s, n) {
    return !s || s.type !== "QualifiedTypeIdentifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function or(s, n) {
    return !s || s.type !== "StringLiteralTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function lr(s, n) {
    return !s || s.type !== "StringTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Tr(s, n) {
    return !s || s.type !== "SymbolTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function hi(s, n) {
    return !s || s.type !== "ThisTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function wt(s, n) {
    return !s || s.type !== "TupleTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function di(s, n) {
    return !s || s.type !== "TypeofTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function mi(s, n) {
    return !s || s.type !== "TypeAlias" ? !1 : n == null || (0, i.default)(s, n);
  }
  function yi(s, n) {
    return !s || s.type !== "TypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ve(s, n) {
    return !s || s.type !== "TypeCastExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ti(s, n) {
    return !s || s.type !== "TypeParameter" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Lr(s, n) {
    return !s || s.type !== "TypeParameterDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Si(s, n) {
    return !s || s.type !== "TypeParameterInstantiation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function gi(s, n) {
    return !s || s.type !== "UnionTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function bi(s, n) {
    return !s || s.type !== "Variance" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ei(s, n) {
    return !s || s.type !== "VoidTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Pi(s, n) {
    return !s || s.type !== "EnumDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Bt(s, n) {
    return !s || s.type !== "EnumBooleanBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Dt(s, n) {
    return !s || s.type !== "EnumNumberBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Yt(s, n) {
    return !s || s.type !== "EnumStringBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function xi(s, n) {
    return !s || s.type !== "EnumSymbolBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function vi(s, n) {
    return !s || s.type !== "EnumBooleanMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ai(s, n) {
    return !s || s.type !== "EnumNumberMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Mr(s, n) {
    return !s || s.type !== "EnumStringMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ci(s, n) {
    return !s || s.type !== "EnumDefaultedMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ii(s, n) {
    return !s || s.type !== "IndexedAccessType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Br(s, n) {
    return !s || s.type !== "OptionalIndexedAccessType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Fe(s, n) {
    return !s || s.type !== "JSXAttribute" ? !1 : n == null || (0, i.default)(s, n);
  }
  function wi(s, n) {
    return !s || s.type !== "JSXClosingElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Fr(s, n) {
    return !s || s.type !== "JSXElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Oi(s, n) {
    return !s || s.type !== "JSXEmptyExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ni(s, n) {
    return !s || s.type !== "JSXExpressionContainer" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _i(s, n) {
    return !s || s.type !== "JSXSpreadChild" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Di(s, n) {
    return !s || s.type !== "JSXIdentifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Rr(s, n) {
    return !s || s.type !== "JSXMemberExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ki(s, n) {
    return !s || s.type !== "JSXNamespacedName" ? !1 : n == null || (0, i.default)(s, n);
  }
  function jr(s, n) {
    return !s || s.type !== "JSXOpeningElement" ? !1 : n == null || (0, i.default)(s, n);
  }
  function qr(s, n) {
    return !s || s.type !== "JSXSpreadAttribute" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Li(s, n) {
    return !s || s.type !== "JSXText" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Mi(s, n) {
    return !s || s.type !== "JSXFragment" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ur(s, n) {
    return !s || s.type !== "JSXOpeningFragment" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Vr(s, n) {
    return !s || s.type !== "JSXClosingFragment" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Bi(s, n) {
    return !s || s.type !== "Noop" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Kr(s, n) {
    return !s || s.type !== "Placeholder" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Fi(s, n) {
    return !s || s.type !== "V8IntrinsicIdentifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ri(s, n) {
    return !s || s.type !== "ArgumentPlaceholder" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Sr(s, n) {
    return !s || s.type !== "BindExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ji(s, n) {
    return !s || s.type !== "ImportAttribute" ? !1 : n == null || (0, i.default)(s, n);
  }
  function qi(s, n) {
    return !s || s.type !== "Decorator" ? !1 : n == null || (0, i.default)(s, n);
  }
  function gr(s, n) {
    return !s || s.type !== "DoExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ui(s, n) {
    return !s || s.type !== "ExportDefaultSpecifier" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Vi(s, n) {
    return !s || s.type !== "RecordExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Wr(s, n) {
    return !s || s.type !== "TupleExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ki(s, n) {
    return !s || s.type !== "DecimalLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Wi(s, n) {
    return !s || s.type !== "ModuleExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function $i(s, n) {
    return !s || s.type !== "TopicReference" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ji(s, n) {
    return !s || s.type !== "PipelineTopicExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Qt(s, n) {
    return !s || s.type !== "PipelineBareFunction" ? !1 : n == null || (0, i.default)(s, n);
  }
  function $r(s, n) {
    return !s || s.type !== "PipelinePrimaryTopicReference" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Xi(s, n) {
    return !s || s.type !== "TSParameterProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function b(s, n) {
    return !s || s.type !== "TSDeclareFunction" ? !1 : n == null || (0, i.default)(s, n);
  }
  function t(s, n) {
    return !s || s.type !== "TSDeclareMethod" ? !1 : n == null || (0, i.default)(s, n);
  }
  function e(s, n) {
    return !s || s.type !== "TSQualifiedName" ? !1 : n == null || (0, i.default)(s, n);
  }
  function r(s, n) {
    return !s || s.type !== "TSCallSignatureDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function a(s, n) {
    return !s || s.type !== "TSConstructSignatureDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function c(s, n) {
    return !s || s.type !== "TSPropertySignature" ? !1 : n == null || (0, i.default)(s, n);
  }
  function E(s, n) {
    return !s || s.type !== "TSMethodSignature" ? !1 : n == null || (0, i.default)(s, n);
  }
  function M(s, n) {
    return !s || s.type !== "TSIndexSignature" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Y(s, n) {
    return !s || s.type !== "TSAnyKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function se(s, n) {
    return !s || s.type !== "TSBooleanKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ue(s, n) {
    return !s || s.type !== "TSBigIntKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ee(s, n) {
    return !s || s.type !== "TSIntrinsicKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _e(s, n) {
    return !s || s.type !== "TSNeverKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ke(s, n) {
    return !s || s.type !== "TSNullKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Re(s, n) {
    return !s || s.type !== "TSNumberKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Qe(s, n) {
    return !s || s.type !== "TSObjectKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function mt(s, n) {
    return !s || s.type !== "TSStringKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function tt(s, n) {
    return !s || s.type !== "TSSymbolKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ut(s, n) {
    return !s || s.type !== "TSUndefinedKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function ur(s, n) {
    return !s || s.type !== "TSUnknownKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Zt(s, n) {
    return !s || s.type !== "TSVoidKeyword" ? !1 : n == null || (0, i.default)(s, n);
  }
  function un(s, n) {
    return !s || s.type !== "TSThisType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function cn(s, n) {
    return !s || s.type !== "TSFunctionType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function pn(s, n) {
    return !s || s.type !== "TSConstructorType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function fn(s, n) {
    return !s || s.type !== "TSTypeReference" ? !1 : n == null || (0, i.default)(s, n);
  }
  function hn(s, n) {
    return !s || s.type !== "TSTypePredicate" ? !1 : n == null || (0, i.default)(s, n);
  }
  function dn(s, n) {
    return !s || s.type !== "TSTypeQuery" ? !1 : n == null || (0, i.default)(s, n);
  }
  function mn(s, n) {
    return !s || s.type !== "TSTypeLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function yn(s, n) {
    return !s || s.type !== "TSArrayType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Tn(s, n) {
    return !s || s.type !== "TSTupleType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Sn(s, n) {
    return !s || s.type !== "TSOptionalType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function gn(s, n) {
    return !s || s.type !== "TSRestType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function bn(s, n) {
    return !s || s.type !== "TSNamedTupleMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function En(s, n) {
    return !s || s.type !== "TSUnionType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Pn(s, n) {
    return !s || s.type !== "TSIntersectionType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function xn(s, n) {
    return !s || s.type !== "TSConditionalType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function vn(s, n) {
    return !s || s.type !== "TSInferType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function An(s, n) {
    return !s || s.type !== "TSParenthesizedType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Cn(s, n) {
    return !s || s.type !== "TSTypeOperator" ? !1 : n == null || (0, i.default)(s, n);
  }
  function In(s, n) {
    return !s || s.type !== "TSIndexedAccessType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function wn(s, n) {
    return !s || s.type !== "TSMappedType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function On(s, n) {
    return !s || s.type !== "TSTemplateLiteralType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Nn(s, n) {
    return !s || s.type !== "TSLiteralType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function _n(s, n) {
    return !s || s.type !== "TSExpressionWithTypeArguments" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Dn(s, n) {
    return !s || s.type !== "TSInterfaceDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function kn(s, n) {
    return !s || s.type !== "TSInterfaceBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Ln(s, n) {
    return !s || s.type !== "TSTypeAliasDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Mn(s, n) {
    return !s || s.type !== "TSInstantiationExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Bn(s, n) {
    return !s || s.type !== "TSAsExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Fn(s, n) {
    return !s || s.type !== "TSSatisfiesExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Rn(s, n) {
    return !s || s.type !== "TSTypeAssertion" ? !1 : n == null || (0, i.default)(s, n);
  }
  function jn(s, n) {
    return !s || s.type !== "TSEnumBody" ? !1 : n == null || (0, i.default)(s, n);
  }
  function qn(s, n) {
    return !s || s.type !== "TSEnumDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Un(s, n) {
    return !s || s.type !== "TSEnumMember" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Vn(s, n) {
    return !s || s.type !== "TSModuleDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Kn(s, n) {
    return !s || s.type !== "TSModuleBlock" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Wn(s, n) {
    return !s || s.type !== "TSImportType" ? !1 : n == null || (0, i.default)(s, n);
  }
  function $n(s, n) {
    return !s || s.type !== "TSImportEqualsDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Jn(s, n) {
    return !s || s.type !== "TSExternalModuleReference" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Xn(s, n) {
    return !s || s.type !== "TSNonNullExpression" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Yn(s, n) {
    return !s || s.type !== "TSExportAssignment" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Hn(s, n) {
    return !s || s.type !== "TSNamespaceExportDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Gn(s, n) {
    return !s || s.type !== "TSTypeAnnotation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function zn(s, n) {
    return !s || s.type !== "TSTypeParameterInstantiation" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Qn(s, n) {
    return !s || s.type !== "TSTypeParameterDeclaration" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Zn(s, n) {
    return !s || s.type !== "TSTypeParameter" ? !1 : n == null || (0, i.default)(s, n);
  }
  function es(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (s.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ts(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (s.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function rs(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function is(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (s.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ns(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (s.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ss(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (s.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function as(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (s.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function h(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function d(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function T(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function k(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function te(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Se(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function je(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function pt(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function St(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Ht(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ao(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (s.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function oo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (s.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function lo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (s.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function uo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (s.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function co(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (s.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function po(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (s.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function fo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (s.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ho(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function mo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function yo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function To(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function So(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function go(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (s.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function bo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Bs(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Eo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Po(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function xo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function vo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Ao(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Co(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Io(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function wo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Oo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function No(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function _o(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Do(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function ko(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Lo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Mo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Bo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Fo(s, n) {
    if (!s) return !1;
    switch (s.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return n == null || (0, i.default)(s, n);
  }
  function Ro(s, n) {
    return (0, l.default)("isNumberLiteral", "isNumericLiteral"), !s || s.type !== "NumberLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function jo(s, n) {
    return (0, l.default)("isRegexLiteral", "isRegExpLiteral"), !s || s.type !== "RegexLiteral" ? !1 : n == null || (0, i.default)(s, n);
  }
  function qo(s, n) {
    return (0, l.default)("isRestProperty", "isRestElement"), !s || s.type !== "RestProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Uo(s, n) {
    return (0, l.default)("isSpreadProperty", "isSpreadElement"), !s || s.type !== "SpreadProperty" ? !1 : n == null || (0, i.default)(s, n);
  }
  function Vo(s, n) {
    return (0, l.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Bs(s, n);
  }
  return W;
}
var Pl;
function Pp() {
  if (Pl) return qs;
  Pl = 1, Object.defineProperty(qs, "__esModule", {
    value: !0
  }), qs.default = l;
  var i = bt();
  function l(u, o, f) {
    if (!(0, i.isMemberExpression)(u)) return !1;
    const p = Array.isArray(o) ? o : o.split("."), P = [];
    let w;
    for (w = u; (0, i.isMemberExpression)(w); w = w.object)
      P.push(w.property);
    if (P.push(w), P.length < p.length || !f && P.length > p.length) return !1;
    for (let x = 0, A = P.length - 1; x < p.length; x++, A--) {
      const g = P[A];
      let I;
      if ((0, i.isIdentifier)(g))
        I = g.name;
      else if ((0, i.isStringLiteral)(g))
        I = g.value;
      else if ((0, i.isThisExpression)(g))
        I = "this";
      else
        return !1;
      if (p[x] !== I) return !1;
    }
    return !0;
  }
  return qs;
}
var xl;
function xp() {
  if (xl) return js;
  xl = 1, Object.defineProperty(js, "__esModule", {
    value: !0
  }), js.default = l;
  var i = Pp();
  function l(u, o) {
    const f = u.split(".");
    return (p) => (0, i.default)(p, f, o);
  }
  return js;
}
var vl;
function sf() {
  if (vl) return cs;
  vl = 1, Object.defineProperty(cs, "__esModule", {
    value: !0
  }), cs.default = void 0;
  var i = xp();
  const l = (0, i.default)("React.Component");
  return cs.default = l, cs;
}
var Ks = {}, Al;
function af() {
  if (Al) return Ks;
  Al = 1, Object.defineProperty(Ks, "__esModule", {
    value: !0
  }), Ks.default = i;
  function i(l) {
    return !!l && /^[a-z]/.test(l);
  }
  return Ks;
}
var Ws = {}, $s = {}, Xo = {}, U = {}, Yi = {}, Yo = {}, vt = {}, Js = {}, Xs = {}, Cl;
function sl() {
  if (Cl) return Xs;
  Cl = 1, Object.defineProperty(Xs, "__esModule", {
    value: !0
  }), Xs.default = l;
  var i = tr();
  function l(u, o) {
    if (u === o) return !0;
    if (u == null || i.ALIAS_KEYS[o]) return !1;
    const f = i.FLIPPED_ALIAS_KEYS[o];
    if (f) {
      if (f[0] === u) return !0;
      for (const p of f)
        if (u === p) return !0;
    }
    return !1;
  }
  return Xs;
}
var Ys = {}, Il;
function vp() {
  if (Il) return Ys;
  Il = 1, Object.defineProperty(Ys, "__esModule", {
    value: !0
  }), Ys.default = l;
  var i = tr();
  function l(u, o) {
    if (u === o) return !0;
    const f = i.PLACEHOLDERS_ALIAS[u];
    if (f) {
      for (const p of f)
        if (o === p) return !0;
    }
    return !1;
  }
  return Ys;
}
var wl;
function Ls() {
  if (wl) return Js;
  wl = 1, Object.defineProperty(Js, "__esModule", {
    value: !0
  }), Js.default = f;
  var i = nl(), l = sl(), u = vp(), o = tr();
  function f(p, P, w) {
    return P ? (0, l.default)(P.type, p) ? w === void 0 ? !0 : (0, i.default)(P, w) : !w && P.type === "Placeholder" && p in o.FLIPPED_ALIAS_KEYS ? (0, u.default)(P.expectedNode, p) : !1 : !1;
  }
  return Js;
}
var Hs = {}, Ho = {}, rn = {}, Ol;
function of() {
  if (Ol) return rn;
  Ol = 1, Object.defineProperty(rn, "__esModule", {
    value: !0
  }), rn.isIdentifierChar = x, rn.isIdentifierName = A, rn.isIdentifierStart = w;
  let i = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", l = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const u = new RegExp("[" + i + "]"), o = new RegExp("[" + i + l + "]");
  i = l = null;
  const f = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], p = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function P(g, I) {
    let v = 65536;
    for (let S = 0, _ = I.length; S < _; S += 2) {
      if (v += I[S], v > g) return !1;
      if (v += I[S + 1], v >= g) return !0;
    }
    return !1;
  }
  function w(g) {
    return g < 65 ? g === 36 : g <= 90 ? !0 : g < 97 ? g === 95 : g <= 122 ? !0 : g <= 65535 ? g >= 170 && u.test(String.fromCharCode(g)) : P(g, f);
  }
  function x(g) {
    return g < 48 ? g === 36 : g < 58 ? !0 : g < 65 ? !1 : g <= 90 ? !0 : g < 97 ? g === 95 : g <= 122 ? !0 : g <= 65535 ? g >= 170 && o.test(String.fromCharCode(g)) : P(g, f) || P(g, p);
  }
  function A(g) {
    let I = !0;
    for (let v = 0; v < g.length; v++) {
      let S = g.charCodeAt(v);
      if ((S & 64512) === 55296 && v + 1 < g.length) {
        const _ = g.charCodeAt(++v);
        (_ & 64512) === 56320 && (S = 65536 + ((S & 1023) << 10) + (_ & 1023));
      }
      if (I) {
        if (I = !1, !w(S))
          return !1;
      } else if (!x(S))
        return !1;
    }
    return !I;
  }
  return rn;
}
var Jr = {}, Nl;
function lf() {
  if (Nl) return Jr;
  Nl = 1, Object.defineProperty(Jr, "__esModule", {
    value: !0
  }), Jr.isKeyword = x, Jr.isReservedWord = f, Jr.isStrictBindOnlyReservedWord = P, Jr.isStrictBindReservedWord = w, Jr.isStrictReservedWord = p;
  const i = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, l = new Set(i.keyword), u = new Set(i.strict), o = new Set(i.strictBind);
  function f(A, g) {
    return g && A === "await" || A === "enum";
  }
  function p(A, g) {
    return f(A, g) || u.has(A);
  }
  function P(A) {
    return o.has(A);
  }
  function w(A, g) {
    return p(A, g) || P(A);
  }
  function x(A) {
    return l.has(A);
  }
  return Jr;
}
var _l;
function to() {
  return _l || (_l = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), Object.defineProperty(i, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return l.isIdentifierChar;
      }
    }), Object.defineProperty(i, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return l.isIdentifierName;
      }
    }), Object.defineProperty(i, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return l.isIdentifierStart;
      }
    }), Object.defineProperty(i, "isKeyword", {
      enumerable: !0,
      get: function() {
        return u.isKeyword;
      }
    }), Object.defineProperty(i, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return u.isReservedWord;
      }
    }), Object.defineProperty(i, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return u.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(i, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return u.isStrictBindReservedWord;
      }
    }), Object.defineProperty(i, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return u.isStrictReservedWord;
      }
    });
    var l = of(), u = lf();
  }(Ho)), Ho;
}
var Dl;
function Ms() {
  if (Dl) return Hs;
  Dl = 1, Object.defineProperty(Hs, "__esModule", {
    value: !0
  }), Hs.default = l;
  var i = to();
  function l(u, o = !0) {
    return typeof u != "string" || o && ((0, i.isKeyword)(u) || (0, i.isStrictReservedWord)(u, !0)) ? !1 : (0, i.isIdentifierName)(u);
  }
  return Hs;
}
var nn = {}, kl;
function uf() {
  if (kl) return nn;
  kl = 1, Object.defineProperty(nn, "__esModule", {
    value: !0
  }), nn.readCodePoint = x, nn.readInt = w, nn.readStringContents = o;
  var i = function(g) {
    return g >= 48 && g <= 57;
  };
  const l = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, u = {
    bin: (A) => A === 48 || A === 49,
    oct: (A) => A >= 48 && A <= 55,
    dec: (A) => A >= 48 && A <= 57,
    hex: (A) => A >= 48 && A <= 57 || A >= 65 && A <= 70 || A >= 97 && A <= 102
  };
  function o(A, g, I, v, S, _) {
    const B = I, y = v, X = S;
    let Z = "", J = null, G = I;
    const {
      length: O
    } = g;
    for (; ; ) {
      if (I >= O) {
        _.unterminated(B, y, X), Z += g.slice(G, I);
        break;
      }
      const ee = g.charCodeAt(I);
      if (f(A, ee, g, I)) {
        Z += g.slice(G, I);
        break;
      }
      if (ee === 92) {
        Z += g.slice(G, I);
        const L = p(g, I, v, S, A === "template", _);
        L.ch === null && !J ? J = {
          pos: I,
          lineStart: v,
          curLine: S
        } : Z += L.ch, {
          pos: I,
          lineStart: v,
          curLine: S
        } = L, G = I;
      } else ee === 8232 || ee === 8233 ? (++I, ++S, v = I) : ee === 10 || ee === 13 ? A === "template" ? (Z += g.slice(G, I) + `
`, ++I, ee === 13 && g.charCodeAt(I) === 10 && ++I, ++S, G = v = I) : _.unterminated(B, y, X) : ++I;
    }
    return {
      pos: I,
      str: Z,
      firstInvalidLoc: J,
      lineStart: v,
      curLine: S,
      containsInvalid: !!J
    };
  }
  function f(A, g, I, v) {
    return A === "template" ? g === 96 || g === 36 && I.charCodeAt(v + 1) === 123 : g === (A === "double" ? 34 : 39);
  }
  function p(A, g, I, v, S, _) {
    const B = !S;
    g++;
    const y = (Z) => ({
      pos: g,
      ch: Z,
      lineStart: I,
      curLine: v
    }), X = A.charCodeAt(g++);
    switch (X) {
      case 110:
        return y(`
`);
      case 114:
        return y("\r");
      case 120: {
        let Z;
        return {
          code: Z,
          pos: g
        } = P(A, g, I, v, 2, !1, B, _), y(Z === null ? null : String.fromCharCode(Z));
      }
      case 117: {
        let Z;
        return {
          code: Z,
          pos: g
        } = x(A, g, I, v, B, _), y(Z === null ? null : String.fromCodePoint(Z));
      }
      case 116:
        return y("	");
      case 98:
        return y("\b");
      case 118:
        return y("\v");
      case 102:
        return y("\f");
      case 13:
        A.charCodeAt(g) === 10 && ++g;
      case 10:
        I = g, ++v;
      case 8232:
      case 8233:
        return y("");
      case 56:
      case 57:
        if (S)
          return y(null);
        _.strictNumericEscape(g - 1, I, v);
      default:
        if (X >= 48 && X <= 55) {
          const Z = g - 1;
          let G = /^[0-7]+/.exec(A.slice(Z, g + 2))[0], O = parseInt(G, 8);
          O > 255 && (G = G.slice(0, -1), O = parseInt(G, 8)), g += G.length - 1;
          const ee = A.charCodeAt(g);
          if (G !== "0" || ee === 56 || ee === 57) {
            if (S)
              return y(null);
            _.strictNumericEscape(Z, I, v);
          }
          return y(String.fromCharCode(O));
        }
        return y(String.fromCharCode(X));
    }
  }
  function P(A, g, I, v, S, _, B, y) {
    const X = g;
    let Z;
    return {
      n: Z,
      pos: g
    } = w(A, g, I, v, 16, S, _, !1, y, !B), Z === null && (B ? y.invalidEscapeSequence(X, I, v) : g = X - 1), {
      code: Z,
      pos: g
    };
  }
  function w(A, g, I, v, S, _, B, y, X, Z) {
    const J = g, G = S === 16 ? l.hex : l.decBinOct, O = S === 16 ? u.hex : S === 10 ? u.dec : S === 8 ? u.oct : u.bin;
    let ee = !1, L = 0;
    for (let q = 0, H = _ ?? 1 / 0; q < H; ++q) {
      const N = A.charCodeAt(g);
      let F;
      if (N === 95 && y !== "bail") {
        const ie = A.charCodeAt(g - 1), re = A.charCodeAt(g + 1);
        if (y) {
          if (Number.isNaN(re) || !O(re) || G.has(ie) || G.has(re)) {
            if (Z) return {
              n: null,
              pos: g
            };
            X.unexpectedNumericSeparator(g, I, v);
          }
        } else {
          if (Z) return {
            n: null,
            pos: g
          };
          X.numericSeparatorInEscapeSequence(g, I, v);
        }
        ++g;
        continue;
      }
      if (N >= 97 ? F = N - 97 + 10 : N >= 65 ? F = N - 65 + 10 : i(N) ? F = N - 48 : F = 1 / 0, F >= S) {
        if (F <= 9 && Z)
          return {
            n: null,
            pos: g
          };
        if (F <= 9 && X.invalidDigit(g, I, v, S))
          F = 0;
        else if (B)
          F = 0, ee = !0;
        else
          break;
      }
      ++g, L = L * S + F;
    }
    return g === J || _ != null && g - J !== _ || ee ? {
      n: null,
      pos: g
    } : {
      n: L,
      pos: g
    };
  }
  function x(A, g, I, v, S, _) {
    const B = A.charCodeAt(g);
    let y;
    if (B === 123) {
      if (++g, {
        code: y,
        pos: g
      } = P(A, g, I, v, A.indexOf("}", g) - g, !0, S, _), ++g, y !== null && y > 1114111)
        if (S)
          _.invalidCodePoint(g, I, v);
        else
          return {
            code: null,
            pos: g
          };
    } else
      ({
        code: y,
        pos: g
      } = P(A, g, I, v, 4, !1, S, _));
    return {
      code: y,
      pos: g
    };
  }
  return nn;
}
var ze = {}, Ll;
function zi() {
  if (Ll) return ze;
  Ll = 1, Object.defineProperty(ze, "__esModule", {
    value: !0
  }), ze.UPDATE_OPERATORS = ze.UNARY_OPERATORS = ze.STRING_UNARY_OPERATORS = ze.STATEMENT_OR_BLOCK_KEYS = ze.NUMBER_UNARY_OPERATORS = ze.NUMBER_BINARY_OPERATORS = ze.NOT_LOCAL_BINDING = ze.LOGICAL_OPERATORS = ze.INHERIT_KEYS = ze.FOR_INIT_KEYS = ze.FLATTENABLE_KEYS = ze.EQUALITY_BINARY_OPERATORS = ze.COMPARISON_BINARY_OPERATORS = ze.COMMENT_KEYS = ze.BOOLEAN_UNARY_OPERATORS = ze.BOOLEAN_NUMBER_BINARY_OPERATORS = ze.BOOLEAN_BINARY_OPERATORS = ze.BLOCK_SCOPED_SYMBOL = ze.BINARY_OPERATORS = ze.ASSIGNMENT_OPERATORS = void 0, ze.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], ze.FLATTENABLE_KEYS = ["body", "expressions"], ze.FOR_INIT_KEYS = ["left", "init"], ze.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  const i = ze.LOGICAL_OPERATORS = ["||", "&&", "??"];
  ze.UPDATE_OPERATORS = ["++", "--"];
  const l = ze.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], u = ze.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], o = ze.COMPARISON_BINARY_OPERATORS = [...u, "in", "instanceof"], f = ze.BOOLEAN_BINARY_OPERATORS = [...o, ...l], p = ze.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  ze.BINARY_OPERATORS = ["+", ...p, ...f, "|>"], ze.ASSIGNMENT_OPERATORS = ["=", "+=", ...p.map((A) => A + "="), ...i.map((A) => A + "=")];
  const P = ze.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], w = ze.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], x = ze.STRING_UNARY_OPERATORS = ["typeof"];
  return ze.UNARY_OPERATORS = ["void", "throw", ...P, ...w, ...x], ze.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, ze.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), ze.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding"), ze;
}
var ot = {}, Ml;
function vr() {
  if (Ml) return ot;
  Ml = 1, Object.defineProperty(ot, "__esModule", {
    value: !0
  }), ot.VISITOR_KEYS = ot.NODE_PARENT_VALIDATIONS = ot.NODE_FIELDS = ot.FLIPPED_ALIAS_KEYS = ot.DEPRECATED_KEYS = ot.BUILDER_KEYS = ot.ALIAS_KEYS = void 0, ot.arrayOf = _, ot.arrayOfType = B, ot.assertEach = X, ot.assertNodeOrValueType = G, ot.assertNodeType = J, ot.assertOneOf = Z, ot.assertOptionalChainStart = L, ot.assertShape = ee, ot.assertValueType = O, ot.chain = q, ot.default = re, ot.defineAliasedType = ie, ot.validate = g, ot.validateArrayOfType = y, ot.validateOptional = v, ot.validateOptionalType = S, ot.validateType = I;
  var i = Ls(), l = al();
  const u = ot.VISITOR_KEYS = {}, o = ot.ALIAS_KEYS = {}, f = ot.FLIPPED_ALIAS_KEYS = {}, p = ot.NODE_FIELDS = {}, P = ot.BUILDER_KEYS = {}, w = ot.DEPRECATED_KEYS = {}, x = ot.NODE_PARENT_VALIDATIONS = {};
  function A(Q) {
    return Array.isArray(Q) ? "array" : Q === null ? "null" : typeof Q;
  }
  function g(Q) {
    return {
      validate: Q
    };
  }
  function I(...Q) {
    return g(J(...Q));
  }
  function v(Q) {
    return {
      validate: Q,
      optional: !0
    };
  }
  function S(...Q) {
    return {
      validate: J(...Q),
      optional: !0
    };
  }
  function _(Q) {
    return q(O("array"), X(Q));
  }
  function B(...Q) {
    return _(J(...Q));
  }
  function y(...Q) {
    return g(B(...Q));
  }
  function X(Q) {
    const pe = process.env.BABEL_TYPES_8_BREAKING ? l.validateChild : () => {
    };
    function ne(R, C, z) {
      if (Array.isArray(z))
        for (let ae = 0; ae < z.length; ae++) {
          const ce = `${C}[${ae}]`, ye = z[ae];
          Q(R, ce, ye), pe(R, ce, ye);
        }
    }
    return ne.each = Q, ne;
  }
  function Z(...Q) {
    function pe(ne, R, C) {
      if (!Q.includes(C))
        throw new TypeError(`Property ${R} expected value to be one of ${JSON.stringify(Q)} but got ${JSON.stringify(C)}`);
    }
    return pe.oneOf = Q, pe;
  }
  function J(...Q) {
    function pe(ne, R, C) {
      for (const z of Q)
        if ((0, i.default)(z, C)) {
          (0, l.validateChild)(ne, R, C);
          return;
        }
      throw new TypeError(`Property ${R} of ${ne.type} expected node to be of a type ${JSON.stringify(Q)} but instead got ${JSON.stringify(C == null ? void 0 : C.type)}`);
    }
    return pe.oneOfNodeTypes = Q, pe;
  }
  function G(...Q) {
    function pe(ne, R, C) {
      for (const z of Q)
        if (A(C) === z || (0, i.default)(z, C)) {
          (0, l.validateChild)(ne, R, C);
          return;
        }
      throw new TypeError(`Property ${R} of ${ne.type} expected node to be of a type ${JSON.stringify(Q)} but instead got ${JSON.stringify(C == null ? void 0 : C.type)}`);
    }
    return pe.oneOfNodeOrValueTypes = Q, pe;
  }
  function O(Q) {
    function pe(ne, R, C) {
      if (!(A(C) === Q))
        throw new TypeError(`Property ${R} expected type of ${Q} but got ${A(C)}`);
    }
    return pe.type = Q, pe;
  }
  function ee(Q) {
    function pe(ne, R, C) {
      const z = [];
      for (const ae of Object.keys(Q))
        try {
          (0, l.validateField)(ne, ae, C[ae], Q[ae]);
        } catch (ce) {
          if (ce instanceof TypeError) {
            z.push(ce.message);
            continue;
          }
          throw ce;
        }
      if (z.length)
        throw new TypeError(`Property ${R} of ${ne.type} expected to have the following:
${z.join(`
`)}`);
    }
    return pe.shapeOf = Q, pe;
  }
  function L() {
    function Q(pe) {
      var ne;
      let R = pe;
      for (; pe; ) {
        const {
          type: C
        } = R;
        if (C === "OptionalCallExpression") {
          if (R.optional) return;
          R = R.callee;
          continue;
        }
        if (C === "OptionalMemberExpression") {
          if (R.optional) return;
          R = R.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${pe.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(ne = R) == null ? void 0 : ne.type}`);
    }
    return Q;
  }
  function q(...Q) {
    function pe(...ne) {
      for (const R of Q)
        R(...ne);
    }
    if (pe.chainOf = Q, Q.length >= 2 && "type" in Q[0] && Q[0].type === "array" && !("each" in Q[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return pe;
  }
  const H = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), N = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]), F = {};
  function ie(...Q) {
    return (pe, ne = {}) => {
      let R = ne.aliases;
      if (!R) {
        var C, z;
        ne.inherits && (R = (C = F[ne.inherits].aliases) == null ? void 0 : C.slice()), (z = R) != null || (R = []), ne.aliases = R;
      }
      const ae = Q.filter((ce) => !R.includes(ce));
      R.unshift(...ae), re(pe, ne);
    };
  }
  function re(Q, pe = {}) {
    const ne = pe.inherits && F[pe.inherits] || {};
    let R = pe.fields;
    if (!R && (R = {}, ne.fields)) {
      const ce = Object.getOwnPropertyNames(ne.fields);
      for (const ye of ce) {
        const he = ne.fields[ye], Pe = he.default;
        if (Array.isArray(Pe) ? Pe.length > 0 : Pe && typeof Pe == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        R[ye] = {
          default: Array.isArray(Pe) ? [] : Pe,
          optional: he.optional,
          deprecated: he.deprecated,
          validate: he.validate
        };
      }
    }
    const C = pe.visitor || ne.visitor || [], z = pe.aliases || ne.aliases || [], ae = pe.builder || ne.builder || pe.visitor || [];
    for (const ce of Object.keys(pe))
      if (!H.has(ce))
        throw new Error(`Unknown type option "${ce}" on ${Q}`);
    pe.deprecatedAlias && (w[pe.deprecatedAlias] = Q);
    for (const ce of C.concat(ae))
      R[ce] = R[ce] || {};
    for (const ce of Object.keys(R)) {
      const ye = R[ce];
      ye.default !== void 0 && !ae.includes(ce) && (ye.optional = !0), ye.default === void 0 ? ye.default = null : !ye.validate && ye.default != null && (ye.validate = O(A(ye.default)));
      for (const he of Object.keys(ye))
        if (!N.has(he))
          throw new Error(`Unknown field key "${he}" on ${Q}.${ce}`);
    }
    u[Q] = pe.visitor = C, P[Q] = pe.builder = ae, p[Q] = pe.fields = R, o[Q] = pe.aliases = z, z.forEach((ce) => {
      f[ce] = f[ce] || [], f[ce].push(Q);
    }), pe.validate && (x[Q] = pe.validate), F[Q] = pe;
  }
  return ot;
}
var Bl;
function ro() {
  if (Bl) return vt;
  Bl = 1, Object.defineProperty(vt, "__esModule", {
    value: !0
  }), vt.patternLikeCommon = vt.importAttributes = vt.functionTypeAnnotationCommon = vt.functionDeclarationCommon = vt.functionCommon = vt.classMethodOrPropertyCommon = vt.classMethodOrDeclareMethodCommon = void 0;
  var i = Ls(), l = Ms(), u = to(), o = uf(), f = zi(), p = vr();
  const P = (0, p.defineAliasedType)("Standardized");
  P("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, p.arrayOf)((0, p.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), P("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          const _ = (0, p.assertOneOf)(...f.ASSIGNMENT_OPERATORS), B = (0, p.assertOneOf)("=");
          return function(y, X, Z) {
            ((0, i.default)("Pattern", y.left) ? B : _)(y, X, Z);
          };
        }(), {
          type: "string"
        }) : (0, p.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  }), P("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, p.assertOneOf)(...f.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const _ = (0, p.assertNodeType)("Expression"), B = (0, p.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(X, Z, J) {
            (X.operator === "in" ? B : _)(X, Z, J);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  }), P("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    }
  }), P("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, p.assertNodeType)("DirectiveLiteral")
      }
    }
  }), P("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    }
  }), P("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, p.arrayOfType)("Directive"),
        default: []
      },
      body: (0, p.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  }), P("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), P("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, p.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, p.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), P("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  }), P("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, p.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  }), P("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), P("DebuggerStatement", {
    aliases: ["Statement"]
  }), P("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  }), P("EmptyStatement", {
    aliases: ["Statement"]
  }), P("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  }), P("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, p.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertEach)((0, p.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, p.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  }), P("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), P("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, p.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  });
  const w = () => ({
    params: (0, p.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  });
  vt.functionCommon = w;
  const x = () => ({
    returnType: {
      validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  vt.functionTypeAnnotationCommon = x;
  const A = () => Object.assign({}, w(), {
    declare: {
      validate: (0, p.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, p.assertNodeType)("Identifier"),
      optional: !0
    }
  });
  vt.functionDeclarationCommon = A, P("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, A(), x(), {
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      const _ = (0, p.assertNodeType)("Identifier");
      return function(B, y, X) {
        (0, i.default)("ExportDefaultDeclaration", B) || _(X, "id", X.id);
      };
    }() : void 0
  }), P("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, w(), x(), {
      id: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  const g = () => ({
    typeAnnotation: {
      validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, p.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, p.arrayOfType)("Decorator"),
      optional: !0
    }
  });
  vt.patternLikeCommon = g, P("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, g(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("string"), Object.assign(function(_, B, y) {
          if (!(0, l.default)(y, !1))
            throw new TypeError(`"${y}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, p.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(_, B, y) {
      const X = /\.(\w+)$/.exec(B);
      if (!X) return;
      const [, Z] = X, J = {
        computed: !1
      };
      if (Z === "property") {
        if ((0, i.default)("MemberExpression", _, J) || (0, i.default)("OptionalMemberExpression", _, J)) return;
      } else if (Z === "key") {
        if ((0, i.default)("Property", _, J) || (0, i.default)("Method", _, J)) return;
      } else if (Z === "exported") {
        if ((0, i.default)("ExportSpecifier", _)) return;
      } else if (Z === "imported") {
        if ((0, i.default)("ImportSpecifier", _, {
          imported: y
        })) return;
      } else if (Z === "meta" && (0, i.default)("MetaProperty", _, {
        meta: y
      }))
        return;
      if (((0, u.isKeyword)(y.name) || (0, u.isReservedWord)(y.name, !1)) && y.name !== "this")
        throw new TypeError(`"${y.name}" is not a valid identifier`);
    } : void 0
  }), P("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, p.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), P("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), P("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), P("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, p.chain)((0, p.assertValueType)("number"), Object.assign(function(_, B, y) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), P("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), P("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), P("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, p.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("string"), Object.assign(function(_, B, y) {
          const X = /[^gimsuy]/.exec(y);
          if (X)
            throw new TypeError(`"${X[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, p.assertValueType)("string"),
        default: ""
      }
    }
  }), P("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, p.assertOneOf)(...f.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, p.assertNodeType)("Expression")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, p.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const _ = (0, p.assertNodeType)("Identifier", "PrivateName"), B = (0, p.assertNodeType)("Expression"), y = function(X, Z, J) {
            (X.computed ? B : _)(X, Z, J);
          };
          return y.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], y;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), P("NewExpression", {
    inherits: "CallExpression"
  }), P("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, p.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, p.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, p.arrayOfType)("Directive"),
        default: []
      },
      body: (0, p.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  }), P("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, p.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  }), P("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, w(), x(), {
      kind: Object.assign({
        validate: (0, p.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const _ = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), B = (0, p.assertNodeType)("Expression"), y = function(X, Z, J) {
            (X.computed ? B : _)(X, Z, J);
          };
          return y.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], y;
        }()
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }), P("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const _ = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), B = (0, p.assertNodeType)("Expression");
          return Object.assign(function(X, Z, J) {
            (X.computed ? B : _)(X, Z, J);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, p.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), Object.assign(function(_, B, y) {
          if (y) {
            if (_.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, i.default)("Identifier", _.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, p.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      const _ = (0, p.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), B = (0, p.assertNodeType)("Expression");
      return function(y, X, Z) {
        ((0, i.default)("ObjectPattern", y) ? _ : B)(Z, "value", Z.value);
      };
    }() : void 0
  }), P("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, g(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("LVal")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(_, B) {
      const y = /(\w+)\[(\d+)\]/.exec(B);
      if (!y) throw new Error("Internal Babel error: malformed key.");
      const [, X, Z] = y;
      if (_[X].length > +Z + 1)
        throw new TypeError(`RestElement must be last element of ${X}`);
    } : void 0
  }), P("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), P("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, p.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  }), P("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, p.validateArrayOfType)("Statement")
    }
  }), P("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, p.assertNodeType)("Expression")
      },
      cases: (0, p.validateArrayOfType)("SwitchCase")
    }
  }), P("ThisExpression", {
    aliases: ["Expression"]
  }), P("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertNodeType)("BlockStatement"), Object.assign(function(_) {
          if (!_.handler && !_.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, p.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, p.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    }
  }), P("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, p.assertOneOf)(...f.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  }), P("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "MemberExpression") : (0, p.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, p.assertOneOf)(...f.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  }), P("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, p.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, p.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      const _ = (0, p.assertNodeType)("Identifier");
      return function(B, y, X) {
        if ((0, i.default)("ForXStatement", B, {
          left: X
        })) {
          if (X.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${B.type}`);
        } else
          X.declarations.forEach((Z) => {
            Z.init || _(Z, "id", Z.id);
          });
      };
    })() : void 0
  }), P("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, p.assertNodeType)("LVal")
      },
      definite: {
        optional: !0,
        validate: (0, p.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), P("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), P("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, g(), {
      left: {
        validate: (0, p.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  }), P("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, g(), {
      elements: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  }), P("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, w(), x(), {
      expression: {
        validate: (0, p.assertValueType)("boolean")
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  }), P("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, p.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  }), P("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, p.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, p.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, p.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  }), P("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, p.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, p.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, p.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, p.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      const _ = (0, p.assertNodeType)("Identifier");
      return function(B, y, X) {
        (0, i.default)("ExportDefaultDeclaration", B) || _(X, "id", X.id);
      };
    }() : void 0
  });
  const I = vt.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, p.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, p.arrayOfType)("ImportAttribute")
    }
  };
  P("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, p.assertNodeType)("StringLiteral")
      },
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("type", "value"))
    }, I)
  }), P("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, p.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("value"))
    }
  }), P("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertNodeType)("Declaration"), Object.assign(function(_, B, y) {
          if (y && _.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (y && _.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, p.assertNodeType)("Declaration")
      }
    }, I, {
      specifiers: {
        default: [],
        validate: (0, p.arrayOf)(function() {
          const _ = (0, p.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), B = (0, p.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(y, X, Z) {
            (y.source ? _ : B)(y, X, Z);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : _;
        }())
      },
      source: {
        validate: (0, p.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("type", "value"))
    })
  }), P("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, p.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, p.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), P("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, p.assertNodeType)("VariableDeclaration", "LVal");
          const _ = (0, p.assertNodeType)("VariableDeclaration"), B = (0, p.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(y, X, Z) {
            (0, i.default)("VariableDeclaration", Z) ? _(y, X, Z) : B(y, X, Z);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  }), P("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, I, {
      module: {
        optional: !0,
        validate: (0, p.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, p.assertOneOf)("source", "defer")
      },
      specifiers: (0, p.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, p.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, p.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  }), P("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), P("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), P("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, p.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, p.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), P("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, p.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, p.assertNodeType)("Expression")
      },
      options: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), P("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertNodeType)("Identifier"), Object.assign(function(_, B, y) {
          let X;
          switch (y.name) {
            case "function":
              X = "sent";
              break;
            case "new":
              X = "target";
              break;
            case "import":
              X = "meta";
              break;
          }
          if (!(0, i.default)("Identifier", _.property, {
            name: X
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, p.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  });
  const v = () => ({
    abstract: {
      validate: (0, p.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, p.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, p.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, p.chain)(function() {
        const _ = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), B = (0, p.assertNodeType)("Expression");
        return function(y, X, Z) {
          (y.computed ? B : _)(y, X, Z);
        };
      }(), (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  vt.classMethodOrPropertyCommon = v;
  const S = () => Object.assign({}, w(), v(), {
    params: (0, p.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
    kind: {
      validate: (0, p.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, p.chain)((0, p.assertValueType)("string"), (0, p.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, p.arrayOfType)("Decorator"),
      optional: !0
    }
  });
  return vt.classMethodOrDeclareMethodCommon = S, P("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, S(), x(), {
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    })
  }), P("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, g(), {
      properties: (0, p.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  }), P("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("Super", {
    aliases: ["Expression"]
  }), P("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, p.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, p.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), P("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, p.chain)((0, p.assertShape)({
          raw: {
            validate: (0, p.assertValueType)("string")
          },
          cooked: {
            validate: (0, p.assertValueType)("string"),
            optional: !0
          }
        }), function(B) {
          const y = B.value.raw;
          let X = !1;
          const Z = () => {
            throw new Error("Internal @babel/types error.");
          }, {
            str: J,
            firstInvalidLoc: G
          } = (0, o.readStringContents)("template", y, 0, 0, 0, {
            unterminated() {
              X = !0;
            },
            strictNumericEscape: Z,
            invalidEscapeSequence: Z,
            numericSeparatorInEscapeSequence: Z,
            unexpectedNumericSeparator: Z,
            invalidDigit: Z,
            invalidCodePoint: Z
          });
          if (!X) throw new Error("Invalid raw");
          B.value.cooked = G ? null : J;
        })
      },
      tail: {
        default: !1
      }
    }
  }), P("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, p.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Expression", "TSType")), function(_, B, y) {
          if (_.quasis.length !== y.length + 1)
            throw new TypeError(`Number of ${_.type} quasis should be exactly one more than the number of expressions.
Expected ${y.length + 1} quasis but got ${_.quasis.length}`);
        })
      }
    }
  }), P("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), Object.assign(function(_, B, y) {
          if (y && !_.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, p.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), P("Import", {
    aliases: ["Expression"]
  }), P("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), P("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), P("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, p.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const _ = (0, p.assertNodeType)("Identifier"), B = (0, p.assertNodeType)("Expression");
          return Object.assign(function(X, Z, J) {
            (X.computed ? B : _)(X, Z, J);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), (0, p.assertOptionalChainStart)()) : (0, p.assertValueType)("boolean")
      }
    }
  }), P("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, p.assertNodeType)("Expression")
      },
      arguments: (0, p.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), (0, p.assertOptionalChainStart)()) : (0, p.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, p.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), P("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, v(), {
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), P("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, v(), {
      key: {
        validate: (0, p.chain)(function() {
          const _ = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), B = (0, p.assertNodeType)("Expression");
          return function(y, X, Z) {
            (y.computed ? B : _)(y, X, Z);
          };
        }(), (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), P("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, p.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, p.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, p.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: !0
      }
    }
  }), P("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, S(), x(), {
      kind: {
        validate: (0, p.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, p.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    })
  }), P("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), P("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, p.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  }), vt;
}
var Fl = {}, Rl;
function cf() {
  if (Rl) return Fl;
  Rl = 1;
  var i = ro(), l = vr();
  const u = (0, l.defineAliasedType)("Flow"), o = (f) => {
    const p = f === "DeclareClass";
    u(f, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...p ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, l.validateType)("Identifier"),
        typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, l.validateOptional)((0, l.arrayOfType)("InterfaceExtends"))
      }, p ? {
        mixins: (0, l.validateOptional)((0, l.arrayOfType)("InterfaceExtends")),
        implements: (0, l.validateOptional)((0, l.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, l.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  return u("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, l.validateType)("FlowType")
    }
  }), u("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterInstantiation")
    }
  }), o("DeclareClass"), u("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      predicate: (0, l.validateOptionalType)("DeclaredPredicate")
    }
  }), o("DeclareInterface"), u("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier", "StringLiteral"),
      body: (0, l.validateType)("BlockStatement"),
      kind: (0, l.validateOptional)((0, l.assertOneOf)("CommonJS", "ES"))
    }
  }), u("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, l.validateType)("TypeAnnotation")
    }
  }), u("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, l.validateType)("FlowType")
    }
  }), u("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, l.validateOptionalType)("FlowType"),
      impltype: (0, l.validateOptionalType)("FlowType")
    }
  }), u("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier")
    }
  }), u("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, l.validateOptionalType)("Flow"),
      specifiers: (0, l.validateOptional)((0, l.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, l.validateOptionalType)("StringLiteral"),
      default: (0, l.validateOptional)((0, l.assertValueType)("boolean"))
    }, i.importAttributes)
  }), u("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, l.validateType)("StringLiteral"),
      exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value"))
    }, i.importAttributes)
  }), u("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, l.validateType)("Flow")
    }
  }), u("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  }), u("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, l.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, l.validateOptionalType)("FunctionTypeParam"),
      this: (0, l.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, l.validateType)("FlowType")
    }
  }), u("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, l.validateOptionalType)("Identifier"),
      typeAnnotation: (0, l.validateType)("FlowType"),
      optional: (0, l.validateOptional)((0, l.assertValueType)("boolean"))
    }
  }), u("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, l.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterInstantiation")
    }
  }), u("InferredPredicate", {
    aliases: ["FlowPredicate"]
  }), u("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, l.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterInstantiation")
    }
  }), o("InterfaceDeclaration"), u("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, l.validateOptional)((0, l.arrayOfType)("InterfaceExtends")),
      body: (0, l.validateType)("ObjectTypeAnnotation")
    }
  }), u("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, l.validate)((0, l.arrayOfType)("FlowType"))
    }
  }), u("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, l.validateType)("FlowType")
    }
  }), u("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, l.validate)((0, l.assertValueType)("number"))
    }
  }), u("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, l.validate)((0, l.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, l.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, l.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, l.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, l.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, l.validateOptional)((0, l.assertValueType)("boolean"))
    }
  }), u("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      value: (0, l.validateType)("FlowType"),
      optional: (0, l.validate)((0, l.assertValueType)("boolean")),
      static: (0, l.validate)((0, l.assertValueType)("boolean")),
      method: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, l.validateType)("FlowType"),
      static: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, l.validateOptionalType)("Identifier"),
      key: (0, l.validateType)("FlowType"),
      value: (0, l.validateType)("FlowType"),
      static: (0, l.validate)((0, l.assertValueType)("boolean")),
      variance: (0, l.validateOptionalType)("Variance")
    }
  }), u("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, l.validateType)("Identifier", "StringLiteral"),
      value: (0, l.validateType)("FlowType"),
      kind: (0, l.validate)((0, l.assertOneOf)("init", "get", "set")),
      static: (0, l.validate)((0, l.assertValueType)("boolean")),
      proto: (0, l.validate)((0, l.assertValueType)("boolean")),
      optional: (0, l.validate)((0, l.assertValueType)("boolean")),
      variance: (0, l.validateOptionalType)("Variance"),
      method: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, l.validateType)("FlowType")
    }
  }), u("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, l.validateOptionalType)("FlowType"),
      impltype: (0, l.validateType)("FlowType")
    }
  }), u("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      qualification: (0, l.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  }), u("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, l.validate)((0, l.assertValueType)("string"))
    }
  }), u("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, l.validate)((0, l.arrayOfType)("FlowType"))
    }
  }), u("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, l.validateType)("FlowType")
    }
  }), u("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      typeParameters: (0, l.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, l.validateType)("FlowType")
    }
  }), u("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, l.validateType)("FlowType")
    }
  }), u("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, l.validateType)("Expression"),
      typeAnnotation: (0, l.validateType)("TypeAnnotation")
    }
  }), u("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, l.validate)((0, l.assertValueType)("string")),
      bound: (0, l.validateOptionalType)("TypeAnnotation"),
      default: (0, l.validateOptionalType)("FlowType"),
      variance: (0, l.validateOptionalType)("Variance")
    }
  }), u("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, l.validate)((0, l.arrayOfType)("TypeParameter"))
    }
  }), u("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, l.validate)((0, l.arrayOfType)("FlowType"))
    }
  }), u("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, l.validate)((0, l.arrayOfType)("FlowType"))
    }
  }), u("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, l.validate)((0, l.assertOneOf)("minus", "plus"))
    }
  }), u("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), u("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      body: (0, l.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  }), u("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, l.validate)((0, l.assertValueType)("boolean")),
      members: (0, l.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, l.validate)((0, l.assertValueType)("boolean")),
      members: (0, l.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, l.validate)((0, l.assertValueType)("boolean")),
      members: (0, l.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, l.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), u("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      init: (0, l.validateType)("BooleanLiteral")
    }
  }), u("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      init: (0, l.validateType)("NumericLiteral")
    }
  }), u("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, l.validateType)("Identifier"),
      init: (0, l.validateType)("StringLiteral")
    }
  }), u("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, l.validateType)("Identifier")
    }
  }), u("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, l.validateType)("FlowType"),
      indexType: (0, l.validateType)("FlowType")
    }
  }), u("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, l.validateType)("FlowType"),
      indexType: (0, l.validateType)("FlowType"),
      optional: (0, l.validate)((0, l.assertValueType)("boolean"))
    }
  }), Fl;
}
var jl = {}, ql;
function pf() {
  if (ql) return jl;
  ql = 1;
  var i = vr();
  const l = (0, i.defineAliasedType)("JSX");
  return l("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, i.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, i.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), l("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), l("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, i.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, i.assertNodeType)("JSXClosingElement")
      },
      children: (0, i.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), l("JSXEmptyExpression", {}), l("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, i.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), l("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, i.assertNodeType)("Expression")
      }
    }
  }), l("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, i.assertValueType)("string")
      }
    }
  }), l("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, i.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, i.assertNodeType)("JSXIdentifier")
      }
    }
  }), l("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, i.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, i.assertNodeType)("JSXIdentifier")
      }
    }
  }), l("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, i.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, i.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, i.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), l("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, i.assertNodeType)("Expression")
      }
    }
  }), l("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, i.assertValueType)("string")
      }
    }
  }), l("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, i.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, i.assertNodeType)("JSXClosingFragment")
      },
      children: (0, i.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  }), l("JSXOpeningFragment", {
    aliases: ["Immutable"]
  }), l("JSXClosingFragment", {
    aliases: ["Immutable"]
  }), jl;
}
var Ul = {}, br = {}, Vl;
function Ap() {
  if (Vl) return br;
  Vl = 1, Object.defineProperty(br, "__esModule", {
    value: !0
  }), br.PLACEHOLDERS_FLIPPED_ALIAS = br.PLACEHOLDERS_ALIAS = br.PLACEHOLDERS = void 0;
  var i = vr();
  const l = br.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], u = br.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const f of l) {
    const p = i.ALIAS_KEYS[f];
    p != null && p.length && (u[f] = p);
  }
  const o = br.PLACEHOLDERS_FLIPPED_ALIAS = {};
  return Object.keys(u).forEach((f) => {
    u[f].forEach((p) => {
      hasOwnProperty.call(o, p) || (o[p] = []), o[p].push(f);
    });
  }), br;
}
var Kl;
function ff() {
  if (Kl) return Ul;
  Kl = 1;
  var i = vr(), l = Ap(), u = ro();
  const o = (0, i.defineAliasedType)("Miscellaneous");
  return o("Noop", {
    visitor: []
  }), o("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, i.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, i.assertOneOf)(...l.PLACEHOLDERS)
      }
    }, (0, u.patternLikeCommon)())
  }), o("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, i.assertValueType)("string")
      }
    }
  }), Ul;
}
var Wl = {}, $l;
function hf() {
  if ($l) return Wl;
  $l = 1;
  var i = vr();
  return (0, i.default)("ArgumentPlaceholder", {}), (0, i.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, i.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, i.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  }), (0, i.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, i.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, i.assertNodeType)("StringLiteral")
      }
    }
  }), (0, i.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, i.assertNodeType)("Expression")
      }
    }
  }), (0, i.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, i.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, i.assertValueType)("boolean"),
        default: !1
      }
    }
  }), (0, i.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, i.assertNodeType)("Identifier")
      }
    }
  }), (0, i.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, i.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  }), (0, i.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, i.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), (0, i.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, i.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), (0, i.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, i.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  }), (0, i.default)("TopicReference", {
    aliases: ["Expression"]
  }), (0, i.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, i.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, i.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, i.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, i.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  }), Wl;
}
var Jl = {}, Xl;
function df() {
  if (Xl) return Jl;
  Xl = 1;
  var i = vr(), l = ro(), u = Ls();
  const o = (0, i.defineAliasedType)("TypeScript"), f = (0, i.assertValueType)("boolean"), p = () => ({
    returnType: {
      validate: (0, i.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, i.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  o("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, i.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, i.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, i.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  }), o("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, l.functionDeclarationCommon)(), p())
  }), o("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, l.classMethodOrDeclareMethodCommon)(), p())
  }), o("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, i.validateType)("TSEntityName"),
      right: (0, i.validateType)("Identifier")
    }
  });
  const P = () => ({
    typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, i.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation")
  }), w = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: P()
  };
  o("TSCallSignatureDeclaration", w), o("TSConstructSignatureDeclaration", w);
  const x = () => ({
    key: (0, i.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, i.validateOptional)(f)
  });
  o("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, x(), {
      readonly: (0, i.validateOptional)(f),
      typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, i.assertOneOf)("get", "set")
      }
    })
  }), o("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, P(), x(), {
      kind: {
        validate: (0, i.assertOneOf)("method", "get", "set")
      }
    })
  }), o("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, i.validateOptional)(f),
      static: (0, i.validateOptional)(f),
      parameters: (0, i.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const A = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const S of A)
    o(S, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  o("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const g = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  o("TSFunctionType", Object.assign({}, g, {
    fields: P()
  })), o("TSConstructorType", Object.assign({}, g, {
    fields: Object.assign({}, P(), {
      abstract: (0, i.validateOptional)(f)
    })
  })), o("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, i.validateType)("TSEntityName"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), o("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, i.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, i.validateOptional)(f)
    }
  }), o("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, i.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), o("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, i.validateArrayOfType)("TSTypeElement")
    }
  }), o("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, i.validateType)("TSType")
    }
  }), o("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, i.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  }), o("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, i.validateType)("TSType")
    }
  }), o("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, i.validateType)("TSType")
    }
  }), o("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, i.validateType)("Identifier"),
      optional: {
        validate: f,
        default: !1
      },
      elementType: (0, i.validateType)("TSType")
    }
  });
  const I = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, i.validateArrayOfType)("TSType")
    }
  };
  o("TSUnionType", I), o("TSIntersectionType", I), o("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, i.validateType)("TSType"),
      extendsType: (0, i.validateType)("TSType"),
      trueType: (0, i.validateType)("TSType"),
      falseType: (0, i.validateType)("TSType")
    }
  }), o("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, i.validateType)("TSTypeParameter")
    }
  }), o("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, i.validateType)("TSType")
    }
  }), o("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, i.validate)((0, i.assertValueType)("string")),
      typeAnnotation: (0, i.validateType)("TSType")
    }
  }), o("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, i.validateType)("TSType"),
      indexType: (0, i.validateType)("TSType")
    }
  }), o("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, i.validateType)("TSTypeParameter")
    }, {
      readonly: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, i.validateOptionalType)("TSType"),
      nameType: (0, i.validateOptionalType)("TSType")
    })
  }), o("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, i.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("TSType")), function(S, _, B) {
          if (S.quasis.length !== B.length + 1)
            throw new TypeError(`Number of ${S.type} quasis should be exactly one more than the number of types.
Expected ${B.length + 1} quasis but got ${S.quasis.length}`);
        })
      }
    }
  }), o("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const S = (0, i.assertNodeType)("NumericLiteral", "BigIntLiteral"), _ = (0, i.assertOneOf)("-"), B = (0, i.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function y(X, Z, J) {
            (0, u.default)("UnaryExpression", J) ? (_(J, "operator", J.operator), S(J, "argument", J.argument)) : B(X, Z, J);
          }
          return y.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], y;
        }()
      }
    }
  }), o("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, i.validateType)("TSEntityName"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), o("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, i.validateOptional)(f),
      id: (0, i.validateType)("Identifier"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, i.validateOptional)((0, i.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, i.validateType)("TSInterfaceBody")
    }
  }), o("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, i.validateArrayOfType)("TSTypeElement")
    }
  }), o("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, i.validateOptional)(f),
      id: (0, i.validateType)("Identifier"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, i.validateType)("TSType")
    }
  }), o("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, i.validateType)("Expression"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const v = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, i.validateType)("Expression"),
      typeAnnotation: (0, i.validateType)("TSType")
    }
  };
  return o("TSAsExpression", v), o("TSSatisfiesExpression", v), o("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, i.validateType)("TSType"),
      expression: (0, i.validateType)("Expression")
    }
  }), o("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, i.validateArrayOfType)("TSEnumMember")
    }
  }), o("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, i.validateOptional)(f),
      const: (0, i.validateOptional)(f),
      id: (0, i.validateType)("Identifier"),
      members: (0, i.validateArrayOfType)("TSEnumMember"),
      initializer: (0, i.validateOptionalType)("Expression"),
      body: (0, i.validateOptionalType)("TSEnumBody")
    }
  }), o("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, i.validateType)("Identifier", "StringLiteral"),
      initializer: (0, i.validateOptionalType)("Expression")
    }
  }), o("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, i.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, i.validateOptional)(f)
    }, {
      global: (0, i.validateOptional)(f)
    }, {
      id: (0, i.validateType)("Identifier", "StringLiteral"),
      body: (0, i.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  }), o("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, i.validateArrayOfType)("Statement")
    }
  }), o("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, i.validateType)("StringLiteral"),
      qualifier: (0, i.validateOptionalType)("TSEntityName"),
      typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, i.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), o("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, i.validate)(f)
    }, {
      id: (0, i.validateType)("Identifier"),
      moduleReference: (0, i.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, i.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  }), o("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, i.validateType)("StringLiteral")
    }
  }), o("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, i.validateType)("Expression")
    }
  }), o("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, i.validateType)("Expression")
    }
  }), o("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, i.validateType)("Identifier")
    }
  }), o("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, i.assertNodeType)("TSType")
      }
    }
  }), o("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, i.validateArrayOfType)("TSType")
    }
  }), o("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, i.validateArrayOfType)("TSTypeParameter")
    }
  }), o("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, i.assertValueType)("string")
      },
      in: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, i.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, i.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, i.assertNodeType)("TSType"),
        optional: !0
      }
    }
  }), Jl;
}
var ps = {}, Yl;
function mf() {
  return Yl || (Yl = 1, Object.defineProperty(ps, "__esModule", {
    value: !0
  }), ps.DEPRECATED_ALIASES = void 0, ps.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  }), ps;
}
var Hl;
function tr() {
  return Hl || (Hl = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), Object.defineProperty(i, "ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return l.ALIAS_KEYS;
      }
    }), Object.defineProperty(i, "BUILDER_KEYS", {
      enumerable: !0,
      get: function() {
        return l.BUILDER_KEYS;
      }
    }), Object.defineProperty(i, "DEPRECATED_ALIASES", {
      enumerable: !0,
      get: function() {
        return o.DEPRECATED_ALIASES;
      }
    }), Object.defineProperty(i, "DEPRECATED_KEYS", {
      enumerable: !0,
      get: function() {
        return l.DEPRECATED_KEYS;
      }
    }), Object.defineProperty(i, "FLIPPED_ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return l.FLIPPED_ALIAS_KEYS;
      }
    }), Object.defineProperty(i, "NODE_FIELDS", {
      enumerable: !0,
      get: function() {
        return l.NODE_FIELDS;
      }
    }), Object.defineProperty(i, "NODE_PARENT_VALIDATIONS", {
      enumerable: !0,
      get: function() {
        return l.NODE_PARENT_VALIDATIONS;
      }
    }), Object.defineProperty(i, "PLACEHOLDERS", {
      enumerable: !0,
      get: function() {
        return u.PLACEHOLDERS;
      }
    }), Object.defineProperty(i, "PLACEHOLDERS_ALIAS", {
      enumerable: !0,
      get: function() {
        return u.PLACEHOLDERS_ALIAS;
      }
    }), Object.defineProperty(i, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: !0,
      get: function() {
        return u.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    }), i.TYPES = void 0, Object.defineProperty(i, "VISITOR_KEYS", {
      enumerable: !0,
      get: function() {
        return l.VISITOR_KEYS;
      }
    }), ro(), cf(), pf(), ff(), hf(), df();
    var l = vr(), u = Ap(), o = mf();
    Object.keys(o.DEPRECATED_ALIASES).forEach((f) => {
      l.FLIPPED_ALIAS_KEYS[f] = l.FLIPPED_ALIAS_KEYS[o.DEPRECATED_ALIASES[f]];
    }), i.TYPES = [].concat(Object.keys(l.VISITOR_KEYS), Object.keys(l.FLIPPED_ALIAS_KEYS), Object.keys(l.DEPRECATED_KEYS));
  }(Yo)), Yo;
}
var Gl;
function al() {
  if (Gl) return Yi;
  Gl = 1, Object.defineProperty(Yi, "__esModule", {
    value: !0
  }), Yi.default = l, Yi.validateChild = f, Yi.validateField = o, Yi.validateInternal = u;
  var i = tr();
  function l(p, P, w) {
    if (!p) return;
    const x = i.NODE_FIELDS[p.type];
    if (!x) return;
    const A = x[P];
    o(p, P, w, A), f(p, P, w);
  }
  function u(p, P, w, x, A) {
    if (p != null && p.validate && !(p.optional && x == null) && (p.validate(P, w, x), A)) {
      var g;
      const I = x.type;
      if (I == null) return;
      (g = i.NODE_PARENT_VALIDATIONS[I]) == null || g.call(i.NODE_PARENT_VALIDATIONS, P, w, x);
    }
  }
  function o(p, P, w, x) {
    x != null && x.validate && (x.optional && w == null || x.validate(p, P, w));
  }
  function f(p, P, w) {
    var x;
    const A = w == null ? void 0 : w.type;
    A != null && ((x = i.NODE_PARENT_VALIDATIONS[A]) == null || x.call(i.NODE_PARENT_VALIDATIONS, p, P, w));
  }
  return Yi;
}
var zl;
function Cp() {
  if (zl) return U;
  zl = 1, Object.defineProperty(U, "__esModule", {
    value: !0
  }), U.anyTypeAnnotation = Gt, U.argumentPlaceholder = qi, U.arrayExpression = p, U.arrayPattern = Xe, U.arrayTypeAnnotation = Mt, U.arrowFunctionExpression = Tt, U.assignmentExpression = P, U.assignmentPattern = ft, U.awaitExpression = Kt, U.bigIntLiteral = At, U.binaryExpression = w, U.bindExpression = gr, U.blockStatement = I, U.booleanLiteral = ne, U.booleanLiteralTypeAnnotation = Qr, U.booleanTypeAnnotation = zr, U.breakStatement = v, U.callExpression = S, U.catchClause = _, U.classAccessorProperty = rr, U.classBody = be, U.classDeclaration = j, U.classExpression = ve, U.classImplements = Xt, U.classMethod = et, U.classPrivateMethod = Hr, U.classPrivateProperty = Yr, U.classProperty = Jt, U.conditionalExpression = B, U.continueStatement = y, U.debuggerStatement = X, U.decimalLiteral = Ji, U.declareClass = Ir, U.declareExportAllDeclaration = ti, U.declareExportDeclaration = Or, U.declareFunction = hr, U.declareInterface = dr, U.declareModule = Zr, U.declareModuleExports = mr, U.declareOpaqueType = wr, U.declareTypeAlias = ei, U.declareVariable = nr, U.declaredPredicate = ri, U.decorator = Vi, U.directive = A, U.directiveLiteral = g, U.doExpression = Wr, U.doWhileStatement = Z, U.emptyStatement = J, U.emptyTypeAnnotation = Dr, U.enumBooleanBody = xi, U.enumBooleanMember = Ci, U.enumDeclaration = Yt, U.enumDefaultedMember = Fe, U.enumNumberBody = vi, U.enumNumberMember = Ii, U.enumStringBody = Ai, U.enumStringMember = Br, U.enumSymbolBody = Mr, U.existsTypeAnnotation = yr, U.exportAllDeclaration = D, U.exportDefaultDeclaration = V, U.exportDefaultSpecifier = Ki, U.exportNamedDeclaration = le, U.exportNamespaceSpecifier = xt, U.exportSpecifier = me, U.expressionStatement = G, U.file = O, U.forInStatement = ee, U.forOfStatement = ge, U.forStatement = L, U.functionDeclaration = q, U.functionExpression = H, U.functionTypeAnnotation = Nr, U.functionTypeParam = _r, U.genericTypeAnnotation = zt, U.identifier = N, U.ifStatement = F, U.import = Nt, U.importAttribute = Ui, U.importDeclaration = xe, U.importDefaultSpecifier = De, U.importExpression = Ye, U.importNamespaceSpecifier = We, U.importSpecifier = Ce, U.indexedAccessType = wi, U.inferredPredicate = ii, U.interfaceDeclaration = ni, U.interfaceExtends = _t, U.interfaceTypeAnnotation = si, U.interpreterDirective = x, U.intersectionTypeAnnotation = ai, U.jSXAttribute = U.jsxAttribute = Oi, U.jSXClosingElement = U.jsxClosingElement = Ni, U.jSXClosingFragment = U.jsxClosingFragment = Fi, U.jSXElement = U.jsxElement = _i, U.jSXEmptyExpression = U.jsxEmptyExpression = Di, U.jSXExpressionContainer = U.jsxExpressionContainer = Rr, U.jSXFragment = U.jsxFragment = Bi, U.jSXIdentifier = U.jsxIdentifier = jr, U.jSXMemberExpression = U.jsxMemberExpression = qr, U.jSXNamespacedName = U.jsxNamespacedName = Li, U.jSXOpeningElement = U.jsxOpeningElement = Mi, U.jSXOpeningFragment = U.jsxOpeningFragment = Kr, U.jSXSpreadAttribute = U.jsxSpreadAttribute = Ur, U.jSXSpreadChild = U.jsxSpreadChild = ki, U.jSXText = U.jsxText = Vr, U.labeledStatement = ie, U.logicalExpression = C, U.memberExpression = z, U.metaProperty = $e, U.mixedTypeAnnotation = sr, U.moduleExpression = Qt, U.newExpression = ae, U.noop = Ri, U.nullLiteral = pe, U.nullLiteralTypeAnnotation = ir, U.nullableTypeAnnotation = oi, U.numberLiteral = is, U.numberLiteralTypeAnnotation = li, U.numberTypeAnnotation = ui, U.numericLiteral = Q, U.objectExpression = ye, U.objectMethod = he, U.objectPattern = oe, U.objectProperty = Pe, U.objectTypeAnnotation = ci, U.objectTypeCallProperty = pi, U.objectTypeIndexer = ar, U.objectTypeInternalSlot = kr, U.objectTypeProperty = fi, U.objectTypeSpreadProperty = or, U.opaqueType = lr, U.optionalCallExpression = $t, U.optionalIndexedAccessType = Fr, U.optionalMemberExpression = Wt, U.parenthesizedExpression = Le, U.pipelineBareFunction = b, U.pipelinePrimaryTopicReference = t, U.pipelineTopicExpression = Xi, U.placeholder = Sr, U.privateName = Cr, U.program = ce, U.qualifiedTypeIdentifier = Tr, U.recordExpression = Wi, U.regExpLiteral = R, U.regexLiteral = ns, U.restElement = Ne, U.restProperty = ss, U.returnStatement = we, U.sequenceExpression = Ie, U.spreadElement = K, U.spreadProperty = as, U.staticBlock = Gr, U.stringLiteral = re, U.stringLiteralTypeAnnotation = hi, U.stringTypeAnnotation = wt, U.super = Ae, U.switchCase = fe, U.switchStatement = Te, U.symbolTypeAnnotation = di, U.taggedTemplateExpression = Be, U.templateElement = Ke, U.templateLiteral = ct, U.thisExpression = de, U.thisTypeAnnotation = mi, U.throwStatement = Ue, U.topicReference = $r, U.tryStatement = Je, U.tSAnyKeyword = U.tsAnyKeyword = Ee, U.tSArrayType = U.tsArrayType = gn, U.tSAsExpression = U.tsAsExpression = jn, U.tSBigIntKeyword = U.tsBigIntKeyword = ke, U.tSBooleanKeyword = U.tsBooleanKeyword = _e, U.tSCallSignatureDeclaration = U.tsCallSignatureDeclaration = E, U.tSConditionalType = U.tsConditionalType = Cn, U.tSConstructSignatureDeclaration = U.tsConstructSignatureDeclaration = M, U.tSConstructorType = U.tsConstructorType = dn, U.tSDeclareFunction = U.tsDeclareFunction = r, U.tSDeclareMethod = U.tsDeclareMethod = a, U.tSEnumBody = U.tsEnumBody = Vn, U.tSEnumDeclaration = U.tsEnumDeclaration = Kn, U.tSEnumMember = U.tsEnumMember = Wn, U.tSExportAssignment = U.tsExportAssignment = zn, U.tSExpressionWithTypeArguments = U.tsExpressionWithTypeArguments = Ln, U.tSExternalModuleReference = U.tsExternalModuleReference = Hn, U.tSFunctionType = U.tsFunctionType = hn, U.tSImportEqualsDeclaration = U.tsImportEqualsDeclaration = Yn, U.tSImportType = U.tsImportType = Xn, U.tSIndexSignature = U.tsIndexSignature = ue, U.tSIndexedAccessType = U.tsIndexedAccessType = Nn, U.tSInferType = U.tsInferType = In, U.tSInstantiationExpression = U.tsInstantiationExpression = Rn, U.tSInterfaceBody = U.tsInterfaceBody = Bn, U.tSInterfaceDeclaration = U.tsInterfaceDeclaration = Mn, U.tSIntersectionType = U.tsIntersectionType = An, U.tSIntrinsicKeyword = U.tsIntrinsicKeyword = Re, U.tSLiteralType = U.tsLiteralType = kn, U.tSMappedType = U.tsMappedType = _n, U.tSMethodSignature = U.tsMethodSignature = se, U.tSModuleBlock = U.tsModuleBlock = Jn, U.tSModuleDeclaration = U.tsModuleDeclaration = $n, U.tSNamedTupleMember = U.tsNamedTupleMember = xn, U.tSNamespaceExportDeclaration = U.tsNamespaceExportDeclaration = Qn, U.tSNeverKeyword = U.tsNeverKeyword = Qe, U.tSNonNullExpression = U.tsNonNullExpression = Gn, U.tSNullKeyword = U.tsNullKeyword = mt, U.tSNumberKeyword = U.tsNumberKeyword = tt, U.tSObjectKeyword = U.tsObjectKeyword = ut, U.tSOptionalType = U.tsOptionalType = En, U.tSParameterProperty = U.tsParameterProperty = e, U.tSParenthesizedType = U.tsParenthesizedType = wn, U.tSPropertySignature = U.tsPropertySignature = Y, U.tSQualifiedName = U.tsQualifiedName = c, U.tSRestType = U.tsRestType = Pn, U.tSSatisfiesExpression = U.tsSatisfiesExpression = qn, U.tSStringKeyword = U.tsStringKeyword = ur, U.tSSymbolKeyword = U.tsSymbolKeyword = Zt, U.tSTemplateLiteralType = U.tsTemplateLiteralType = Dn, U.tSThisType = U.tsThisType = fn, U.tSTupleType = U.tsTupleType = bn, U.tSTypeAliasDeclaration = U.tsTypeAliasDeclaration = Fn, U.tSTypeAnnotation = U.tsTypeAnnotation = Zn, U.tSTypeAssertion = U.tsTypeAssertion = Un, U.tSTypeLiteral = U.tsTypeLiteral = Sn, U.tSTypeOperator = U.tsTypeOperator = On, U.tSTypeParameter = U.tsTypeParameter = rs, U.tSTypeParameterDeclaration = U.tsTypeParameterDeclaration = ts, U.tSTypeParameterInstantiation = U.tsTypeParameterInstantiation = es, U.tSTypePredicate = U.tsTypePredicate = yn, U.tSTypeQuery = U.tsTypeQuery = Tn, U.tSTypeReference = U.tsTypeReference = mn, U.tSUndefinedKeyword = U.tsUndefinedKeyword = un, U.tSUnionType = U.tsUnionType = vn, U.tSUnknownKeyword = U.tsUnknownKeyword = cn, U.tSVoidKeyword = U.tsVoidKeyword = pn, U.tupleExpression = $i, U.tupleTypeAnnotation = yi, U.typeAlias = Ti, U.typeAnnotation = Lr, U.typeCastExpression = Si, U.typeParameter = gi, U.typeParameterDeclaration = bi, U.typeParameterInstantiation = Ei, U.typeofTypeAnnotation = Ve, U.unaryExpression = He, U.unionTypeAnnotation = Pi, U.updateExpression = st, U.v8IntrinsicIdentifier = ji, U.variableDeclaration = qe, U.variableDeclarator = Ge, U.variance = Bt, U.voidTypeAnnotation = Dt, U.whileStatement = at, U.withStatement = it, U.yieldExpression = Lt;
  var i = al(), l = eo(), u = vr();
  const {
    validateInternal: o
  } = i, {
    NODE_FIELDS: f
  } = u;
  function p(h = []) {
    const d = {
      type: "ArrayExpression",
      elements: h
    }, T = f.ArrayExpression;
    return o(T.elements, d, "elements", h, 1), d;
  }
  function P(h, d, T) {
    const k = {
      type: "AssignmentExpression",
      operator: h,
      left: d,
      right: T
    }, te = f.AssignmentExpression;
    return o(te.operator, k, "operator", h), o(te.left, k, "left", d, 1), o(te.right, k, "right", T, 1), k;
  }
  function w(h, d, T) {
    const k = {
      type: "BinaryExpression",
      operator: h,
      left: d,
      right: T
    }, te = f.BinaryExpression;
    return o(te.operator, k, "operator", h), o(te.left, k, "left", d, 1), o(te.right, k, "right", T, 1), k;
  }
  function x(h) {
    const d = {
      type: "InterpreterDirective",
      value: h
    }, T = f.InterpreterDirective;
    return o(T.value, d, "value", h), d;
  }
  function A(h) {
    const d = {
      type: "Directive",
      value: h
    }, T = f.Directive;
    return o(T.value, d, "value", h, 1), d;
  }
  function g(h) {
    const d = {
      type: "DirectiveLiteral",
      value: h
    }, T = f.DirectiveLiteral;
    return o(T.value, d, "value", h), d;
  }
  function I(h, d = []) {
    const T = {
      type: "BlockStatement",
      body: h,
      directives: d
    }, k = f.BlockStatement;
    return o(k.body, T, "body", h, 1), o(k.directives, T, "directives", d, 1), T;
  }
  function v(h = null) {
    const d = {
      type: "BreakStatement",
      label: h
    }, T = f.BreakStatement;
    return o(T.label, d, "label", h, 1), d;
  }
  function S(h, d) {
    const T = {
      type: "CallExpression",
      callee: h,
      arguments: d
    }, k = f.CallExpression;
    return o(k.callee, T, "callee", h, 1), o(k.arguments, T, "arguments", d, 1), T;
  }
  function _(h = null, d) {
    const T = {
      type: "CatchClause",
      param: h,
      body: d
    }, k = f.CatchClause;
    return o(k.param, T, "param", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function B(h, d, T) {
    const k = {
      type: "ConditionalExpression",
      test: h,
      consequent: d,
      alternate: T
    }, te = f.ConditionalExpression;
    return o(te.test, k, "test", h, 1), o(te.consequent, k, "consequent", d, 1), o(te.alternate, k, "alternate", T, 1), k;
  }
  function y(h = null) {
    const d = {
      type: "ContinueStatement",
      label: h
    }, T = f.ContinueStatement;
    return o(T.label, d, "label", h, 1), d;
  }
  function X() {
    return {
      type: "DebuggerStatement"
    };
  }
  function Z(h, d) {
    const T = {
      type: "DoWhileStatement",
      test: h,
      body: d
    }, k = f.DoWhileStatement;
    return o(k.test, T, "test", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function J() {
    return {
      type: "EmptyStatement"
    };
  }
  function G(h) {
    const d = {
      type: "ExpressionStatement",
      expression: h
    }, T = f.ExpressionStatement;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function O(h, d = null, T = null) {
    const k = {
      type: "File",
      program: h,
      comments: d,
      tokens: T
    }, te = f.File;
    return o(te.program, k, "program", h, 1), o(te.comments, k, "comments", d, 1), o(te.tokens, k, "tokens", T), k;
  }
  function ee(h, d, T) {
    const k = {
      type: "ForInStatement",
      left: h,
      right: d,
      body: T
    }, te = f.ForInStatement;
    return o(te.left, k, "left", h, 1), o(te.right, k, "right", d, 1), o(te.body, k, "body", T, 1), k;
  }
  function L(h = null, d = null, T = null, k) {
    const te = {
      type: "ForStatement",
      init: h,
      test: d,
      update: T,
      body: k
    }, Se = f.ForStatement;
    return o(Se.init, te, "init", h, 1), o(Se.test, te, "test", d, 1), o(Se.update, te, "update", T, 1), o(Se.body, te, "body", k, 1), te;
  }
  function q(h = null, d, T, k = !1, te = !1) {
    const Se = {
      type: "FunctionDeclaration",
      id: h,
      params: d,
      body: T,
      generator: k,
      async: te
    }, je = f.FunctionDeclaration;
    return o(je.id, Se, "id", h, 1), o(je.params, Se, "params", d, 1), o(je.body, Se, "body", T, 1), o(je.generator, Se, "generator", k), o(je.async, Se, "async", te), Se;
  }
  function H(h = null, d, T, k = !1, te = !1) {
    const Se = {
      type: "FunctionExpression",
      id: h,
      params: d,
      body: T,
      generator: k,
      async: te
    }, je = f.FunctionExpression;
    return o(je.id, Se, "id", h, 1), o(je.params, Se, "params", d, 1), o(je.body, Se, "body", T, 1), o(je.generator, Se, "generator", k), o(je.async, Se, "async", te), Se;
  }
  function N(h) {
    const d = {
      type: "Identifier",
      name: h
    }, T = f.Identifier;
    return o(T.name, d, "name", h), d;
  }
  function F(h, d, T = null) {
    const k = {
      type: "IfStatement",
      test: h,
      consequent: d,
      alternate: T
    }, te = f.IfStatement;
    return o(te.test, k, "test", h, 1), o(te.consequent, k, "consequent", d, 1), o(te.alternate, k, "alternate", T, 1), k;
  }
  function ie(h, d) {
    const T = {
      type: "LabeledStatement",
      label: h,
      body: d
    }, k = f.LabeledStatement;
    return o(k.label, T, "label", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function re(h) {
    const d = {
      type: "StringLiteral",
      value: h
    }, T = f.StringLiteral;
    return o(T.value, d, "value", h), d;
  }
  function Q(h) {
    const d = {
      type: "NumericLiteral",
      value: h
    }, T = f.NumericLiteral;
    return o(T.value, d, "value", h), d;
  }
  function pe() {
    return {
      type: "NullLiteral"
    };
  }
  function ne(h) {
    const d = {
      type: "BooleanLiteral",
      value: h
    }, T = f.BooleanLiteral;
    return o(T.value, d, "value", h), d;
  }
  function R(h, d = "") {
    const T = {
      type: "RegExpLiteral",
      pattern: h,
      flags: d
    }, k = f.RegExpLiteral;
    return o(k.pattern, T, "pattern", h), o(k.flags, T, "flags", d), T;
  }
  function C(h, d, T) {
    const k = {
      type: "LogicalExpression",
      operator: h,
      left: d,
      right: T
    }, te = f.LogicalExpression;
    return o(te.operator, k, "operator", h), o(te.left, k, "left", d, 1), o(te.right, k, "right", T, 1), k;
  }
  function z(h, d, T = !1, k = null) {
    const te = {
      type: "MemberExpression",
      object: h,
      property: d,
      computed: T,
      optional: k
    }, Se = f.MemberExpression;
    return o(Se.object, te, "object", h, 1), o(Se.property, te, "property", d, 1), o(Se.computed, te, "computed", T), o(Se.optional, te, "optional", k), te;
  }
  function ae(h, d) {
    const T = {
      type: "NewExpression",
      callee: h,
      arguments: d
    }, k = f.NewExpression;
    return o(k.callee, T, "callee", h, 1), o(k.arguments, T, "arguments", d, 1), T;
  }
  function ce(h, d = [], T = "script", k = null) {
    const te = {
      type: "Program",
      body: h,
      directives: d,
      sourceType: T,
      interpreter: k
    }, Se = f.Program;
    return o(Se.body, te, "body", h, 1), o(Se.directives, te, "directives", d, 1), o(Se.sourceType, te, "sourceType", T), o(Se.interpreter, te, "interpreter", k, 1), te;
  }
  function ye(h) {
    const d = {
      type: "ObjectExpression",
      properties: h
    }, T = f.ObjectExpression;
    return o(T.properties, d, "properties", h, 1), d;
  }
  function he(h = "method", d, T, k, te = !1, Se = !1, je = !1) {
    const pt = {
      type: "ObjectMethod",
      kind: h,
      key: d,
      params: T,
      body: k,
      computed: te,
      generator: Se,
      async: je
    }, St = f.ObjectMethod;
    return o(St.kind, pt, "kind", h), o(St.key, pt, "key", d, 1), o(St.params, pt, "params", T, 1), o(St.body, pt, "body", k, 1), o(St.computed, pt, "computed", te), o(St.generator, pt, "generator", Se), o(St.async, pt, "async", je), pt;
  }
  function Pe(h, d, T = !1, k = !1, te = null) {
    const Se = {
      type: "ObjectProperty",
      key: h,
      value: d,
      computed: T,
      shorthand: k,
      decorators: te
    }, je = f.ObjectProperty;
    return o(je.key, Se, "key", h, 1), o(je.value, Se, "value", d, 1), o(je.computed, Se, "computed", T), o(je.shorthand, Se, "shorthand", k), o(je.decorators, Se, "decorators", te, 1), Se;
  }
  function Ne(h) {
    const d = {
      type: "RestElement",
      argument: h
    }, T = f.RestElement;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function we(h = null) {
    const d = {
      type: "ReturnStatement",
      argument: h
    }, T = f.ReturnStatement;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Ie(h) {
    const d = {
      type: "SequenceExpression",
      expressions: h
    }, T = f.SequenceExpression;
    return o(T.expressions, d, "expressions", h, 1), d;
  }
  function Le(h) {
    const d = {
      type: "ParenthesizedExpression",
      expression: h
    }, T = f.ParenthesizedExpression;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function fe(h = null, d) {
    const T = {
      type: "SwitchCase",
      test: h,
      consequent: d
    }, k = f.SwitchCase;
    return o(k.test, T, "test", h, 1), o(k.consequent, T, "consequent", d, 1), T;
  }
  function Te(h, d) {
    const T = {
      type: "SwitchStatement",
      discriminant: h,
      cases: d
    }, k = f.SwitchStatement;
    return o(k.discriminant, T, "discriminant", h, 1), o(k.cases, T, "cases", d, 1), T;
  }
  function de() {
    return {
      type: "ThisExpression"
    };
  }
  function Ue(h) {
    const d = {
      type: "ThrowStatement",
      argument: h
    }, T = f.ThrowStatement;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Je(h, d = null, T = null) {
    const k = {
      type: "TryStatement",
      block: h,
      handler: d,
      finalizer: T
    }, te = f.TryStatement;
    return o(te.block, k, "block", h, 1), o(te.handler, k, "handler", d, 1), o(te.finalizer, k, "finalizer", T, 1), k;
  }
  function He(h, d, T = !0) {
    const k = {
      type: "UnaryExpression",
      operator: h,
      argument: d,
      prefix: T
    }, te = f.UnaryExpression;
    return o(te.operator, k, "operator", h), o(te.argument, k, "argument", d, 1), o(te.prefix, k, "prefix", T), k;
  }
  function st(h, d, T = !1) {
    const k = {
      type: "UpdateExpression",
      operator: h,
      argument: d,
      prefix: T
    }, te = f.UpdateExpression;
    return o(te.operator, k, "operator", h), o(te.argument, k, "argument", d, 1), o(te.prefix, k, "prefix", T), k;
  }
  function qe(h, d) {
    const T = {
      type: "VariableDeclaration",
      kind: h,
      declarations: d
    }, k = f.VariableDeclaration;
    return o(k.kind, T, "kind", h), o(k.declarations, T, "declarations", d, 1), T;
  }
  function Ge(h, d = null) {
    const T = {
      type: "VariableDeclarator",
      id: h,
      init: d
    }, k = f.VariableDeclarator;
    return o(k.id, T, "id", h, 1), o(k.init, T, "init", d, 1), T;
  }
  function at(h, d) {
    const T = {
      type: "WhileStatement",
      test: h,
      body: d
    }, k = f.WhileStatement;
    return o(k.test, T, "test", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function it(h, d) {
    const T = {
      type: "WithStatement",
      object: h,
      body: d
    }, k = f.WithStatement;
    return o(k.object, T, "object", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function ft(h, d) {
    const T = {
      type: "AssignmentPattern",
      left: h,
      right: d
    }, k = f.AssignmentPattern;
    return o(k.left, T, "left", h, 1), o(k.right, T, "right", d, 1), T;
  }
  function Xe(h) {
    const d = {
      type: "ArrayPattern",
      elements: h
    }, T = f.ArrayPattern;
    return o(T.elements, d, "elements", h, 1), d;
  }
  function Tt(h, d, T = !1) {
    const k = {
      type: "ArrowFunctionExpression",
      params: h,
      body: d,
      async: T,
      expression: null
    }, te = f.ArrowFunctionExpression;
    return o(te.params, k, "params", h, 1), o(te.body, k, "body", d, 1), o(te.async, k, "async", T), k;
  }
  function be(h) {
    const d = {
      type: "ClassBody",
      body: h
    }, T = f.ClassBody;
    return o(T.body, d, "body", h, 1), d;
  }
  function ve(h = null, d = null, T, k = null) {
    const te = {
      type: "ClassExpression",
      id: h,
      superClass: d,
      body: T,
      decorators: k
    }, Se = f.ClassExpression;
    return o(Se.id, te, "id", h, 1), o(Se.superClass, te, "superClass", d, 1), o(Se.body, te, "body", T, 1), o(Se.decorators, te, "decorators", k, 1), te;
  }
  function j(h = null, d = null, T, k = null) {
    const te = {
      type: "ClassDeclaration",
      id: h,
      superClass: d,
      body: T,
      decorators: k
    }, Se = f.ClassDeclaration;
    return o(Se.id, te, "id", h, 1), o(Se.superClass, te, "superClass", d, 1), o(Se.body, te, "body", T, 1), o(Se.decorators, te, "decorators", k, 1), te;
  }
  function D(h) {
    const d = {
      type: "ExportAllDeclaration",
      source: h
    }, T = f.ExportAllDeclaration;
    return o(T.source, d, "source", h, 1), d;
  }
  function V(h) {
    const d = {
      type: "ExportDefaultDeclaration",
      declaration: h
    }, T = f.ExportDefaultDeclaration;
    return o(T.declaration, d, "declaration", h, 1), d;
  }
  function le(h = null, d = [], T = null) {
    const k = {
      type: "ExportNamedDeclaration",
      declaration: h,
      specifiers: d,
      source: T
    }, te = f.ExportNamedDeclaration;
    return o(te.declaration, k, "declaration", h, 1), o(te.specifiers, k, "specifiers", d, 1), o(te.source, k, "source", T, 1), k;
  }
  function me(h, d) {
    const T = {
      type: "ExportSpecifier",
      local: h,
      exported: d
    }, k = f.ExportSpecifier;
    return o(k.local, T, "local", h, 1), o(k.exported, T, "exported", d, 1), T;
  }
  function ge(h, d, T, k = !1) {
    const te = {
      type: "ForOfStatement",
      left: h,
      right: d,
      body: T,
      await: k
    }, Se = f.ForOfStatement;
    return o(Se.left, te, "left", h, 1), o(Se.right, te, "right", d, 1), o(Se.body, te, "body", T, 1), o(Se.await, te, "await", k), te;
  }
  function xe(h, d) {
    const T = {
      type: "ImportDeclaration",
      specifiers: h,
      source: d
    }, k = f.ImportDeclaration;
    return o(k.specifiers, T, "specifiers", h, 1), o(k.source, T, "source", d, 1), T;
  }
  function De(h) {
    const d = {
      type: "ImportDefaultSpecifier",
      local: h
    }, T = f.ImportDefaultSpecifier;
    return o(T.local, d, "local", h, 1), d;
  }
  function We(h) {
    const d = {
      type: "ImportNamespaceSpecifier",
      local: h
    }, T = f.ImportNamespaceSpecifier;
    return o(T.local, d, "local", h, 1), d;
  }
  function Ce(h, d) {
    const T = {
      type: "ImportSpecifier",
      local: h,
      imported: d
    }, k = f.ImportSpecifier;
    return o(k.local, T, "local", h, 1), o(k.imported, T, "imported", d, 1), T;
  }
  function Ye(h, d = null) {
    const T = {
      type: "ImportExpression",
      source: h,
      options: d
    }, k = f.ImportExpression;
    return o(k.source, T, "source", h, 1), o(k.options, T, "options", d, 1), T;
  }
  function $e(h, d) {
    const T = {
      type: "MetaProperty",
      meta: h,
      property: d
    }, k = f.MetaProperty;
    return o(k.meta, T, "meta", h, 1), o(k.property, T, "property", d, 1), T;
  }
  function et(h = "method", d, T, k, te = !1, Se = !1, je = !1, pt = !1) {
    const St = {
      type: "ClassMethod",
      kind: h,
      key: d,
      params: T,
      body: k,
      computed: te,
      static: Se,
      generator: je,
      async: pt
    }, Ht = f.ClassMethod;
    return o(Ht.kind, St, "kind", h), o(Ht.key, St, "key", d, 1), o(Ht.params, St, "params", T, 1), o(Ht.body, St, "body", k, 1), o(Ht.computed, St, "computed", te), o(Ht.static, St, "static", Se), o(Ht.generator, St, "generator", je), o(Ht.async, St, "async", pt), St;
  }
  function oe(h) {
    const d = {
      type: "ObjectPattern",
      properties: h
    }, T = f.ObjectPattern;
    return o(T.properties, d, "properties", h, 1), d;
  }
  function K(h) {
    const d = {
      type: "SpreadElement",
      argument: h
    }, T = f.SpreadElement;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Ae() {
    return {
      type: "Super"
    };
  }
  function Be(h, d) {
    const T = {
      type: "TaggedTemplateExpression",
      tag: h,
      quasi: d
    }, k = f.TaggedTemplateExpression;
    return o(k.tag, T, "tag", h, 1), o(k.quasi, T, "quasi", d, 1), T;
  }
  function Ke(h, d = !1) {
    const T = {
      type: "TemplateElement",
      value: h,
      tail: d
    }, k = f.TemplateElement;
    return o(k.value, T, "value", h), o(k.tail, T, "tail", d), T;
  }
  function ct(h, d) {
    const T = {
      type: "TemplateLiteral",
      quasis: h,
      expressions: d
    }, k = f.TemplateLiteral;
    return o(k.quasis, T, "quasis", h, 1), o(k.expressions, T, "expressions", d, 1), T;
  }
  function Lt(h = null, d = !1) {
    const T = {
      type: "YieldExpression",
      argument: h,
      delegate: d
    }, k = f.YieldExpression;
    return o(k.argument, T, "argument", h, 1), o(k.delegate, T, "delegate", d), T;
  }
  function Kt(h) {
    const d = {
      type: "AwaitExpression",
      argument: h
    }, T = f.AwaitExpression;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Nt() {
    return {
      type: "Import"
    };
  }
  function At(h) {
    const d = {
      type: "BigIntLiteral",
      value: h
    }, T = f.BigIntLiteral;
    return o(T.value, d, "value", h), d;
  }
  function xt(h) {
    const d = {
      type: "ExportNamespaceSpecifier",
      exported: h
    }, T = f.ExportNamespaceSpecifier;
    return o(T.exported, d, "exported", h, 1), d;
  }
  function Wt(h, d, T = !1, k) {
    const te = {
      type: "OptionalMemberExpression",
      object: h,
      property: d,
      computed: T,
      optional: k
    }, Se = f.OptionalMemberExpression;
    return o(Se.object, te, "object", h, 1), o(Se.property, te, "property", d, 1), o(Se.computed, te, "computed", T), o(Se.optional, te, "optional", k), te;
  }
  function $t(h, d, T) {
    const k = {
      type: "OptionalCallExpression",
      callee: h,
      arguments: d,
      optional: T
    }, te = f.OptionalCallExpression;
    return o(te.callee, k, "callee", h, 1), o(te.arguments, k, "arguments", d, 1), o(te.optional, k, "optional", T), k;
  }
  function Jt(h, d = null, T = null, k = null, te = !1, Se = !1) {
    const je = {
      type: "ClassProperty",
      key: h,
      value: d,
      typeAnnotation: T,
      decorators: k,
      computed: te,
      static: Se
    }, pt = f.ClassProperty;
    return o(pt.key, je, "key", h, 1), o(pt.value, je, "value", d, 1), o(pt.typeAnnotation, je, "typeAnnotation", T, 1), o(pt.decorators, je, "decorators", k, 1), o(pt.computed, je, "computed", te), o(pt.static, je, "static", Se), je;
  }
  function rr(h, d = null, T = null, k = null, te = !1, Se = !1) {
    const je = {
      type: "ClassAccessorProperty",
      key: h,
      value: d,
      typeAnnotation: T,
      decorators: k,
      computed: te,
      static: Se
    }, pt = f.ClassAccessorProperty;
    return o(pt.key, je, "key", h, 1), o(pt.value, je, "value", d, 1), o(pt.typeAnnotation, je, "typeAnnotation", T, 1), o(pt.decorators, je, "decorators", k, 1), o(pt.computed, je, "computed", te), o(pt.static, je, "static", Se), je;
  }
  function Yr(h, d = null, T = null, k = !1) {
    const te = {
      type: "ClassPrivateProperty",
      key: h,
      value: d,
      decorators: T,
      static: k
    }, Se = f.ClassPrivateProperty;
    return o(Se.key, te, "key", h, 1), o(Se.value, te, "value", d, 1), o(Se.decorators, te, "decorators", T, 1), o(Se.static, te, "static", k), te;
  }
  function Hr(h = "method", d, T, k, te = !1) {
    const Se = {
      type: "ClassPrivateMethod",
      kind: h,
      key: d,
      params: T,
      body: k,
      static: te
    }, je = f.ClassPrivateMethod;
    return o(je.kind, Se, "kind", h), o(je.key, Se, "key", d, 1), o(je.params, Se, "params", T, 1), o(je.body, Se, "body", k, 1), o(je.static, Se, "static", te), Se;
  }
  function Cr(h) {
    const d = {
      type: "PrivateName",
      id: h
    }, T = f.PrivateName;
    return o(T.id, d, "id", h, 1), d;
  }
  function Gr(h) {
    const d = {
      type: "StaticBlock",
      body: h
    }, T = f.StaticBlock;
    return o(T.body, d, "body", h, 1), d;
  }
  function Gt() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function Mt(h) {
    const d = {
      type: "ArrayTypeAnnotation",
      elementType: h
    }, T = f.ArrayTypeAnnotation;
    return o(T.elementType, d, "elementType", h, 1), d;
  }
  function zr() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function Qr(h) {
    const d = {
      type: "BooleanLiteralTypeAnnotation",
      value: h
    }, T = f.BooleanLiteralTypeAnnotation;
    return o(T.value, d, "value", h), d;
  }
  function ir() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function Xt(h, d = null) {
    const T = {
      type: "ClassImplements",
      id: h,
      typeParameters: d
    }, k = f.ClassImplements;
    return o(k.id, T, "id", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function Ir(h, d = null, T = null, k) {
    const te = {
      type: "DeclareClass",
      id: h,
      typeParameters: d,
      extends: T,
      body: k
    }, Se = f.DeclareClass;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.extends, te, "extends", T, 1), o(Se.body, te, "body", k, 1), te;
  }
  function hr(h) {
    const d = {
      type: "DeclareFunction",
      id: h
    }, T = f.DeclareFunction;
    return o(T.id, d, "id", h, 1), d;
  }
  function dr(h, d = null, T = null, k) {
    const te = {
      type: "DeclareInterface",
      id: h,
      typeParameters: d,
      extends: T,
      body: k
    }, Se = f.DeclareInterface;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.extends, te, "extends", T, 1), o(Se.body, te, "body", k, 1), te;
  }
  function Zr(h, d, T = null) {
    const k = {
      type: "DeclareModule",
      id: h,
      body: d,
      kind: T
    }, te = f.DeclareModule;
    return o(te.id, k, "id", h, 1), o(te.body, k, "body", d, 1), o(te.kind, k, "kind", T), k;
  }
  function mr(h) {
    const d = {
      type: "DeclareModuleExports",
      typeAnnotation: h
    }, T = f.DeclareModuleExports;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function ei(h, d = null, T) {
    const k = {
      type: "DeclareTypeAlias",
      id: h,
      typeParameters: d,
      right: T
    }, te = f.DeclareTypeAlias;
    return o(te.id, k, "id", h, 1), o(te.typeParameters, k, "typeParameters", d, 1), o(te.right, k, "right", T, 1), k;
  }
  function wr(h, d = null, T = null) {
    const k = {
      type: "DeclareOpaqueType",
      id: h,
      typeParameters: d,
      supertype: T
    }, te = f.DeclareOpaqueType;
    return o(te.id, k, "id", h, 1), o(te.typeParameters, k, "typeParameters", d, 1), o(te.supertype, k, "supertype", T, 1), k;
  }
  function nr(h) {
    const d = {
      type: "DeclareVariable",
      id: h
    }, T = f.DeclareVariable;
    return o(T.id, d, "id", h, 1), d;
  }
  function Or(h = null, d = null, T = null, k = null) {
    const te = {
      type: "DeclareExportDeclaration",
      declaration: h,
      specifiers: d,
      source: T,
      attributes: k
    }, Se = f.DeclareExportDeclaration;
    return o(Se.declaration, te, "declaration", h, 1), o(Se.specifiers, te, "specifiers", d, 1), o(Se.source, te, "source", T, 1), o(Se.attributes, te, "attributes", k, 1), te;
  }
  function ti(h, d = null) {
    const T = {
      type: "DeclareExportAllDeclaration",
      source: h,
      attributes: d
    }, k = f.DeclareExportAllDeclaration;
    return o(k.source, T, "source", h, 1), o(k.attributes, T, "attributes", d, 1), T;
  }
  function ri(h) {
    const d = {
      type: "DeclaredPredicate",
      value: h
    }, T = f.DeclaredPredicate;
    return o(T.value, d, "value", h, 1), d;
  }
  function yr() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function Nr(h = null, d, T = null, k) {
    const te = {
      type: "FunctionTypeAnnotation",
      typeParameters: h,
      params: d,
      rest: T,
      returnType: k
    }, Se = f.FunctionTypeAnnotation;
    return o(Se.typeParameters, te, "typeParameters", h, 1), o(Se.params, te, "params", d, 1), o(Se.rest, te, "rest", T, 1), o(Se.returnType, te, "returnType", k, 1), te;
  }
  function _r(h = null, d) {
    const T = {
      type: "FunctionTypeParam",
      name: h,
      typeAnnotation: d
    }, k = f.FunctionTypeParam;
    return o(k.name, T, "name", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function zt(h, d = null) {
    const T = {
      type: "GenericTypeAnnotation",
      id: h,
      typeParameters: d
    }, k = f.GenericTypeAnnotation;
    return o(k.id, T, "id", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function ii() {
    return {
      type: "InferredPredicate"
    };
  }
  function _t(h, d = null) {
    const T = {
      type: "InterfaceExtends",
      id: h,
      typeParameters: d
    }, k = f.InterfaceExtends;
    return o(k.id, T, "id", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function ni(h, d = null, T = null, k) {
    const te = {
      type: "InterfaceDeclaration",
      id: h,
      typeParameters: d,
      extends: T,
      body: k
    }, Se = f.InterfaceDeclaration;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.extends, te, "extends", T, 1), o(Se.body, te, "body", k, 1), te;
  }
  function si(h = null, d) {
    const T = {
      type: "InterfaceTypeAnnotation",
      extends: h,
      body: d
    }, k = f.InterfaceTypeAnnotation;
    return o(k.extends, T, "extends", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function ai(h) {
    const d = {
      type: "IntersectionTypeAnnotation",
      types: h
    }, T = f.IntersectionTypeAnnotation;
    return o(T.types, d, "types", h, 1), d;
  }
  function sr() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function Dr() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function oi(h) {
    const d = {
      type: "NullableTypeAnnotation",
      typeAnnotation: h
    }, T = f.NullableTypeAnnotation;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function li(h) {
    const d = {
      type: "NumberLiteralTypeAnnotation",
      value: h
    }, T = f.NumberLiteralTypeAnnotation;
    return o(T.value, d, "value", h), d;
  }
  function ui() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function ci(h, d = [], T = [], k = [], te = !1) {
    const Se = {
      type: "ObjectTypeAnnotation",
      properties: h,
      indexers: d,
      callProperties: T,
      internalSlots: k,
      exact: te
    }, je = f.ObjectTypeAnnotation;
    return o(je.properties, Se, "properties", h, 1), o(je.indexers, Se, "indexers", d, 1), o(je.callProperties, Se, "callProperties", T, 1), o(je.internalSlots, Se, "internalSlots", k, 1), o(je.exact, Se, "exact", te), Se;
  }
  function kr(h, d, T, k, te) {
    const Se = {
      type: "ObjectTypeInternalSlot",
      id: h,
      value: d,
      optional: T,
      static: k,
      method: te
    }, je = f.ObjectTypeInternalSlot;
    return o(je.id, Se, "id", h, 1), o(je.value, Se, "value", d, 1), o(je.optional, Se, "optional", T), o(je.static, Se, "static", k), o(je.method, Se, "method", te), Se;
  }
  function pi(h) {
    const d = {
      type: "ObjectTypeCallProperty",
      value: h,
      static: null
    }, T = f.ObjectTypeCallProperty;
    return o(T.value, d, "value", h, 1), d;
  }
  function ar(h = null, d, T, k = null) {
    const te = {
      type: "ObjectTypeIndexer",
      id: h,
      key: d,
      value: T,
      variance: k,
      static: null
    }, Se = f.ObjectTypeIndexer;
    return o(Se.id, te, "id", h, 1), o(Se.key, te, "key", d, 1), o(Se.value, te, "value", T, 1), o(Se.variance, te, "variance", k, 1), te;
  }
  function fi(h, d, T = null) {
    const k = {
      type: "ObjectTypeProperty",
      key: h,
      value: d,
      variance: T,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, te = f.ObjectTypeProperty;
    return o(te.key, k, "key", h, 1), o(te.value, k, "value", d, 1), o(te.variance, k, "variance", T, 1), k;
  }
  function or(h) {
    const d = {
      type: "ObjectTypeSpreadProperty",
      argument: h
    }, T = f.ObjectTypeSpreadProperty;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function lr(h, d = null, T = null, k) {
    const te = {
      type: "OpaqueType",
      id: h,
      typeParameters: d,
      supertype: T,
      impltype: k
    }, Se = f.OpaqueType;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.supertype, te, "supertype", T, 1), o(Se.impltype, te, "impltype", k, 1), te;
  }
  function Tr(h, d) {
    const T = {
      type: "QualifiedTypeIdentifier",
      id: h,
      qualification: d
    }, k = f.QualifiedTypeIdentifier;
    return o(k.id, T, "id", h, 1), o(k.qualification, T, "qualification", d, 1), T;
  }
  function hi(h) {
    const d = {
      type: "StringLiteralTypeAnnotation",
      value: h
    }, T = f.StringLiteralTypeAnnotation;
    return o(T.value, d, "value", h), d;
  }
  function wt() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function di() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function mi() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function yi(h) {
    const d = {
      type: "TupleTypeAnnotation",
      types: h
    }, T = f.TupleTypeAnnotation;
    return o(T.types, d, "types", h, 1), d;
  }
  function Ve(h) {
    const d = {
      type: "TypeofTypeAnnotation",
      argument: h
    }, T = f.TypeofTypeAnnotation;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Ti(h, d = null, T) {
    const k = {
      type: "TypeAlias",
      id: h,
      typeParameters: d,
      right: T
    }, te = f.TypeAlias;
    return o(te.id, k, "id", h, 1), o(te.typeParameters, k, "typeParameters", d, 1), o(te.right, k, "right", T, 1), k;
  }
  function Lr(h) {
    const d = {
      type: "TypeAnnotation",
      typeAnnotation: h
    }, T = f.TypeAnnotation;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function Si(h, d) {
    const T = {
      type: "TypeCastExpression",
      expression: h,
      typeAnnotation: d
    }, k = f.TypeCastExpression;
    return o(k.expression, T, "expression", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function gi(h = null, d = null, T = null) {
    const k = {
      type: "TypeParameter",
      bound: h,
      default: d,
      variance: T,
      name: null
    }, te = f.TypeParameter;
    return o(te.bound, k, "bound", h, 1), o(te.default, k, "default", d, 1), o(te.variance, k, "variance", T, 1), k;
  }
  function bi(h) {
    const d = {
      type: "TypeParameterDeclaration",
      params: h
    }, T = f.TypeParameterDeclaration;
    return o(T.params, d, "params", h, 1), d;
  }
  function Ei(h) {
    const d = {
      type: "TypeParameterInstantiation",
      params: h
    }, T = f.TypeParameterInstantiation;
    return o(T.params, d, "params", h, 1), d;
  }
  function Pi(h) {
    const d = {
      type: "UnionTypeAnnotation",
      types: h
    }, T = f.UnionTypeAnnotation;
    return o(T.types, d, "types", h, 1), d;
  }
  function Bt(h) {
    const d = {
      type: "Variance",
      kind: h
    }, T = f.Variance;
    return o(T.kind, d, "kind", h), d;
  }
  function Dt() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function Yt(h, d) {
    const T = {
      type: "EnumDeclaration",
      id: h,
      body: d
    }, k = f.EnumDeclaration;
    return o(k.id, T, "id", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function xi(h) {
    const d = {
      type: "EnumBooleanBody",
      members: h,
      explicitType: null,
      hasUnknownMembers: null
    }, T = f.EnumBooleanBody;
    return o(T.members, d, "members", h, 1), d;
  }
  function vi(h) {
    const d = {
      type: "EnumNumberBody",
      members: h,
      explicitType: null,
      hasUnknownMembers: null
    }, T = f.EnumNumberBody;
    return o(T.members, d, "members", h, 1), d;
  }
  function Ai(h) {
    const d = {
      type: "EnumStringBody",
      members: h,
      explicitType: null,
      hasUnknownMembers: null
    }, T = f.EnumStringBody;
    return o(T.members, d, "members", h, 1), d;
  }
  function Mr(h) {
    const d = {
      type: "EnumSymbolBody",
      members: h,
      hasUnknownMembers: null
    }, T = f.EnumSymbolBody;
    return o(T.members, d, "members", h, 1), d;
  }
  function Ci(h) {
    const d = {
      type: "EnumBooleanMember",
      id: h,
      init: null
    }, T = f.EnumBooleanMember;
    return o(T.id, d, "id", h, 1), d;
  }
  function Ii(h, d) {
    const T = {
      type: "EnumNumberMember",
      id: h,
      init: d
    }, k = f.EnumNumberMember;
    return o(k.id, T, "id", h, 1), o(k.init, T, "init", d, 1), T;
  }
  function Br(h, d) {
    const T = {
      type: "EnumStringMember",
      id: h,
      init: d
    }, k = f.EnumStringMember;
    return o(k.id, T, "id", h, 1), o(k.init, T, "init", d, 1), T;
  }
  function Fe(h) {
    const d = {
      type: "EnumDefaultedMember",
      id: h
    }, T = f.EnumDefaultedMember;
    return o(T.id, d, "id", h, 1), d;
  }
  function wi(h, d) {
    const T = {
      type: "IndexedAccessType",
      objectType: h,
      indexType: d
    }, k = f.IndexedAccessType;
    return o(k.objectType, T, "objectType", h, 1), o(k.indexType, T, "indexType", d, 1), T;
  }
  function Fr(h, d) {
    const T = {
      type: "OptionalIndexedAccessType",
      objectType: h,
      indexType: d,
      optional: null
    }, k = f.OptionalIndexedAccessType;
    return o(k.objectType, T, "objectType", h, 1), o(k.indexType, T, "indexType", d, 1), T;
  }
  function Oi(h, d = null) {
    const T = {
      type: "JSXAttribute",
      name: h,
      value: d
    }, k = f.JSXAttribute;
    return o(k.name, T, "name", h, 1), o(k.value, T, "value", d, 1), T;
  }
  function Ni(h) {
    const d = {
      type: "JSXClosingElement",
      name: h
    }, T = f.JSXClosingElement;
    return o(T.name, d, "name", h, 1), d;
  }
  function _i(h, d = null, T, k = null) {
    const te = {
      type: "JSXElement",
      openingElement: h,
      closingElement: d,
      children: T,
      selfClosing: k
    }, Se = f.JSXElement;
    return o(Se.openingElement, te, "openingElement", h, 1), o(Se.closingElement, te, "closingElement", d, 1), o(Se.children, te, "children", T, 1), o(Se.selfClosing, te, "selfClosing", k), te;
  }
  function Di() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function Rr(h) {
    const d = {
      type: "JSXExpressionContainer",
      expression: h
    }, T = f.JSXExpressionContainer;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function ki(h) {
    const d = {
      type: "JSXSpreadChild",
      expression: h
    }, T = f.JSXSpreadChild;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function jr(h) {
    const d = {
      type: "JSXIdentifier",
      name: h
    }, T = f.JSXIdentifier;
    return o(T.name, d, "name", h), d;
  }
  function qr(h, d) {
    const T = {
      type: "JSXMemberExpression",
      object: h,
      property: d
    }, k = f.JSXMemberExpression;
    return o(k.object, T, "object", h, 1), o(k.property, T, "property", d, 1), T;
  }
  function Li(h, d) {
    const T = {
      type: "JSXNamespacedName",
      namespace: h,
      name: d
    }, k = f.JSXNamespacedName;
    return o(k.namespace, T, "namespace", h, 1), o(k.name, T, "name", d, 1), T;
  }
  function Mi(h, d, T = !1) {
    const k = {
      type: "JSXOpeningElement",
      name: h,
      attributes: d,
      selfClosing: T
    }, te = f.JSXOpeningElement;
    return o(te.name, k, "name", h, 1), o(te.attributes, k, "attributes", d, 1), o(te.selfClosing, k, "selfClosing", T), k;
  }
  function Ur(h) {
    const d = {
      type: "JSXSpreadAttribute",
      argument: h
    }, T = f.JSXSpreadAttribute;
    return o(T.argument, d, "argument", h, 1), d;
  }
  function Vr(h) {
    const d = {
      type: "JSXText",
      value: h
    }, T = f.JSXText;
    return o(T.value, d, "value", h), d;
  }
  function Bi(h, d, T) {
    const k = {
      type: "JSXFragment",
      openingFragment: h,
      closingFragment: d,
      children: T
    }, te = f.JSXFragment;
    return o(te.openingFragment, k, "openingFragment", h, 1), o(te.closingFragment, k, "closingFragment", d, 1), o(te.children, k, "children", T, 1), k;
  }
  function Kr() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function Fi() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function Ri() {
    return {
      type: "Noop"
    };
  }
  function Sr(h, d) {
    const T = {
      type: "Placeholder",
      expectedNode: h,
      name: d
    }, k = f.Placeholder;
    return o(k.expectedNode, T, "expectedNode", h), o(k.name, T, "name", d, 1), T;
  }
  function ji(h) {
    const d = {
      type: "V8IntrinsicIdentifier",
      name: h
    }, T = f.V8IntrinsicIdentifier;
    return o(T.name, d, "name", h), d;
  }
  function qi() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function gr(h, d) {
    const T = {
      type: "BindExpression",
      object: h,
      callee: d
    }, k = f.BindExpression;
    return o(k.object, T, "object", h, 1), o(k.callee, T, "callee", d, 1), T;
  }
  function Ui(h, d) {
    const T = {
      type: "ImportAttribute",
      key: h,
      value: d
    }, k = f.ImportAttribute;
    return o(k.key, T, "key", h, 1), o(k.value, T, "value", d, 1), T;
  }
  function Vi(h) {
    const d = {
      type: "Decorator",
      expression: h
    }, T = f.Decorator;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function Wr(h, d = !1) {
    const T = {
      type: "DoExpression",
      body: h,
      async: d
    }, k = f.DoExpression;
    return o(k.body, T, "body", h, 1), o(k.async, T, "async", d), T;
  }
  function Ki(h) {
    const d = {
      type: "ExportDefaultSpecifier",
      exported: h
    }, T = f.ExportDefaultSpecifier;
    return o(T.exported, d, "exported", h, 1), d;
  }
  function Wi(h) {
    const d = {
      type: "RecordExpression",
      properties: h
    }, T = f.RecordExpression;
    return o(T.properties, d, "properties", h, 1), d;
  }
  function $i(h = []) {
    const d = {
      type: "TupleExpression",
      elements: h
    }, T = f.TupleExpression;
    return o(T.elements, d, "elements", h, 1), d;
  }
  function Ji(h) {
    const d = {
      type: "DecimalLiteral",
      value: h
    }, T = f.DecimalLiteral;
    return o(T.value, d, "value", h), d;
  }
  function Qt(h) {
    const d = {
      type: "ModuleExpression",
      body: h
    }, T = f.ModuleExpression;
    return o(T.body, d, "body", h, 1), d;
  }
  function $r() {
    return {
      type: "TopicReference"
    };
  }
  function Xi(h) {
    const d = {
      type: "PipelineTopicExpression",
      expression: h
    }, T = f.PipelineTopicExpression;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function b(h) {
    const d = {
      type: "PipelineBareFunction",
      callee: h
    }, T = f.PipelineBareFunction;
    return o(T.callee, d, "callee", h, 1), d;
  }
  function t() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function e(h) {
    const d = {
      type: "TSParameterProperty",
      parameter: h
    }, T = f.TSParameterProperty;
    return o(T.parameter, d, "parameter", h, 1), d;
  }
  function r(h = null, d = null, T, k = null) {
    const te = {
      type: "TSDeclareFunction",
      id: h,
      typeParameters: d,
      params: T,
      returnType: k
    }, Se = f.TSDeclareFunction;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.params, te, "params", T, 1), o(Se.returnType, te, "returnType", k, 1), te;
  }
  function a(h = null, d, T = null, k, te = null) {
    const Se = {
      type: "TSDeclareMethod",
      decorators: h,
      key: d,
      typeParameters: T,
      params: k,
      returnType: te
    }, je = f.TSDeclareMethod;
    return o(je.decorators, Se, "decorators", h, 1), o(je.key, Se, "key", d, 1), o(je.typeParameters, Se, "typeParameters", T, 1), o(je.params, Se, "params", k, 1), o(je.returnType, Se, "returnType", te, 1), Se;
  }
  function c(h, d) {
    const T = {
      type: "TSQualifiedName",
      left: h,
      right: d
    }, k = f.TSQualifiedName;
    return o(k.left, T, "left", h, 1), o(k.right, T, "right", d, 1), T;
  }
  function E(h = null, d, T = null) {
    const k = {
      type: "TSCallSignatureDeclaration",
      typeParameters: h,
      parameters: d,
      typeAnnotation: T
    }, te = f.TSCallSignatureDeclaration;
    return o(te.typeParameters, k, "typeParameters", h, 1), o(te.parameters, k, "parameters", d, 1), o(te.typeAnnotation, k, "typeAnnotation", T, 1), k;
  }
  function M(h = null, d, T = null) {
    const k = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: h,
      parameters: d,
      typeAnnotation: T
    }, te = f.TSConstructSignatureDeclaration;
    return o(te.typeParameters, k, "typeParameters", h, 1), o(te.parameters, k, "parameters", d, 1), o(te.typeAnnotation, k, "typeAnnotation", T, 1), k;
  }
  function Y(h, d = null) {
    const T = {
      type: "TSPropertySignature",
      key: h,
      typeAnnotation: d
    }, k = f.TSPropertySignature;
    return o(k.key, T, "key", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function se(h, d = null, T, k = null) {
    const te = {
      type: "TSMethodSignature",
      key: h,
      typeParameters: d,
      parameters: T,
      typeAnnotation: k,
      kind: null
    }, Se = f.TSMethodSignature;
    return o(Se.key, te, "key", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.parameters, te, "parameters", T, 1), o(Se.typeAnnotation, te, "typeAnnotation", k, 1), te;
  }
  function ue(h, d = null) {
    const T = {
      type: "TSIndexSignature",
      parameters: h,
      typeAnnotation: d
    }, k = f.TSIndexSignature;
    return o(k.parameters, T, "parameters", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function Ee() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function _e() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function ke() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function Re() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function Qe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function mt() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tt() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function ut() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function ur() {
    return {
      type: "TSStringKeyword"
    };
  }
  function Zt() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function un() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function cn() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function pn() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function fn() {
    return {
      type: "TSThisType"
    };
  }
  function hn(h = null, d, T = null) {
    const k = {
      type: "TSFunctionType",
      typeParameters: h,
      parameters: d,
      typeAnnotation: T
    }, te = f.TSFunctionType;
    return o(te.typeParameters, k, "typeParameters", h, 1), o(te.parameters, k, "parameters", d, 1), o(te.typeAnnotation, k, "typeAnnotation", T, 1), k;
  }
  function dn(h = null, d, T = null) {
    const k = {
      type: "TSConstructorType",
      typeParameters: h,
      parameters: d,
      typeAnnotation: T
    }, te = f.TSConstructorType;
    return o(te.typeParameters, k, "typeParameters", h, 1), o(te.parameters, k, "parameters", d, 1), o(te.typeAnnotation, k, "typeAnnotation", T, 1), k;
  }
  function mn(h, d = null) {
    const T = {
      type: "TSTypeReference",
      typeName: h,
      typeParameters: d
    }, k = f.TSTypeReference;
    return o(k.typeName, T, "typeName", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function yn(h, d = null, T = null) {
    const k = {
      type: "TSTypePredicate",
      parameterName: h,
      typeAnnotation: d,
      asserts: T
    }, te = f.TSTypePredicate;
    return o(te.parameterName, k, "parameterName", h, 1), o(te.typeAnnotation, k, "typeAnnotation", d, 1), o(te.asserts, k, "asserts", T), k;
  }
  function Tn(h, d = null) {
    const T = {
      type: "TSTypeQuery",
      exprName: h,
      typeParameters: d
    }, k = f.TSTypeQuery;
    return o(k.exprName, T, "exprName", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function Sn(h) {
    const d = {
      type: "TSTypeLiteral",
      members: h
    }, T = f.TSTypeLiteral;
    return o(T.members, d, "members", h, 1), d;
  }
  function gn(h) {
    const d = {
      type: "TSArrayType",
      elementType: h
    }, T = f.TSArrayType;
    return o(T.elementType, d, "elementType", h, 1), d;
  }
  function bn(h) {
    const d = {
      type: "TSTupleType",
      elementTypes: h
    }, T = f.TSTupleType;
    return o(T.elementTypes, d, "elementTypes", h, 1), d;
  }
  function En(h) {
    const d = {
      type: "TSOptionalType",
      typeAnnotation: h
    }, T = f.TSOptionalType;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function Pn(h) {
    const d = {
      type: "TSRestType",
      typeAnnotation: h
    }, T = f.TSRestType;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function xn(h, d, T = !1) {
    const k = {
      type: "TSNamedTupleMember",
      label: h,
      elementType: d,
      optional: T
    }, te = f.TSNamedTupleMember;
    return o(te.label, k, "label", h, 1), o(te.elementType, k, "elementType", d, 1), o(te.optional, k, "optional", T), k;
  }
  function vn(h) {
    const d = {
      type: "TSUnionType",
      types: h
    }, T = f.TSUnionType;
    return o(T.types, d, "types", h, 1), d;
  }
  function An(h) {
    const d = {
      type: "TSIntersectionType",
      types: h
    }, T = f.TSIntersectionType;
    return o(T.types, d, "types", h, 1), d;
  }
  function Cn(h, d, T, k) {
    const te = {
      type: "TSConditionalType",
      checkType: h,
      extendsType: d,
      trueType: T,
      falseType: k
    }, Se = f.TSConditionalType;
    return o(Se.checkType, te, "checkType", h, 1), o(Se.extendsType, te, "extendsType", d, 1), o(Se.trueType, te, "trueType", T, 1), o(Se.falseType, te, "falseType", k, 1), te;
  }
  function In(h) {
    const d = {
      type: "TSInferType",
      typeParameter: h
    }, T = f.TSInferType;
    return o(T.typeParameter, d, "typeParameter", h, 1), d;
  }
  function wn(h) {
    const d = {
      type: "TSParenthesizedType",
      typeAnnotation: h
    }, T = f.TSParenthesizedType;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function On(h) {
    const d = {
      type: "TSTypeOperator",
      typeAnnotation: h,
      operator: null
    }, T = f.TSTypeOperator;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function Nn(h, d) {
    const T = {
      type: "TSIndexedAccessType",
      objectType: h,
      indexType: d
    }, k = f.TSIndexedAccessType;
    return o(k.objectType, T, "objectType", h, 1), o(k.indexType, T, "indexType", d, 1), T;
  }
  function _n(h, d = null, T = null) {
    const k = {
      type: "TSMappedType",
      typeParameter: h,
      typeAnnotation: d,
      nameType: T
    }, te = f.TSMappedType;
    return o(te.typeParameter, k, "typeParameter", h, 1), o(te.typeAnnotation, k, "typeAnnotation", d, 1), o(te.nameType, k, "nameType", T, 1), k;
  }
  function Dn(h, d) {
    const T = {
      type: "TSTemplateLiteralType",
      quasis: h,
      types: d
    }, k = f.TSTemplateLiteralType;
    return o(k.quasis, T, "quasis", h, 1), o(k.types, T, "types", d, 1), T;
  }
  function kn(h) {
    const d = {
      type: "TSLiteralType",
      literal: h
    }, T = f.TSLiteralType;
    return o(T.literal, d, "literal", h, 1), d;
  }
  function Ln(h, d = null) {
    const T = {
      type: "TSExpressionWithTypeArguments",
      expression: h,
      typeParameters: d
    }, k = f.TSExpressionWithTypeArguments;
    return o(k.expression, T, "expression", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function Mn(h, d = null, T = null, k) {
    const te = {
      type: "TSInterfaceDeclaration",
      id: h,
      typeParameters: d,
      extends: T,
      body: k
    }, Se = f.TSInterfaceDeclaration;
    return o(Se.id, te, "id", h, 1), o(Se.typeParameters, te, "typeParameters", d, 1), o(Se.extends, te, "extends", T, 1), o(Se.body, te, "body", k, 1), te;
  }
  function Bn(h) {
    const d = {
      type: "TSInterfaceBody",
      body: h
    }, T = f.TSInterfaceBody;
    return o(T.body, d, "body", h, 1), d;
  }
  function Fn(h, d = null, T) {
    const k = {
      type: "TSTypeAliasDeclaration",
      id: h,
      typeParameters: d,
      typeAnnotation: T
    }, te = f.TSTypeAliasDeclaration;
    return o(te.id, k, "id", h, 1), o(te.typeParameters, k, "typeParameters", d, 1), o(te.typeAnnotation, k, "typeAnnotation", T, 1), k;
  }
  function Rn(h, d = null) {
    const T = {
      type: "TSInstantiationExpression",
      expression: h,
      typeParameters: d
    }, k = f.TSInstantiationExpression;
    return o(k.expression, T, "expression", h, 1), o(k.typeParameters, T, "typeParameters", d, 1), T;
  }
  function jn(h, d) {
    const T = {
      type: "TSAsExpression",
      expression: h,
      typeAnnotation: d
    }, k = f.TSAsExpression;
    return o(k.expression, T, "expression", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function qn(h, d) {
    const T = {
      type: "TSSatisfiesExpression",
      expression: h,
      typeAnnotation: d
    }, k = f.TSSatisfiesExpression;
    return o(k.expression, T, "expression", h, 1), o(k.typeAnnotation, T, "typeAnnotation", d, 1), T;
  }
  function Un(h, d) {
    const T = {
      type: "TSTypeAssertion",
      typeAnnotation: h,
      expression: d
    }, k = f.TSTypeAssertion;
    return o(k.typeAnnotation, T, "typeAnnotation", h, 1), o(k.expression, T, "expression", d, 1), T;
  }
  function Vn(h) {
    const d = {
      type: "TSEnumBody",
      members: h
    }, T = f.TSEnumBody;
    return o(T.members, d, "members", h, 1), d;
  }
  function Kn(h, d) {
    const T = {
      type: "TSEnumDeclaration",
      id: h,
      members: d
    }, k = f.TSEnumDeclaration;
    return o(k.id, T, "id", h, 1), o(k.members, T, "members", d, 1), T;
  }
  function Wn(h, d = null) {
    const T = {
      type: "TSEnumMember",
      id: h,
      initializer: d
    }, k = f.TSEnumMember;
    return o(k.id, T, "id", h, 1), o(k.initializer, T, "initializer", d, 1), T;
  }
  function $n(h, d) {
    const T = {
      type: "TSModuleDeclaration",
      id: h,
      body: d,
      kind: null
    }, k = f.TSModuleDeclaration;
    return o(k.id, T, "id", h, 1), o(k.body, T, "body", d, 1), T;
  }
  function Jn(h) {
    const d = {
      type: "TSModuleBlock",
      body: h
    }, T = f.TSModuleBlock;
    return o(T.body, d, "body", h, 1), d;
  }
  function Xn(h, d = null, T = null) {
    const k = {
      type: "TSImportType",
      argument: h,
      qualifier: d,
      typeParameters: T
    }, te = f.TSImportType;
    return o(te.argument, k, "argument", h, 1), o(te.qualifier, k, "qualifier", d, 1), o(te.typeParameters, k, "typeParameters", T, 1), k;
  }
  function Yn(h, d) {
    const T = {
      type: "TSImportEqualsDeclaration",
      id: h,
      moduleReference: d,
      isExport: null
    }, k = f.TSImportEqualsDeclaration;
    return o(k.id, T, "id", h, 1), o(k.moduleReference, T, "moduleReference", d, 1), T;
  }
  function Hn(h) {
    const d = {
      type: "TSExternalModuleReference",
      expression: h
    }, T = f.TSExternalModuleReference;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function Gn(h) {
    const d = {
      type: "TSNonNullExpression",
      expression: h
    }, T = f.TSNonNullExpression;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function zn(h) {
    const d = {
      type: "TSExportAssignment",
      expression: h
    }, T = f.TSExportAssignment;
    return o(T.expression, d, "expression", h, 1), d;
  }
  function Qn(h) {
    const d = {
      type: "TSNamespaceExportDeclaration",
      id: h
    }, T = f.TSNamespaceExportDeclaration;
    return o(T.id, d, "id", h, 1), d;
  }
  function Zn(h) {
    const d = {
      type: "TSTypeAnnotation",
      typeAnnotation: h
    }, T = f.TSTypeAnnotation;
    return o(T.typeAnnotation, d, "typeAnnotation", h, 1), d;
  }
  function es(h) {
    const d = {
      type: "TSTypeParameterInstantiation",
      params: h
    }, T = f.TSTypeParameterInstantiation;
    return o(T.params, d, "params", h, 1), d;
  }
  function ts(h) {
    const d = {
      type: "TSTypeParameterDeclaration",
      params: h
    }, T = f.TSTypeParameterDeclaration;
    return o(T.params, d, "params", h, 1), d;
  }
  function rs(h = null, d = null, T) {
    const k = {
      type: "TSTypeParameter",
      constraint: h,
      default: d,
      name: T
    }, te = f.TSTypeParameter;
    return o(te.constraint, k, "constraint", h, 1), o(te.default, k, "default", d, 1), o(te.name, k, "name", T), k;
  }
  function is(h) {
    return (0, l.default)("NumberLiteral", "NumericLiteral", "The node type "), Q(h);
  }
  function ns(h, d = "") {
    return (0, l.default)("RegexLiteral", "RegExpLiteral", "The node type "), R(h, d);
  }
  function ss(h) {
    return (0, l.default)("RestProperty", "RestElement", "The node type "), Ne(h);
  }
  function as(h) {
    return (0, l.default)("SpreadProperty", "SpreadElement", "The node type "), K(h);
  }
  return U;
}
var Go = {}, Ql;
function yf() {
  return Ql || (Ql = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), Object.defineProperty(i, "AnyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.anyTypeAnnotation;
      }
    }), Object.defineProperty(i, "ArgumentPlaceholder", {
      enumerable: !0,
      get: function() {
        return l.argumentPlaceholder;
      }
    }), Object.defineProperty(i, "ArrayExpression", {
      enumerable: !0,
      get: function() {
        return l.arrayExpression;
      }
    }), Object.defineProperty(i, "ArrayPattern", {
      enumerable: !0,
      get: function() {
        return l.arrayPattern;
      }
    }), Object.defineProperty(i, "ArrayTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.arrayTypeAnnotation;
      }
    }), Object.defineProperty(i, "ArrowFunctionExpression", {
      enumerable: !0,
      get: function() {
        return l.arrowFunctionExpression;
      }
    }), Object.defineProperty(i, "AssignmentExpression", {
      enumerable: !0,
      get: function() {
        return l.assignmentExpression;
      }
    }), Object.defineProperty(i, "AssignmentPattern", {
      enumerable: !0,
      get: function() {
        return l.assignmentPattern;
      }
    }), Object.defineProperty(i, "AwaitExpression", {
      enumerable: !0,
      get: function() {
        return l.awaitExpression;
      }
    }), Object.defineProperty(i, "BigIntLiteral", {
      enumerable: !0,
      get: function() {
        return l.bigIntLiteral;
      }
    }), Object.defineProperty(i, "BinaryExpression", {
      enumerable: !0,
      get: function() {
        return l.binaryExpression;
      }
    }), Object.defineProperty(i, "BindExpression", {
      enumerable: !0,
      get: function() {
        return l.bindExpression;
      }
    }), Object.defineProperty(i, "BlockStatement", {
      enumerable: !0,
      get: function() {
        return l.blockStatement;
      }
    }), Object.defineProperty(i, "BooleanLiteral", {
      enumerable: !0,
      get: function() {
        return l.booleanLiteral;
      }
    }), Object.defineProperty(i, "BooleanLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.booleanLiteralTypeAnnotation;
      }
    }), Object.defineProperty(i, "BooleanTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.booleanTypeAnnotation;
      }
    }), Object.defineProperty(i, "BreakStatement", {
      enumerable: !0,
      get: function() {
        return l.breakStatement;
      }
    }), Object.defineProperty(i, "CallExpression", {
      enumerable: !0,
      get: function() {
        return l.callExpression;
      }
    }), Object.defineProperty(i, "CatchClause", {
      enumerable: !0,
      get: function() {
        return l.catchClause;
      }
    }), Object.defineProperty(i, "ClassAccessorProperty", {
      enumerable: !0,
      get: function() {
        return l.classAccessorProperty;
      }
    }), Object.defineProperty(i, "ClassBody", {
      enumerable: !0,
      get: function() {
        return l.classBody;
      }
    }), Object.defineProperty(i, "ClassDeclaration", {
      enumerable: !0,
      get: function() {
        return l.classDeclaration;
      }
    }), Object.defineProperty(i, "ClassExpression", {
      enumerable: !0,
      get: function() {
        return l.classExpression;
      }
    }), Object.defineProperty(i, "ClassImplements", {
      enumerable: !0,
      get: function() {
        return l.classImplements;
      }
    }), Object.defineProperty(i, "ClassMethod", {
      enumerable: !0,
      get: function() {
        return l.classMethod;
      }
    }), Object.defineProperty(i, "ClassPrivateMethod", {
      enumerable: !0,
      get: function() {
        return l.classPrivateMethod;
      }
    }), Object.defineProperty(i, "ClassPrivateProperty", {
      enumerable: !0,
      get: function() {
        return l.classPrivateProperty;
      }
    }), Object.defineProperty(i, "ClassProperty", {
      enumerable: !0,
      get: function() {
        return l.classProperty;
      }
    }), Object.defineProperty(i, "ConditionalExpression", {
      enumerable: !0,
      get: function() {
        return l.conditionalExpression;
      }
    }), Object.defineProperty(i, "ContinueStatement", {
      enumerable: !0,
      get: function() {
        return l.continueStatement;
      }
    }), Object.defineProperty(i, "DebuggerStatement", {
      enumerable: !0,
      get: function() {
        return l.debuggerStatement;
      }
    }), Object.defineProperty(i, "DecimalLiteral", {
      enumerable: !0,
      get: function() {
        return l.decimalLiteral;
      }
    }), Object.defineProperty(i, "DeclareClass", {
      enumerable: !0,
      get: function() {
        return l.declareClass;
      }
    }), Object.defineProperty(i, "DeclareExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return l.declareExportAllDeclaration;
      }
    }), Object.defineProperty(i, "DeclareExportDeclaration", {
      enumerable: !0,
      get: function() {
        return l.declareExportDeclaration;
      }
    }), Object.defineProperty(i, "DeclareFunction", {
      enumerable: !0,
      get: function() {
        return l.declareFunction;
      }
    }), Object.defineProperty(i, "DeclareInterface", {
      enumerable: !0,
      get: function() {
        return l.declareInterface;
      }
    }), Object.defineProperty(i, "DeclareModule", {
      enumerable: !0,
      get: function() {
        return l.declareModule;
      }
    }), Object.defineProperty(i, "DeclareModuleExports", {
      enumerable: !0,
      get: function() {
        return l.declareModuleExports;
      }
    }), Object.defineProperty(i, "DeclareOpaqueType", {
      enumerable: !0,
      get: function() {
        return l.declareOpaqueType;
      }
    }), Object.defineProperty(i, "DeclareTypeAlias", {
      enumerable: !0,
      get: function() {
        return l.declareTypeAlias;
      }
    }), Object.defineProperty(i, "DeclareVariable", {
      enumerable: !0,
      get: function() {
        return l.declareVariable;
      }
    }), Object.defineProperty(i, "DeclaredPredicate", {
      enumerable: !0,
      get: function() {
        return l.declaredPredicate;
      }
    }), Object.defineProperty(i, "Decorator", {
      enumerable: !0,
      get: function() {
        return l.decorator;
      }
    }), Object.defineProperty(i, "Directive", {
      enumerable: !0,
      get: function() {
        return l.directive;
      }
    }), Object.defineProperty(i, "DirectiveLiteral", {
      enumerable: !0,
      get: function() {
        return l.directiveLiteral;
      }
    }), Object.defineProperty(i, "DoExpression", {
      enumerable: !0,
      get: function() {
        return l.doExpression;
      }
    }), Object.defineProperty(i, "DoWhileStatement", {
      enumerable: !0,
      get: function() {
        return l.doWhileStatement;
      }
    }), Object.defineProperty(i, "EmptyStatement", {
      enumerable: !0,
      get: function() {
        return l.emptyStatement;
      }
    }), Object.defineProperty(i, "EmptyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.emptyTypeAnnotation;
      }
    }), Object.defineProperty(i, "EnumBooleanBody", {
      enumerable: !0,
      get: function() {
        return l.enumBooleanBody;
      }
    }), Object.defineProperty(i, "EnumBooleanMember", {
      enumerable: !0,
      get: function() {
        return l.enumBooleanMember;
      }
    }), Object.defineProperty(i, "EnumDeclaration", {
      enumerable: !0,
      get: function() {
        return l.enumDeclaration;
      }
    }), Object.defineProperty(i, "EnumDefaultedMember", {
      enumerable: !0,
      get: function() {
        return l.enumDefaultedMember;
      }
    }), Object.defineProperty(i, "EnumNumberBody", {
      enumerable: !0,
      get: function() {
        return l.enumNumberBody;
      }
    }), Object.defineProperty(i, "EnumNumberMember", {
      enumerable: !0,
      get: function() {
        return l.enumNumberMember;
      }
    }), Object.defineProperty(i, "EnumStringBody", {
      enumerable: !0,
      get: function() {
        return l.enumStringBody;
      }
    }), Object.defineProperty(i, "EnumStringMember", {
      enumerable: !0,
      get: function() {
        return l.enumStringMember;
      }
    }), Object.defineProperty(i, "EnumSymbolBody", {
      enumerable: !0,
      get: function() {
        return l.enumSymbolBody;
      }
    }), Object.defineProperty(i, "ExistsTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.existsTypeAnnotation;
      }
    }), Object.defineProperty(i, "ExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return l.exportAllDeclaration;
      }
    }), Object.defineProperty(i, "ExportDefaultDeclaration", {
      enumerable: !0,
      get: function() {
        return l.exportDefaultDeclaration;
      }
    }), Object.defineProperty(i, "ExportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return l.exportDefaultSpecifier;
      }
    }), Object.defineProperty(i, "ExportNamedDeclaration", {
      enumerable: !0,
      get: function() {
        return l.exportNamedDeclaration;
      }
    }), Object.defineProperty(i, "ExportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return l.exportNamespaceSpecifier;
      }
    }), Object.defineProperty(i, "ExportSpecifier", {
      enumerable: !0,
      get: function() {
        return l.exportSpecifier;
      }
    }), Object.defineProperty(i, "ExpressionStatement", {
      enumerable: !0,
      get: function() {
        return l.expressionStatement;
      }
    }), Object.defineProperty(i, "File", {
      enumerable: !0,
      get: function() {
        return l.file;
      }
    }), Object.defineProperty(i, "ForInStatement", {
      enumerable: !0,
      get: function() {
        return l.forInStatement;
      }
    }), Object.defineProperty(i, "ForOfStatement", {
      enumerable: !0,
      get: function() {
        return l.forOfStatement;
      }
    }), Object.defineProperty(i, "ForStatement", {
      enumerable: !0,
      get: function() {
        return l.forStatement;
      }
    }), Object.defineProperty(i, "FunctionDeclaration", {
      enumerable: !0,
      get: function() {
        return l.functionDeclaration;
      }
    }), Object.defineProperty(i, "FunctionExpression", {
      enumerable: !0,
      get: function() {
        return l.functionExpression;
      }
    }), Object.defineProperty(i, "FunctionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.functionTypeAnnotation;
      }
    }), Object.defineProperty(i, "FunctionTypeParam", {
      enumerable: !0,
      get: function() {
        return l.functionTypeParam;
      }
    }), Object.defineProperty(i, "GenericTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.genericTypeAnnotation;
      }
    }), Object.defineProperty(i, "Identifier", {
      enumerable: !0,
      get: function() {
        return l.identifier;
      }
    }), Object.defineProperty(i, "IfStatement", {
      enumerable: !0,
      get: function() {
        return l.ifStatement;
      }
    }), Object.defineProperty(i, "Import", {
      enumerable: !0,
      get: function() {
        return l.import;
      }
    }), Object.defineProperty(i, "ImportAttribute", {
      enumerable: !0,
      get: function() {
        return l.importAttribute;
      }
    }), Object.defineProperty(i, "ImportDeclaration", {
      enumerable: !0,
      get: function() {
        return l.importDeclaration;
      }
    }), Object.defineProperty(i, "ImportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return l.importDefaultSpecifier;
      }
    }), Object.defineProperty(i, "ImportExpression", {
      enumerable: !0,
      get: function() {
        return l.importExpression;
      }
    }), Object.defineProperty(i, "ImportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return l.importNamespaceSpecifier;
      }
    }), Object.defineProperty(i, "ImportSpecifier", {
      enumerable: !0,
      get: function() {
        return l.importSpecifier;
      }
    }), Object.defineProperty(i, "IndexedAccessType", {
      enumerable: !0,
      get: function() {
        return l.indexedAccessType;
      }
    }), Object.defineProperty(i, "InferredPredicate", {
      enumerable: !0,
      get: function() {
        return l.inferredPredicate;
      }
    }), Object.defineProperty(i, "InterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return l.interfaceDeclaration;
      }
    }), Object.defineProperty(i, "InterfaceExtends", {
      enumerable: !0,
      get: function() {
        return l.interfaceExtends;
      }
    }), Object.defineProperty(i, "InterfaceTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.interfaceTypeAnnotation;
      }
    }), Object.defineProperty(i, "InterpreterDirective", {
      enumerable: !0,
      get: function() {
        return l.interpreterDirective;
      }
    }), Object.defineProperty(i, "IntersectionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.intersectionTypeAnnotation;
      }
    }), Object.defineProperty(i, "JSXAttribute", {
      enumerable: !0,
      get: function() {
        return l.jsxAttribute;
      }
    }), Object.defineProperty(i, "JSXClosingElement", {
      enumerable: !0,
      get: function() {
        return l.jsxClosingElement;
      }
    }), Object.defineProperty(i, "JSXClosingFragment", {
      enumerable: !0,
      get: function() {
        return l.jsxClosingFragment;
      }
    }), Object.defineProperty(i, "JSXElement", {
      enumerable: !0,
      get: function() {
        return l.jsxElement;
      }
    }), Object.defineProperty(i, "JSXEmptyExpression", {
      enumerable: !0,
      get: function() {
        return l.jsxEmptyExpression;
      }
    }), Object.defineProperty(i, "JSXExpressionContainer", {
      enumerable: !0,
      get: function() {
        return l.jsxExpressionContainer;
      }
    }), Object.defineProperty(i, "JSXFragment", {
      enumerable: !0,
      get: function() {
        return l.jsxFragment;
      }
    }), Object.defineProperty(i, "JSXIdentifier", {
      enumerable: !0,
      get: function() {
        return l.jsxIdentifier;
      }
    }), Object.defineProperty(i, "JSXMemberExpression", {
      enumerable: !0,
      get: function() {
        return l.jsxMemberExpression;
      }
    }), Object.defineProperty(i, "JSXNamespacedName", {
      enumerable: !0,
      get: function() {
        return l.jsxNamespacedName;
      }
    }), Object.defineProperty(i, "JSXOpeningElement", {
      enumerable: !0,
      get: function() {
        return l.jsxOpeningElement;
      }
    }), Object.defineProperty(i, "JSXOpeningFragment", {
      enumerable: !0,
      get: function() {
        return l.jsxOpeningFragment;
      }
    }), Object.defineProperty(i, "JSXSpreadAttribute", {
      enumerable: !0,
      get: function() {
        return l.jsxSpreadAttribute;
      }
    }), Object.defineProperty(i, "JSXSpreadChild", {
      enumerable: !0,
      get: function() {
        return l.jsxSpreadChild;
      }
    }), Object.defineProperty(i, "JSXText", {
      enumerable: !0,
      get: function() {
        return l.jsxText;
      }
    }), Object.defineProperty(i, "LabeledStatement", {
      enumerable: !0,
      get: function() {
        return l.labeledStatement;
      }
    }), Object.defineProperty(i, "LogicalExpression", {
      enumerable: !0,
      get: function() {
        return l.logicalExpression;
      }
    }), Object.defineProperty(i, "MemberExpression", {
      enumerable: !0,
      get: function() {
        return l.memberExpression;
      }
    }), Object.defineProperty(i, "MetaProperty", {
      enumerable: !0,
      get: function() {
        return l.metaProperty;
      }
    }), Object.defineProperty(i, "MixedTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.mixedTypeAnnotation;
      }
    }), Object.defineProperty(i, "ModuleExpression", {
      enumerable: !0,
      get: function() {
        return l.moduleExpression;
      }
    }), Object.defineProperty(i, "NewExpression", {
      enumerable: !0,
      get: function() {
        return l.newExpression;
      }
    }), Object.defineProperty(i, "Noop", {
      enumerable: !0,
      get: function() {
        return l.noop;
      }
    }), Object.defineProperty(i, "NullLiteral", {
      enumerable: !0,
      get: function() {
        return l.nullLiteral;
      }
    }), Object.defineProperty(i, "NullLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.nullLiteralTypeAnnotation;
      }
    }), Object.defineProperty(i, "NullableTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.nullableTypeAnnotation;
      }
    }), Object.defineProperty(i, "NumberLiteral", {
      enumerable: !0,
      get: function() {
        return l.numberLiteral;
      }
    }), Object.defineProperty(i, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.numberLiteralTypeAnnotation;
      }
    }), Object.defineProperty(i, "NumberTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.numberTypeAnnotation;
      }
    }), Object.defineProperty(i, "NumericLiteral", {
      enumerable: !0,
      get: function() {
        return l.numericLiteral;
      }
    }), Object.defineProperty(i, "ObjectExpression", {
      enumerable: !0,
      get: function() {
        return l.objectExpression;
      }
    }), Object.defineProperty(i, "ObjectMethod", {
      enumerable: !0,
      get: function() {
        return l.objectMethod;
      }
    }), Object.defineProperty(i, "ObjectPattern", {
      enumerable: !0,
      get: function() {
        return l.objectPattern;
      }
    }), Object.defineProperty(i, "ObjectProperty", {
      enumerable: !0,
      get: function() {
        return l.objectProperty;
      }
    }), Object.defineProperty(i, "ObjectTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.objectTypeAnnotation;
      }
    }), Object.defineProperty(i, "ObjectTypeCallProperty", {
      enumerable: !0,
      get: function() {
        return l.objectTypeCallProperty;
      }
    }), Object.defineProperty(i, "ObjectTypeIndexer", {
      enumerable: !0,
      get: function() {
        return l.objectTypeIndexer;
      }
    }), Object.defineProperty(i, "ObjectTypeInternalSlot", {
      enumerable: !0,
      get: function() {
        return l.objectTypeInternalSlot;
      }
    }), Object.defineProperty(i, "ObjectTypeProperty", {
      enumerable: !0,
      get: function() {
        return l.objectTypeProperty;
      }
    }), Object.defineProperty(i, "ObjectTypeSpreadProperty", {
      enumerable: !0,
      get: function() {
        return l.objectTypeSpreadProperty;
      }
    }), Object.defineProperty(i, "OpaqueType", {
      enumerable: !0,
      get: function() {
        return l.opaqueType;
      }
    }), Object.defineProperty(i, "OptionalCallExpression", {
      enumerable: !0,
      get: function() {
        return l.optionalCallExpression;
      }
    }), Object.defineProperty(i, "OptionalIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return l.optionalIndexedAccessType;
      }
    }), Object.defineProperty(i, "OptionalMemberExpression", {
      enumerable: !0,
      get: function() {
        return l.optionalMemberExpression;
      }
    }), Object.defineProperty(i, "ParenthesizedExpression", {
      enumerable: !0,
      get: function() {
        return l.parenthesizedExpression;
      }
    }), Object.defineProperty(i, "PipelineBareFunction", {
      enumerable: !0,
      get: function() {
        return l.pipelineBareFunction;
      }
    }), Object.defineProperty(i, "PipelinePrimaryTopicReference", {
      enumerable: !0,
      get: function() {
        return l.pipelinePrimaryTopicReference;
      }
    }), Object.defineProperty(i, "PipelineTopicExpression", {
      enumerable: !0,
      get: function() {
        return l.pipelineTopicExpression;
      }
    }), Object.defineProperty(i, "Placeholder", {
      enumerable: !0,
      get: function() {
        return l.placeholder;
      }
    }), Object.defineProperty(i, "PrivateName", {
      enumerable: !0,
      get: function() {
        return l.privateName;
      }
    }), Object.defineProperty(i, "Program", {
      enumerable: !0,
      get: function() {
        return l.program;
      }
    }), Object.defineProperty(i, "QualifiedTypeIdentifier", {
      enumerable: !0,
      get: function() {
        return l.qualifiedTypeIdentifier;
      }
    }), Object.defineProperty(i, "RecordExpression", {
      enumerable: !0,
      get: function() {
        return l.recordExpression;
      }
    }), Object.defineProperty(i, "RegExpLiteral", {
      enumerable: !0,
      get: function() {
        return l.regExpLiteral;
      }
    }), Object.defineProperty(i, "RegexLiteral", {
      enumerable: !0,
      get: function() {
        return l.regexLiteral;
      }
    }), Object.defineProperty(i, "RestElement", {
      enumerable: !0,
      get: function() {
        return l.restElement;
      }
    }), Object.defineProperty(i, "RestProperty", {
      enumerable: !0,
      get: function() {
        return l.restProperty;
      }
    }), Object.defineProperty(i, "ReturnStatement", {
      enumerable: !0,
      get: function() {
        return l.returnStatement;
      }
    }), Object.defineProperty(i, "SequenceExpression", {
      enumerable: !0,
      get: function() {
        return l.sequenceExpression;
      }
    }), Object.defineProperty(i, "SpreadElement", {
      enumerable: !0,
      get: function() {
        return l.spreadElement;
      }
    }), Object.defineProperty(i, "SpreadProperty", {
      enumerable: !0,
      get: function() {
        return l.spreadProperty;
      }
    }), Object.defineProperty(i, "StaticBlock", {
      enumerable: !0,
      get: function() {
        return l.staticBlock;
      }
    }), Object.defineProperty(i, "StringLiteral", {
      enumerable: !0,
      get: function() {
        return l.stringLiteral;
      }
    }), Object.defineProperty(i, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.stringLiteralTypeAnnotation;
      }
    }), Object.defineProperty(i, "StringTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.stringTypeAnnotation;
      }
    }), Object.defineProperty(i, "Super", {
      enumerable: !0,
      get: function() {
        return l.super;
      }
    }), Object.defineProperty(i, "SwitchCase", {
      enumerable: !0,
      get: function() {
        return l.switchCase;
      }
    }), Object.defineProperty(i, "SwitchStatement", {
      enumerable: !0,
      get: function() {
        return l.switchStatement;
      }
    }), Object.defineProperty(i, "SymbolTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.symbolTypeAnnotation;
      }
    }), Object.defineProperty(i, "TSAnyKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsAnyKeyword;
      }
    }), Object.defineProperty(i, "TSArrayType", {
      enumerable: !0,
      get: function() {
        return l.tsArrayType;
      }
    }), Object.defineProperty(i, "TSAsExpression", {
      enumerable: !0,
      get: function() {
        return l.tsAsExpression;
      }
    }), Object.defineProperty(i, "TSBigIntKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsBigIntKeyword;
      }
    }), Object.defineProperty(i, "TSBooleanKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsBooleanKeyword;
      }
    }), Object.defineProperty(i, "TSCallSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsCallSignatureDeclaration;
      }
    }), Object.defineProperty(i, "TSConditionalType", {
      enumerable: !0,
      get: function() {
        return l.tsConditionalType;
      }
    }), Object.defineProperty(i, "TSConstructSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsConstructSignatureDeclaration;
      }
    }), Object.defineProperty(i, "TSConstructorType", {
      enumerable: !0,
      get: function() {
        return l.tsConstructorType;
      }
    }), Object.defineProperty(i, "TSDeclareFunction", {
      enumerable: !0,
      get: function() {
        return l.tsDeclareFunction;
      }
    }), Object.defineProperty(i, "TSDeclareMethod", {
      enumerable: !0,
      get: function() {
        return l.tsDeclareMethod;
      }
    }), Object.defineProperty(i, "TSEnumBody", {
      enumerable: !0,
      get: function() {
        return l.tsEnumBody;
      }
    }), Object.defineProperty(i, "TSEnumDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsEnumDeclaration;
      }
    }), Object.defineProperty(i, "TSEnumMember", {
      enumerable: !0,
      get: function() {
        return l.tsEnumMember;
      }
    }), Object.defineProperty(i, "TSExportAssignment", {
      enumerable: !0,
      get: function() {
        return l.tsExportAssignment;
      }
    }), Object.defineProperty(i, "TSExpressionWithTypeArguments", {
      enumerable: !0,
      get: function() {
        return l.tsExpressionWithTypeArguments;
      }
    }), Object.defineProperty(i, "TSExternalModuleReference", {
      enumerable: !0,
      get: function() {
        return l.tsExternalModuleReference;
      }
    }), Object.defineProperty(i, "TSFunctionType", {
      enumerable: !0,
      get: function() {
        return l.tsFunctionType;
      }
    }), Object.defineProperty(i, "TSImportEqualsDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsImportEqualsDeclaration;
      }
    }), Object.defineProperty(i, "TSImportType", {
      enumerable: !0,
      get: function() {
        return l.tsImportType;
      }
    }), Object.defineProperty(i, "TSIndexSignature", {
      enumerable: !0,
      get: function() {
        return l.tsIndexSignature;
      }
    }), Object.defineProperty(i, "TSIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return l.tsIndexedAccessType;
      }
    }), Object.defineProperty(i, "TSInferType", {
      enumerable: !0,
      get: function() {
        return l.tsInferType;
      }
    }), Object.defineProperty(i, "TSInstantiationExpression", {
      enumerable: !0,
      get: function() {
        return l.tsInstantiationExpression;
      }
    }), Object.defineProperty(i, "TSInterfaceBody", {
      enumerable: !0,
      get: function() {
        return l.tsInterfaceBody;
      }
    }), Object.defineProperty(i, "TSInterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsInterfaceDeclaration;
      }
    }), Object.defineProperty(i, "TSIntersectionType", {
      enumerable: !0,
      get: function() {
        return l.tsIntersectionType;
      }
    }), Object.defineProperty(i, "TSIntrinsicKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsIntrinsicKeyword;
      }
    }), Object.defineProperty(i, "TSLiteralType", {
      enumerable: !0,
      get: function() {
        return l.tsLiteralType;
      }
    }), Object.defineProperty(i, "TSMappedType", {
      enumerable: !0,
      get: function() {
        return l.tsMappedType;
      }
    }), Object.defineProperty(i, "TSMethodSignature", {
      enumerable: !0,
      get: function() {
        return l.tsMethodSignature;
      }
    }), Object.defineProperty(i, "TSModuleBlock", {
      enumerable: !0,
      get: function() {
        return l.tsModuleBlock;
      }
    }), Object.defineProperty(i, "TSModuleDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsModuleDeclaration;
      }
    }), Object.defineProperty(i, "TSNamedTupleMember", {
      enumerable: !0,
      get: function() {
        return l.tsNamedTupleMember;
      }
    }), Object.defineProperty(i, "TSNamespaceExportDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsNamespaceExportDeclaration;
      }
    }), Object.defineProperty(i, "TSNeverKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsNeverKeyword;
      }
    }), Object.defineProperty(i, "TSNonNullExpression", {
      enumerable: !0,
      get: function() {
        return l.tsNonNullExpression;
      }
    }), Object.defineProperty(i, "TSNullKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsNullKeyword;
      }
    }), Object.defineProperty(i, "TSNumberKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsNumberKeyword;
      }
    }), Object.defineProperty(i, "TSObjectKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsObjectKeyword;
      }
    }), Object.defineProperty(i, "TSOptionalType", {
      enumerable: !0,
      get: function() {
        return l.tsOptionalType;
      }
    }), Object.defineProperty(i, "TSParameterProperty", {
      enumerable: !0,
      get: function() {
        return l.tsParameterProperty;
      }
    }), Object.defineProperty(i, "TSParenthesizedType", {
      enumerable: !0,
      get: function() {
        return l.tsParenthesizedType;
      }
    }), Object.defineProperty(i, "TSPropertySignature", {
      enumerable: !0,
      get: function() {
        return l.tsPropertySignature;
      }
    }), Object.defineProperty(i, "TSQualifiedName", {
      enumerable: !0,
      get: function() {
        return l.tsQualifiedName;
      }
    }), Object.defineProperty(i, "TSRestType", {
      enumerable: !0,
      get: function() {
        return l.tsRestType;
      }
    }), Object.defineProperty(i, "TSSatisfiesExpression", {
      enumerable: !0,
      get: function() {
        return l.tsSatisfiesExpression;
      }
    }), Object.defineProperty(i, "TSStringKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsStringKeyword;
      }
    }), Object.defineProperty(i, "TSSymbolKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsSymbolKeyword;
      }
    }), Object.defineProperty(i, "TSTemplateLiteralType", {
      enumerable: !0,
      get: function() {
        return l.tsTemplateLiteralType;
      }
    }), Object.defineProperty(i, "TSThisType", {
      enumerable: !0,
      get: function() {
        return l.tsThisType;
      }
    }), Object.defineProperty(i, "TSTupleType", {
      enumerable: !0,
      get: function() {
        return l.tsTupleType;
      }
    }), Object.defineProperty(i, "TSTypeAliasDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsTypeAliasDeclaration;
      }
    }), Object.defineProperty(i, "TSTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.tsTypeAnnotation;
      }
    }), Object.defineProperty(i, "TSTypeAssertion", {
      enumerable: !0,
      get: function() {
        return l.tsTypeAssertion;
      }
    }), Object.defineProperty(i, "TSTypeLiteral", {
      enumerable: !0,
      get: function() {
        return l.tsTypeLiteral;
      }
    }), Object.defineProperty(i, "TSTypeOperator", {
      enumerable: !0,
      get: function() {
        return l.tsTypeOperator;
      }
    }), Object.defineProperty(i, "TSTypeParameter", {
      enumerable: !0,
      get: function() {
        return l.tsTypeParameter;
      }
    }), Object.defineProperty(i, "TSTypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return l.tsTypeParameterDeclaration;
      }
    }), Object.defineProperty(i, "TSTypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return l.tsTypeParameterInstantiation;
      }
    }), Object.defineProperty(i, "TSTypePredicate", {
      enumerable: !0,
      get: function() {
        return l.tsTypePredicate;
      }
    }), Object.defineProperty(i, "TSTypeQuery", {
      enumerable: !0,
      get: function() {
        return l.tsTypeQuery;
      }
    }), Object.defineProperty(i, "TSTypeReference", {
      enumerable: !0,
      get: function() {
        return l.tsTypeReference;
      }
    }), Object.defineProperty(i, "TSUndefinedKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsUndefinedKeyword;
      }
    }), Object.defineProperty(i, "TSUnionType", {
      enumerable: !0,
      get: function() {
        return l.tsUnionType;
      }
    }), Object.defineProperty(i, "TSUnknownKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsUnknownKeyword;
      }
    }), Object.defineProperty(i, "TSVoidKeyword", {
      enumerable: !0,
      get: function() {
        return l.tsVoidKeyword;
      }
    }), Object.defineProperty(i, "TaggedTemplateExpression", {
      enumerable: !0,
      get: function() {
        return l.taggedTemplateExpression;
      }
    }), Object.defineProperty(i, "TemplateElement", {
      enumerable: !0,
      get: function() {
        return l.templateElement;
      }
    }), Object.defineProperty(i, "TemplateLiteral", {
      enumerable: !0,
      get: function() {
        return l.templateLiteral;
      }
    }), Object.defineProperty(i, "ThisExpression", {
      enumerable: !0,
      get: function() {
        return l.thisExpression;
      }
    }), Object.defineProperty(i, "ThisTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.thisTypeAnnotation;
      }
    }), Object.defineProperty(i, "ThrowStatement", {
      enumerable: !0,
      get: function() {
        return l.throwStatement;
      }
    }), Object.defineProperty(i, "TopicReference", {
      enumerable: !0,
      get: function() {
        return l.topicReference;
      }
    }), Object.defineProperty(i, "TryStatement", {
      enumerable: !0,
      get: function() {
        return l.tryStatement;
      }
    }), Object.defineProperty(i, "TupleExpression", {
      enumerable: !0,
      get: function() {
        return l.tupleExpression;
      }
    }), Object.defineProperty(i, "TupleTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.tupleTypeAnnotation;
      }
    }), Object.defineProperty(i, "TypeAlias", {
      enumerable: !0,
      get: function() {
        return l.typeAlias;
      }
    }), Object.defineProperty(i, "TypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.typeAnnotation;
      }
    }), Object.defineProperty(i, "TypeCastExpression", {
      enumerable: !0,
      get: function() {
        return l.typeCastExpression;
      }
    }), Object.defineProperty(i, "TypeParameter", {
      enumerable: !0,
      get: function() {
        return l.typeParameter;
      }
    }), Object.defineProperty(i, "TypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return l.typeParameterDeclaration;
      }
    }), Object.defineProperty(i, "TypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return l.typeParameterInstantiation;
      }
    }), Object.defineProperty(i, "TypeofTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.typeofTypeAnnotation;
      }
    }), Object.defineProperty(i, "UnaryExpression", {
      enumerable: !0,
      get: function() {
        return l.unaryExpression;
      }
    }), Object.defineProperty(i, "UnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.unionTypeAnnotation;
      }
    }), Object.defineProperty(i, "UpdateExpression", {
      enumerable: !0,
      get: function() {
        return l.updateExpression;
      }
    }), Object.defineProperty(i, "V8IntrinsicIdentifier", {
      enumerable: !0,
      get: function() {
        return l.v8IntrinsicIdentifier;
      }
    }), Object.defineProperty(i, "VariableDeclaration", {
      enumerable: !0,
      get: function() {
        return l.variableDeclaration;
      }
    }), Object.defineProperty(i, "VariableDeclarator", {
      enumerable: !0,
      get: function() {
        return l.variableDeclarator;
      }
    }), Object.defineProperty(i, "Variance", {
      enumerable: !0,
      get: function() {
        return l.variance;
      }
    }), Object.defineProperty(i, "VoidTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.voidTypeAnnotation;
      }
    }), Object.defineProperty(i, "WhileStatement", {
      enumerable: !0,
      get: function() {
        return l.whileStatement;
      }
    }), Object.defineProperty(i, "WithStatement", {
      enumerable: !0,
      get: function() {
        return l.withStatement;
      }
    }), Object.defineProperty(i, "YieldExpression", {
      enumerable: !0,
      get: function() {
        return l.yieldExpression;
      }
    });
    var l = Cp();
  }(Go)), Go;
}
var Zl;
function Vt() {
  return Zl || (Zl = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    });
    var l = Cp();
    Object.keys(l).forEach(function(o) {
      o === "default" || o === "__esModule" || o in i && i[o] === l[o] || Object.defineProperty(i, o, {
        enumerable: !0,
        get: function() {
          return l[o];
        }
      });
    });
    var u = yf();
    Object.keys(u).forEach(function(o) {
      o === "default" || o === "__esModule" || o in i && i[o] === u[o] || Object.defineProperty(i, o, {
        enumerable: !0,
        get: function() {
          return u[o];
        }
      });
    });
  }(Xo)), Xo;
}
var eu;
function Tf() {
  if (eu) return $s;
  eu = 1, Object.defineProperty($s, "__esModule", {
    value: !0
  }), $s.default = u;
  var i = Vt(), l = Ze();
  function u(o, f) {
    const p = o.value.split(/\r\n|\n|\r/);
    let P = 0;
    for (let x = 0; x < p.length; x++)
      /[^ \t]/.exec(p[x]) && (P = x);
    let w = "";
    for (let x = 0; x < p.length; x++) {
      const A = p[x], g = x === 0, I = x === p.length - 1, v = x === P;
      let S = A.replace(/\t/g, " ");
      g || (S = S.replace(/^ +/, "")), I || (S = S.replace(/ +$/, "")), S && (v || (S += " "), w += S);
    }
    w && f.push((0, l.inherits)((0, i.stringLiteral)(w), o));
  }
  return $s;
}
var tu;
function Sf() {
  if (tu) return Ws;
  tu = 1, Object.defineProperty(Ws, "__esModule", {
    value: !0
  }), Ws.default = u;
  var i = bt(), l = Tf();
  function u(o) {
    const f = [];
    for (let p = 0; p < o.children.length; p++) {
      let P = o.children[p];
      if ((0, i.isJSXText)(P)) {
        (0, l.default)(P, f);
        continue;
      }
      (0, i.isJSXExpressionContainer)(P) && (P = P.expression), !(0, i.isJSXEmptyExpression)(P) && f.push(P);
    }
    return f;
  }
  return Ws;
}
var Gs = {}, zs = {}, ru;
function Ip() {
  if (ru) return zs;
  ru = 1, Object.defineProperty(zs, "__esModule", {
    value: !0
  }), zs.default = l;
  var i = tr();
  function l(u) {
    return !!(u && i.VISITOR_KEYS[u.type]);
  }
  return zs;
}
var iu;
function gf() {
  if (iu) return Gs;
  iu = 1, Object.defineProperty(Gs, "__esModule", {
    value: !0
  }), Gs.default = l;
  var i = Ip();
  function l(u) {
    if (!(0, i.default)(u)) {
      var o;
      const f = (o = u == null ? void 0 : u.type) != null ? o : JSON.stringify(u);
      throw new TypeError(`Not a valid node of type "${f}"`);
    }
  }
  return Gs;
}
var $ = {}, nu;
function bf() {
  if (nu) return $;
  nu = 1, Object.defineProperty($, "__esModule", {
    value: !0
  }), $.assertAccessor = vo, $.assertAnyTypeAnnotation = Cr, $.assertArgumentPlaceholder = Sr, $.assertArrayExpression = o, $.assertArrayPattern = it, $.assertArrayTypeAnnotation = Gr, $.assertArrowFunctionExpression = ft, $.assertAssignmentExpression = f, $.assertAssignmentPattern = at, $.assertAwaitExpression = ct, $.assertBigIntLiteral = Kt, $.assertBinary = is, $.assertBinaryExpression = p, $.assertBindExpression = ji, $.assertBlock = as, $.assertBlockParent = ss, $.assertBlockStatement = A, $.assertBooleanLiteral = Q, $.assertBooleanLiteralTypeAnnotation = Mt, $.assertBooleanTypeAnnotation = Gt, $.assertBreakStatement = g, $.assertCallExpression = I, $.assertCatchClause = v, $.assertClass = Bs, $.assertClassAccessorProperty = $t, $.assertClassBody = Xe, $.assertClassDeclaration = be, $.assertClassExpression = Tt, $.assertClassImplements = Qr, $.assertClassMethod = Ye, $.assertClassPrivateMethod = rr, $.assertClassPrivateProperty = Jt, $.assertClassProperty = Wt, $.assertCompletionStatement = T, $.assertConditional = k, $.assertConditionalExpression = S, $.assertContinueStatement = _, $.assertDebuggerStatement = B, $.assertDecimalLiteral = Wi, $.assertDeclaration = lo, $.assertDeclareClass = ir, $.assertDeclareExportAllDeclaration = nr, $.assertDeclareExportDeclaration = wr, $.assertDeclareFunction = Xt, $.assertDeclareInterface = Ir, $.assertDeclareModule = hr, $.assertDeclareModuleExports = dr, $.assertDeclareOpaqueType = mr, $.assertDeclareTypeAlias = Zr, $.assertDeclareVariable = ei, $.assertDeclaredPredicate = Or, $.assertDecorator = gr, $.assertDirective = w, $.assertDirectiveLiteral = x, $.assertDoExpression = Ui, $.assertDoWhileStatement = y, $.assertEmptyStatement = X, $.assertEmptyTypeAnnotation = ai, $.assertEnumBody = _o, $.assertEnumBooleanBody = Dt, $.assertEnumBooleanMember = Ai, $.assertEnumDeclaration = Bt, $.assertEnumDefaultedMember = Ii, $.assertEnumMember = Do, $.assertEnumNumberBody = Yt, $.assertEnumNumberMember = Mr, $.assertEnumStringBody = xi, $.assertEnumStringMember = Ci, $.assertEnumSymbolBody = vi, $.assertExistsTypeAnnotation = ti, $.assertExportAllDeclaration = ve, $.assertExportDeclaration = Po, $.assertExportDefaultDeclaration = j, $.assertExportDefaultSpecifier = Vi, $.assertExportNamedDeclaration = D, $.assertExportNamespaceSpecifier = Nt, $.assertExportSpecifier = V, $.assertExpression = rs, $.assertExpressionStatement = Z, $.assertExpressionWrapper = je, $.assertFile = J, $.assertFlow = Co, $.assertFlowBaseAnnotation = wo, $.assertFlowDeclaration = Oo, $.assertFlowPredicate = No, $.assertFlowType = Io, $.assertFor = pt, $.assertForInStatement = G, $.assertForOfStatement = le, $.assertForStatement = O, $.assertForXStatement = St, $.assertFunction = Ht, $.assertFunctionDeclaration = ee, $.assertFunctionExpression = L, $.assertFunctionParent = ao, $.assertFunctionTypeAnnotation = ri, $.assertFunctionTypeParam = yr, $.assertGenericTypeAnnotation = Nr, $.assertIdentifier = q, $.assertIfStatement = H, $.assertImmutable = ho, $.assertImport = Lt, $.assertImportAttribute = qi, $.assertImportDeclaration = me, $.assertImportDefaultSpecifier = ge, $.assertImportExpression = We, $.assertImportNamespaceSpecifier = xe, $.assertImportOrExportDeclaration = Eo, $.assertImportSpecifier = De, $.assertIndexedAccessType = Br, $.assertInferredPredicate = _r, $.assertInterfaceDeclaration = ii, $.assertInterfaceExtends = zt, $.assertInterfaceTypeAnnotation = _t, $.assertInterpreterDirective = P, $.assertIntersectionTypeAnnotation = ni, $.assertJSX = ko, $.assertJSXAttribute = wi, $.assertJSXClosingElement = Fr, $.assertJSXClosingFragment = Bi, $.assertJSXElement = Oi, $.assertJSXEmptyExpression = Ni, $.assertJSXExpressionContainer = _i, $.assertJSXFragment = Ur, $.assertJSXIdentifier = Rr, $.assertJSXMemberExpression = ki, $.assertJSXNamespacedName = jr, $.assertJSXOpeningElement = qr, $.assertJSXOpeningFragment = Vr, $.assertJSXSpreadAttribute = Li, $.assertJSXSpreadChild = Di, $.assertJSXText = Mi, $.assertLVal = co, $.assertLabeledStatement = N, $.assertLiteral = fo, $.assertLogicalExpression = ne, $.assertLoop = te, $.assertMemberExpression = R, $.assertMetaProperty = Ce, $.assertMethod = yo, $.assertMiscellaneous = Lo, $.assertMixedTypeAnnotation = si, $.assertModuleDeclaration = s, $.assertModuleExpression = $i, $.assertModuleSpecifier = xo, $.assertNewExpression = C, $.assertNoop = Kr, $.assertNullLiteral = re, $.assertNullLiteralTypeAnnotation = zr, $.assertNullableTypeAnnotation = sr, $.assertNumberLiteral = jo, $.assertNumberLiteralTypeAnnotation = Dr, $.assertNumberTypeAnnotation = oi, $.assertNumericLiteral = ie, $.assertObjectExpression = ae, $.assertObjectMember = To, $.assertObjectMethod = ce, $.assertObjectPattern = $e, $.assertObjectProperty = ye, $.assertObjectTypeAnnotation = li, $.assertObjectTypeCallProperty = ci, $.assertObjectTypeIndexer = kr, $.assertObjectTypeInternalSlot = ui, $.assertObjectTypeProperty = pi, $.assertObjectTypeSpreadProperty = ar, $.assertOpaqueType = fi, $.assertOptionalCallExpression = xt, $.assertOptionalIndexedAccessType = Fe, $.assertOptionalMemberExpression = At, $.assertParenthesizedExpression = we, $.assertPattern = bo, $.assertPatternLike = uo, $.assertPipelineBareFunction = $r, $.assertPipelinePrimaryTopicReference = Xi, $.assertPipelineTopicExpression = Qt, $.assertPlaceholder = Fi, $.assertPrivate = Ao, $.assertPrivateName = Yr, $.assertProgram = z, $.assertProperty = So, $.assertPureish = oo, $.assertQualifiedTypeIdentifier = or, $.assertRecordExpression = Wr, $.assertRegExpLiteral = pe, $.assertRegexLiteral = qo, $.assertRestElement = he, $.assertRestProperty = Uo, $.assertReturnStatement = Pe, $.assertScopable = ns, $.assertSequenceExpression = Ne, $.assertSpreadElement = et, $.assertSpreadProperty = Vo, $.assertStandardized = ts, $.assertStatement = h, $.assertStaticBlock = Hr, $.assertStringLiteral = F, $.assertStringLiteralTypeAnnotation = lr, $.assertStringTypeAnnotation = Tr, $.assertSuper = oe, $.assertSwitchCase = Ie, $.assertSwitchStatement = Le, $.assertSymbolTypeAnnotation = hi, $.assertTSAnyKeyword = se, $.assertTSArrayType = Tn, $.assertTSAsExpression = Fn, $.assertTSBaseType = Ro, $.assertTSBigIntKeyword = Ee, $.assertTSBooleanKeyword = ue, $.assertTSCallSignatureDeclaration = a, $.assertTSConditionalType = vn, $.assertTSConstructSignatureDeclaration = c, $.assertTSConstructorType = fn, $.assertTSDeclareFunction = t, $.assertTSDeclareMethod = e, $.assertTSEntityName = po, $.assertTSEnumBody = qn, $.assertTSEnumDeclaration = Un, $.assertTSEnumMember = Vn, $.assertTSExportAssignment = Hn, $.assertTSExpressionWithTypeArguments = Dn, $.assertTSExternalModuleReference = Xn, $.assertTSFunctionType = pn, $.assertTSImportEqualsDeclaration = Jn, $.assertTSImportType = $n, $.assertTSIndexSignature = Y, $.assertTSIndexedAccessType = wn, $.assertTSInferType = An, $.assertTSInstantiationExpression = Bn, $.assertTSInterfaceBody = Ln, $.assertTSInterfaceDeclaration = kn, $.assertTSIntersectionType = xn, $.assertTSIntrinsicKeyword = _e, $.assertTSLiteralType = _n, $.assertTSMappedType = On, $.assertTSMethodSignature = M, $.assertTSModuleBlock = Wn, $.assertTSModuleDeclaration = Kn, $.assertTSNamedTupleMember = En, $.assertTSNamespaceExportDeclaration = Gn, $.assertTSNeverKeyword = ke, $.assertTSNonNullExpression = Yn, $.assertTSNullKeyword = Re, $.assertTSNumberKeyword = Qe, $.assertTSObjectKeyword = mt, $.assertTSOptionalType = gn, $.assertTSParameterProperty = b, $.assertTSParenthesizedType = Cn, $.assertTSPropertySignature = E, $.assertTSQualifiedName = r, $.assertTSRestType = bn, $.assertTSSatisfiesExpression = Rn, $.assertTSStringKeyword = tt, $.assertTSSymbolKeyword = ut, $.assertTSTemplateLiteralType = Nn, $.assertTSThisType = cn, $.assertTSTupleType = Sn, $.assertTSType = Fo, $.assertTSTypeAliasDeclaration = Mn, $.assertTSTypeAnnotation = zn, $.assertTSTypeAssertion = jn, $.assertTSTypeElement = Bo, $.assertTSTypeLiteral = yn, $.assertTSTypeOperator = In, $.assertTSTypeParameter = es, $.assertTSTypeParameterDeclaration = Zn, $.assertTSTypeParameterInstantiation = Qn, $.assertTSTypePredicate = dn, $.assertTSTypeQuery = mn, $.assertTSTypeReference = hn, $.assertTSUndefinedKeyword = ur, $.assertTSUnionType = Pn, $.assertTSUnknownKeyword = Zt, $.assertTSVoidKeyword = un, $.assertTaggedTemplateExpression = K, $.assertTemplateElement = Ae, $.assertTemplateLiteral = Be, $.assertTerminatorless = d, $.assertThisExpression = fe, $.assertThisTypeAnnotation = wt, $.assertThrowStatement = Te, $.assertTopicReference = Ji, $.assertTryStatement = de, $.assertTupleExpression = Ki, $.assertTupleTypeAnnotation = di, $.assertTypeAlias = yi, $.assertTypeAnnotation = Ve, $.assertTypeCastExpression = Ti, $.assertTypeParameter = Lr, $.assertTypeParameterDeclaration = Si, $.assertTypeParameterInstantiation = gi, $.assertTypeScript = Mo, $.assertTypeofTypeAnnotation = mi, $.assertUnaryExpression = Ue, $.assertUnaryLike = go, $.assertUnionTypeAnnotation = bi, $.assertUpdateExpression = Je, $.assertUserWhitespacable = mo, $.assertV8IntrinsicIdentifier = Ri, $.assertVariableDeclaration = He, $.assertVariableDeclarator = st, $.assertVariance = Ei, $.assertVoidTypeAnnotation = Pi, $.assertWhile = Se, $.assertWhileStatement = qe, $.assertWithStatement = Ge, $.assertYieldExpression = Ke;
  var i = Ls(), l = eo();
  function u(n, m, fl) {
    if (!(0, i.default)(n, m, fl))
      throw new Error(`Expected type "${n}" with option ${JSON.stringify(fl)}, but instead got "${m.type}".`);
  }
  function o(n, m) {
    u("ArrayExpression", n, m);
  }
  function f(n, m) {
    u("AssignmentExpression", n, m);
  }
  function p(n, m) {
    u("BinaryExpression", n, m);
  }
  function P(n, m) {
    u("InterpreterDirective", n, m);
  }
  function w(n, m) {
    u("Directive", n, m);
  }
  function x(n, m) {
    u("DirectiveLiteral", n, m);
  }
  function A(n, m) {
    u("BlockStatement", n, m);
  }
  function g(n, m) {
    u("BreakStatement", n, m);
  }
  function I(n, m) {
    u("CallExpression", n, m);
  }
  function v(n, m) {
    u("CatchClause", n, m);
  }
  function S(n, m) {
    u("ConditionalExpression", n, m);
  }
  function _(n, m) {
    u("ContinueStatement", n, m);
  }
  function B(n, m) {
    u("DebuggerStatement", n, m);
  }
  function y(n, m) {
    u("DoWhileStatement", n, m);
  }
  function X(n, m) {
    u("EmptyStatement", n, m);
  }
  function Z(n, m) {
    u("ExpressionStatement", n, m);
  }
  function J(n, m) {
    u("File", n, m);
  }
  function G(n, m) {
    u("ForInStatement", n, m);
  }
  function O(n, m) {
    u("ForStatement", n, m);
  }
  function ee(n, m) {
    u("FunctionDeclaration", n, m);
  }
  function L(n, m) {
    u("FunctionExpression", n, m);
  }
  function q(n, m) {
    u("Identifier", n, m);
  }
  function H(n, m) {
    u("IfStatement", n, m);
  }
  function N(n, m) {
    u("LabeledStatement", n, m);
  }
  function F(n, m) {
    u("StringLiteral", n, m);
  }
  function ie(n, m) {
    u("NumericLiteral", n, m);
  }
  function re(n, m) {
    u("NullLiteral", n, m);
  }
  function Q(n, m) {
    u("BooleanLiteral", n, m);
  }
  function pe(n, m) {
    u("RegExpLiteral", n, m);
  }
  function ne(n, m) {
    u("LogicalExpression", n, m);
  }
  function R(n, m) {
    u("MemberExpression", n, m);
  }
  function C(n, m) {
    u("NewExpression", n, m);
  }
  function z(n, m) {
    u("Program", n, m);
  }
  function ae(n, m) {
    u("ObjectExpression", n, m);
  }
  function ce(n, m) {
    u("ObjectMethod", n, m);
  }
  function ye(n, m) {
    u("ObjectProperty", n, m);
  }
  function he(n, m) {
    u("RestElement", n, m);
  }
  function Pe(n, m) {
    u("ReturnStatement", n, m);
  }
  function Ne(n, m) {
    u("SequenceExpression", n, m);
  }
  function we(n, m) {
    u("ParenthesizedExpression", n, m);
  }
  function Ie(n, m) {
    u("SwitchCase", n, m);
  }
  function Le(n, m) {
    u("SwitchStatement", n, m);
  }
  function fe(n, m) {
    u("ThisExpression", n, m);
  }
  function Te(n, m) {
    u("ThrowStatement", n, m);
  }
  function de(n, m) {
    u("TryStatement", n, m);
  }
  function Ue(n, m) {
    u("UnaryExpression", n, m);
  }
  function Je(n, m) {
    u("UpdateExpression", n, m);
  }
  function He(n, m) {
    u("VariableDeclaration", n, m);
  }
  function st(n, m) {
    u("VariableDeclarator", n, m);
  }
  function qe(n, m) {
    u("WhileStatement", n, m);
  }
  function Ge(n, m) {
    u("WithStatement", n, m);
  }
  function at(n, m) {
    u("AssignmentPattern", n, m);
  }
  function it(n, m) {
    u("ArrayPattern", n, m);
  }
  function ft(n, m) {
    u("ArrowFunctionExpression", n, m);
  }
  function Xe(n, m) {
    u("ClassBody", n, m);
  }
  function Tt(n, m) {
    u("ClassExpression", n, m);
  }
  function be(n, m) {
    u("ClassDeclaration", n, m);
  }
  function ve(n, m) {
    u("ExportAllDeclaration", n, m);
  }
  function j(n, m) {
    u("ExportDefaultDeclaration", n, m);
  }
  function D(n, m) {
    u("ExportNamedDeclaration", n, m);
  }
  function V(n, m) {
    u("ExportSpecifier", n, m);
  }
  function le(n, m) {
    u("ForOfStatement", n, m);
  }
  function me(n, m) {
    u("ImportDeclaration", n, m);
  }
  function ge(n, m) {
    u("ImportDefaultSpecifier", n, m);
  }
  function xe(n, m) {
    u("ImportNamespaceSpecifier", n, m);
  }
  function De(n, m) {
    u("ImportSpecifier", n, m);
  }
  function We(n, m) {
    u("ImportExpression", n, m);
  }
  function Ce(n, m) {
    u("MetaProperty", n, m);
  }
  function Ye(n, m) {
    u("ClassMethod", n, m);
  }
  function $e(n, m) {
    u("ObjectPattern", n, m);
  }
  function et(n, m) {
    u("SpreadElement", n, m);
  }
  function oe(n, m) {
    u("Super", n, m);
  }
  function K(n, m) {
    u("TaggedTemplateExpression", n, m);
  }
  function Ae(n, m) {
    u("TemplateElement", n, m);
  }
  function Be(n, m) {
    u("TemplateLiteral", n, m);
  }
  function Ke(n, m) {
    u("YieldExpression", n, m);
  }
  function ct(n, m) {
    u("AwaitExpression", n, m);
  }
  function Lt(n, m) {
    u("Import", n, m);
  }
  function Kt(n, m) {
    u("BigIntLiteral", n, m);
  }
  function Nt(n, m) {
    u("ExportNamespaceSpecifier", n, m);
  }
  function At(n, m) {
    u("OptionalMemberExpression", n, m);
  }
  function xt(n, m) {
    u("OptionalCallExpression", n, m);
  }
  function Wt(n, m) {
    u("ClassProperty", n, m);
  }
  function $t(n, m) {
    u("ClassAccessorProperty", n, m);
  }
  function Jt(n, m) {
    u("ClassPrivateProperty", n, m);
  }
  function rr(n, m) {
    u("ClassPrivateMethod", n, m);
  }
  function Yr(n, m) {
    u("PrivateName", n, m);
  }
  function Hr(n, m) {
    u("StaticBlock", n, m);
  }
  function Cr(n, m) {
    u("AnyTypeAnnotation", n, m);
  }
  function Gr(n, m) {
    u("ArrayTypeAnnotation", n, m);
  }
  function Gt(n, m) {
    u("BooleanTypeAnnotation", n, m);
  }
  function Mt(n, m) {
    u("BooleanLiteralTypeAnnotation", n, m);
  }
  function zr(n, m) {
    u("NullLiteralTypeAnnotation", n, m);
  }
  function Qr(n, m) {
    u("ClassImplements", n, m);
  }
  function ir(n, m) {
    u("DeclareClass", n, m);
  }
  function Xt(n, m) {
    u("DeclareFunction", n, m);
  }
  function Ir(n, m) {
    u("DeclareInterface", n, m);
  }
  function hr(n, m) {
    u("DeclareModule", n, m);
  }
  function dr(n, m) {
    u("DeclareModuleExports", n, m);
  }
  function Zr(n, m) {
    u("DeclareTypeAlias", n, m);
  }
  function mr(n, m) {
    u("DeclareOpaqueType", n, m);
  }
  function ei(n, m) {
    u("DeclareVariable", n, m);
  }
  function wr(n, m) {
    u("DeclareExportDeclaration", n, m);
  }
  function nr(n, m) {
    u("DeclareExportAllDeclaration", n, m);
  }
  function Or(n, m) {
    u("DeclaredPredicate", n, m);
  }
  function ti(n, m) {
    u("ExistsTypeAnnotation", n, m);
  }
  function ri(n, m) {
    u("FunctionTypeAnnotation", n, m);
  }
  function yr(n, m) {
    u("FunctionTypeParam", n, m);
  }
  function Nr(n, m) {
    u("GenericTypeAnnotation", n, m);
  }
  function _r(n, m) {
    u("InferredPredicate", n, m);
  }
  function zt(n, m) {
    u("InterfaceExtends", n, m);
  }
  function ii(n, m) {
    u("InterfaceDeclaration", n, m);
  }
  function _t(n, m) {
    u("InterfaceTypeAnnotation", n, m);
  }
  function ni(n, m) {
    u("IntersectionTypeAnnotation", n, m);
  }
  function si(n, m) {
    u("MixedTypeAnnotation", n, m);
  }
  function ai(n, m) {
    u("EmptyTypeAnnotation", n, m);
  }
  function sr(n, m) {
    u("NullableTypeAnnotation", n, m);
  }
  function Dr(n, m) {
    u("NumberLiteralTypeAnnotation", n, m);
  }
  function oi(n, m) {
    u("NumberTypeAnnotation", n, m);
  }
  function li(n, m) {
    u("ObjectTypeAnnotation", n, m);
  }
  function ui(n, m) {
    u("ObjectTypeInternalSlot", n, m);
  }
  function ci(n, m) {
    u("ObjectTypeCallProperty", n, m);
  }
  function kr(n, m) {
    u("ObjectTypeIndexer", n, m);
  }
  function pi(n, m) {
    u("ObjectTypeProperty", n, m);
  }
  function ar(n, m) {
    u("ObjectTypeSpreadProperty", n, m);
  }
  function fi(n, m) {
    u("OpaqueType", n, m);
  }
  function or(n, m) {
    u("QualifiedTypeIdentifier", n, m);
  }
  function lr(n, m) {
    u("StringLiteralTypeAnnotation", n, m);
  }
  function Tr(n, m) {
    u("StringTypeAnnotation", n, m);
  }
  function hi(n, m) {
    u("SymbolTypeAnnotation", n, m);
  }
  function wt(n, m) {
    u("ThisTypeAnnotation", n, m);
  }
  function di(n, m) {
    u("TupleTypeAnnotation", n, m);
  }
  function mi(n, m) {
    u("TypeofTypeAnnotation", n, m);
  }
  function yi(n, m) {
    u("TypeAlias", n, m);
  }
  function Ve(n, m) {
    u("TypeAnnotation", n, m);
  }
  function Ti(n, m) {
    u("TypeCastExpression", n, m);
  }
  function Lr(n, m) {
    u("TypeParameter", n, m);
  }
  function Si(n, m) {
    u("TypeParameterDeclaration", n, m);
  }
  function gi(n, m) {
    u("TypeParameterInstantiation", n, m);
  }
  function bi(n, m) {
    u("UnionTypeAnnotation", n, m);
  }
  function Ei(n, m) {
    u("Variance", n, m);
  }
  function Pi(n, m) {
    u("VoidTypeAnnotation", n, m);
  }
  function Bt(n, m) {
    u("EnumDeclaration", n, m);
  }
  function Dt(n, m) {
    u("EnumBooleanBody", n, m);
  }
  function Yt(n, m) {
    u("EnumNumberBody", n, m);
  }
  function xi(n, m) {
    u("EnumStringBody", n, m);
  }
  function vi(n, m) {
    u("EnumSymbolBody", n, m);
  }
  function Ai(n, m) {
    u("EnumBooleanMember", n, m);
  }
  function Mr(n, m) {
    u("EnumNumberMember", n, m);
  }
  function Ci(n, m) {
    u("EnumStringMember", n, m);
  }
  function Ii(n, m) {
    u("EnumDefaultedMember", n, m);
  }
  function Br(n, m) {
    u("IndexedAccessType", n, m);
  }
  function Fe(n, m) {
    u("OptionalIndexedAccessType", n, m);
  }
  function wi(n, m) {
    u("JSXAttribute", n, m);
  }
  function Fr(n, m) {
    u("JSXClosingElement", n, m);
  }
  function Oi(n, m) {
    u("JSXElement", n, m);
  }
  function Ni(n, m) {
    u("JSXEmptyExpression", n, m);
  }
  function _i(n, m) {
    u("JSXExpressionContainer", n, m);
  }
  function Di(n, m) {
    u("JSXSpreadChild", n, m);
  }
  function Rr(n, m) {
    u("JSXIdentifier", n, m);
  }
  function ki(n, m) {
    u("JSXMemberExpression", n, m);
  }
  function jr(n, m) {
    u("JSXNamespacedName", n, m);
  }
  function qr(n, m) {
    u("JSXOpeningElement", n, m);
  }
  function Li(n, m) {
    u("JSXSpreadAttribute", n, m);
  }
  function Mi(n, m) {
    u("JSXText", n, m);
  }
  function Ur(n, m) {
    u("JSXFragment", n, m);
  }
  function Vr(n, m) {
    u("JSXOpeningFragment", n, m);
  }
  function Bi(n, m) {
    u("JSXClosingFragment", n, m);
  }
  function Kr(n, m) {
    u("Noop", n, m);
  }
  function Fi(n, m) {
    u("Placeholder", n, m);
  }
  function Ri(n, m) {
    u("V8IntrinsicIdentifier", n, m);
  }
  function Sr(n, m) {
    u("ArgumentPlaceholder", n, m);
  }
  function ji(n, m) {
    u("BindExpression", n, m);
  }
  function qi(n, m) {
    u("ImportAttribute", n, m);
  }
  function gr(n, m) {
    u("Decorator", n, m);
  }
  function Ui(n, m) {
    u("DoExpression", n, m);
  }
  function Vi(n, m) {
    u("ExportDefaultSpecifier", n, m);
  }
  function Wr(n, m) {
    u("RecordExpression", n, m);
  }
  function Ki(n, m) {
    u("TupleExpression", n, m);
  }
  function Wi(n, m) {
    u("DecimalLiteral", n, m);
  }
  function $i(n, m) {
    u("ModuleExpression", n, m);
  }
  function Ji(n, m) {
    u("TopicReference", n, m);
  }
  function Qt(n, m) {
    u("PipelineTopicExpression", n, m);
  }
  function $r(n, m) {
    u("PipelineBareFunction", n, m);
  }
  function Xi(n, m) {
    u("PipelinePrimaryTopicReference", n, m);
  }
  function b(n, m) {
    u("TSParameterProperty", n, m);
  }
  function t(n, m) {
    u("TSDeclareFunction", n, m);
  }
  function e(n, m) {
    u("TSDeclareMethod", n, m);
  }
  function r(n, m) {
    u("TSQualifiedName", n, m);
  }
  function a(n, m) {
    u("TSCallSignatureDeclaration", n, m);
  }
  function c(n, m) {
    u("TSConstructSignatureDeclaration", n, m);
  }
  function E(n, m) {
    u("TSPropertySignature", n, m);
  }
  function M(n, m) {
    u("TSMethodSignature", n, m);
  }
  function Y(n, m) {
    u("TSIndexSignature", n, m);
  }
  function se(n, m) {
    u("TSAnyKeyword", n, m);
  }
  function ue(n, m) {
    u("TSBooleanKeyword", n, m);
  }
  function Ee(n, m) {
    u("TSBigIntKeyword", n, m);
  }
  function _e(n, m) {
    u("TSIntrinsicKeyword", n, m);
  }
  function ke(n, m) {
    u("TSNeverKeyword", n, m);
  }
  function Re(n, m) {
    u("TSNullKeyword", n, m);
  }
  function Qe(n, m) {
    u("TSNumberKeyword", n, m);
  }
  function mt(n, m) {
    u("TSObjectKeyword", n, m);
  }
  function tt(n, m) {
    u("TSStringKeyword", n, m);
  }
  function ut(n, m) {
    u("TSSymbolKeyword", n, m);
  }
  function ur(n, m) {
    u("TSUndefinedKeyword", n, m);
  }
  function Zt(n, m) {
    u("TSUnknownKeyword", n, m);
  }
  function un(n, m) {
    u("TSVoidKeyword", n, m);
  }
  function cn(n, m) {
    u("TSThisType", n, m);
  }
  function pn(n, m) {
    u("TSFunctionType", n, m);
  }
  function fn(n, m) {
    u("TSConstructorType", n, m);
  }
  function hn(n, m) {
    u("TSTypeReference", n, m);
  }
  function dn(n, m) {
    u("TSTypePredicate", n, m);
  }
  function mn(n, m) {
    u("TSTypeQuery", n, m);
  }
  function yn(n, m) {
    u("TSTypeLiteral", n, m);
  }
  function Tn(n, m) {
    u("TSArrayType", n, m);
  }
  function Sn(n, m) {
    u("TSTupleType", n, m);
  }
  function gn(n, m) {
    u("TSOptionalType", n, m);
  }
  function bn(n, m) {
    u("TSRestType", n, m);
  }
  function En(n, m) {
    u("TSNamedTupleMember", n, m);
  }
  function Pn(n, m) {
    u("TSUnionType", n, m);
  }
  function xn(n, m) {
    u("TSIntersectionType", n, m);
  }
  function vn(n, m) {
    u("TSConditionalType", n, m);
  }
  function An(n, m) {
    u("TSInferType", n, m);
  }
  function Cn(n, m) {
    u("TSParenthesizedType", n, m);
  }
  function In(n, m) {
    u("TSTypeOperator", n, m);
  }
  function wn(n, m) {
    u("TSIndexedAccessType", n, m);
  }
  function On(n, m) {
    u("TSMappedType", n, m);
  }
  function Nn(n, m) {
    u("TSTemplateLiteralType", n, m);
  }
  function _n(n, m) {
    u("TSLiteralType", n, m);
  }
  function Dn(n, m) {
    u("TSExpressionWithTypeArguments", n, m);
  }
  function kn(n, m) {
    u("TSInterfaceDeclaration", n, m);
  }
  function Ln(n, m) {
    u("TSInterfaceBody", n, m);
  }
  function Mn(n, m) {
    u("TSTypeAliasDeclaration", n, m);
  }
  function Bn(n, m) {
    u("TSInstantiationExpression", n, m);
  }
  function Fn(n, m) {
    u("TSAsExpression", n, m);
  }
  function Rn(n, m) {
    u("TSSatisfiesExpression", n, m);
  }
  function jn(n, m) {
    u("TSTypeAssertion", n, m);
  }
  function qn(n, m) {
    u("TSEnumBody", n, m);
  }
  function Un(n, m) {
    u("TSEnumDeclaration", n, m);
  }
  function Vn(n, m) {
    u("TSEnumMember", n, m);
  }
  function Kn(n, m) {
    u("TSModuleDeclaration", n, m);
  }
  function Wn(n, m) {
    u("TSModuleBlock", n, m);
  }
  function $n(n, m) {
    u("TSImportType", n, m);
  }
  function Jn(n, m) {
    u("TSImportEqualsDeclaration", n, m);
  }
  function Xn(n, m) {
    u("TSExternalModuleReference", n, m);
  }
  function Yn(n, m) {
    u("TSNonNullExpression", n, m);
  }
  function Hn(n, m) {
    u("TSExportAssignment", n, m);
  }
  function Gn(n, m) {
    u("TSNamespaceExportDeclaration", n, m);
  }
  function zn(n, m) {
    u("TSTypeAnnotation", n, m);
  }
  function Qn(n, m) {
    u("TSTypeParameterInstantiation", n, m);
  }
  function Zn(n, m) {
    u("TSTypeParameterDeclaration", n, m);
  }
  function es(n, m) {
    u("TSTypeParameter", n, m);
  }
  function ts(n, m) {
    u("Standardized", n, m);
  }
  function rs(n, m) {
    u("Expression", n, m);
  }
  function is(n, m) {
    u("Binary", n, m);
  }
  function ns(n, m) {
    u("Scopable", n, m);
  }
  function ss(n, m) {
    u("BlockParent", n, m);
  }
  function as(n, m) {
    u("Block", n, m);
  }
  function h(n, m) {
    u("Statement", n, m);
  }
  function d(n, m) {
    u("Terminatorless", n, m);
  }
  function T(n, m) {
    u("CompletionStatement", n, m);
  }
  function k(n, m) {
    u("Conditional", n, m);
  }
  function te(n, m) {
    u("Loop", n, m);
  }
  function Se(n, m) {
    u("While", n, m);
  }
  function je(n, m) {
    u("ExpressionWrapper", n, m);
  }
  function pt(n, m) {
    u("For", n, m);
  }
  function St(n, m) {
    u("ForXStatement", n, m);
  }
  function Ht(n, m) {
    u("Function", n, m);
  }
  function ao(n, m) {
    u("FunctionParent", n, m);
  }
  function oo(n, m) {
    u("Pureish", n, m);
  }
  function lo(n, m) {
    u("Declaration", n, m);
  }
  function uo(n, m) {
    u("PatternLike", n, m);
  }
  function co(n, m) {
    u("LVal", n, m);
  }
  function po(n, m) {
    u("TSEntityName", n, m);
  }
  function fo(n, m) {
    u("Literal", n, m);
  }
  function ho(n, m) {
    u("Immutable", n, m);
  }
  function mo(n, m) {
    u("UserWhitespacable", n, m);
  }
  function yo(n, m) {
    u("Method", n, m);
  }
  function To(n, m) {
    u("ObjectMember", n, m);
  }
  function So(n, m) {
    u("Property", n, m);
  }
  function go(n, m) {
    u("UnaryLike", n, m);
  }
  function bo(n, m) {
    u("Pattern", n, m);
  }
  function Bs(n, m) {
    u("Class", n, m);
  }
  function Eo(n, m) {
    u("ImportOrExportDeclaration", n, m);
  }
  function Po(n, m) {
    u("ExportDeclaration", n, m);
  }
  function xo(n, m) {
    u("ModuleSpecifier", n, m);
  }
  function vo(n, m) {
    u("Accessor", n, m);
  }
  function Ao(n, m) {
    u("Private", n, m);
  }
  function Co(n, m) {
    u("Flow", n, m);
  }
  function Io(n, m) {
    u("FlowType", n, m);
  }
  function wo(n, m) {
    u("FlowBaseAnnotation", n, m);
  }
  function Oo(n, m) {
    u("FlowDeclaration", n, m);
  }
  function No(n, m) {
    u("FlowPredicate", n, m);
  }
  function _o(n, m) {
    u("EnumBody", n, m);
  }
  function Do(n, m) {
    u("EnumMember", n, m);
  }
  function ko(n, m) {
    u("JSX", n, m);
  }
  function Lo(n, m) {
    u("Miscellaneous", n, m);
  }
  function Mo(n, m) {
    u("TypeScript", n, m);
  }
  function Bo(n, m) {
    u("TSTypeElement", n, m);
  }
  function Fo(n, m) {
    u("TSType", n, m);
  }
  function Ro(n, m) {
    u("TSBaseType", n, m);
  }
  function jo(n, m) {
    (0, l.default)("assertNumberLiteral", "assertNumericLiteral"), u("NumberLiteral", n, m);
  }
  function qo(n, m) {
    (0, l.default)("assertRegexLiteral", "assertRegExpLiteral"), u("RegexLiteral", n, m);
  }
  function Uo(n, m) {
    (0, l.default)("assertRestProperty", "assertRestElement"), u("RestProperty", n, m);
  }
  function Vo(n, m) {
    (0, l.default)("assertSpreadProperty", "assertSpreadElement"), u("SpreadProperty", n, m);
  }
  function s(n, m) {
    (0, l.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), u("ModuleDeclaration", n, m);
  }
  return $;
}
var fs = {}, su;
function Ef() {
  if (su) return fs;
  su = 1, Object.defineProperty(fs, "__esModule", {
    value: !0
  }), fs.default = void 0;
  var i = Vt();
  fs.default = l;
  function l(u) {
    switch (u) {
      case "string":
        return (0, i.stringTypeAnnotation)();
      case "number":
        return (0, i.numberTypeAnnotation)();
      case "undefined":
        return (0, i.voidTypeAnnotation)();
      case "boolean":
        return (0, i.booleanTypeAnnotation)();
      case "function":
        return (0, i.genericTypeAnnotation)((0, i.identifier)("Function"));
      case "object":
        return (0, i.genericTypeAnnotation)((0, i.identifier)("Object"));
      case "symbol":
        return (0, i.genericTypeAnnotation)((0, i.identifier)("Symbol"));
      case "bigint":
        return (0, i.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + u);
  }
  return fs;
}
var Qs = {}, Zs = {}, au;
function wp() {
  if (au) return Zs;
  au = 1, Object.defineProperty(Zs, "__esModule", {
    value: !0
  }), Zs.default = u;
  var i = bt();
  function l(o) {
    return (0, i.isIdentifier)(o) ? o.name : `${o.id.name}.${l(o.qualification)}`;
  }
  function u(o) {
    const f = Array.from(o), p = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Set(), x = [];
    for (let A = 0; A < f.length; A++) {
      const g = f[A];
      if (g && !x.includes(g)) {
        if ((0, i.isAnyTypeAnnotation)(g))
          return [g];
        if ((0, i.isFlowBaseAnnotation)(g)) {
          P.set(g.type, g);
          continue;
        }
        if ((0, i.isUnionTypeAnnotation)(g)) {
          w.has(g.types) || (f.push(...g.types), w.add(g.types));
          continue;
        }
        if ((0, i.isGenericTypeAnnotation)(g)) {
          const I = l(g.id);
          if (p.has(I)) {
            let v = p.get(I);
            v.typeParameters ? g.typeParameters && (v.typeParameters.params.push(...g.typeParameters.params), v.typeParameters.params = u(v.typeParameters.params)) : v = g.typeParameters;
          } else
            p.set(I, g);
          continue;
        }
        x.push(g);
      }
    }
    for (const [, A] of P)
      x.push(A);
    for (const [, A] of p)
      x.push(A);
    return x;
  }
  return Zs;
}
var ou;
function Pf() {
  if (ou) return Qs;
  ou = 1, Object.defineProperty(Qs, "__esModule", {
    value: !0
  }), Qs.default = u;
  var i = Vt(), l = wp();
  function u(o) {
    const f = (0, l.default)(o);
    return f.length === 1 ? f[0] : (0, i.unionTypeAnnotation)(f);
  }
  return Qs;
}
var ea = {}, ta = {}, lu;
function xf() {
  if (lu) return ta;
  lu = 1, Object.defineProperty(ta, "__esModule", {
    value: !0
  }), ta.default = u;
  var i = bt();
  function l(o) {
    return (0, i.isIdentifier)(o) ? o.name : (0, i.isThisExpression)(o) ? "this" : `${o.right.name}.${l(o.left)}`;
  }
  function u(o) {
    const f = Array.from(o), p = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Set(), x = [];
    for (let A = 0; A < f.length; A++) {
      const g = f[A];
      if (!g || x.includes(g))
        continue;
      if ((0, i.isTSAnyKeyword)(g))
        return [g];
      if ((0, i.isTSBaseType)(g)) {
        P.set(g.type, g);
        continue;
      }
      if ((0, i.isTSUnionType)(g)) {
        w.has(g.types) || (f.push(...g.types), w.add(g.types));
        continue;
      }
      const I = "typeParameters";
      if ((0, i.isTSTypeReference)(g) && g[I]) {
        const v = g[I], S = l(g.typeName);
        if (p.has(S)) {
          let _ = p.get(S);
          const B = _[I];
          B ? (B.params.push(...v.params), B.params = u(B.params)) : _ = v;
        } else
          p.set(S, g);
        continue;
      }
      x.push(g);
    }
    for (const [, A] of P)
      x.push(A);
    for (const [, A] of p)
      x.push(A);
    return x;
  }
  return ta;
}
var uu;
function vf() {
  if (uu) return ea;
  uu = 1, Object.defineProperty(ea, "__esModule", {
    value: !0
  }), ea.default = o;
  var i = Vt(), l = xf(), u = bt();
  function o(f) {
    const p = f.map((w) => (0, u.isTSTypeAnnotation)(w) ? w.typeAnnotation : w), P = (0, l.default)(p);
    return P.length === 1 ? P[0] : (0, i.tsUnionType)(P);
  }
  return ea;
}
var ra = {}, cu;
function Op() {
  if (cu) return ra;
  cu = 1, Object.defineProperty(ra, "__esModule", {
    value: !0
  }), ra.buildUndefinedNode = l;
  var i = Vt();
  function l() {
    return (0, i.unaryExpression)("void", (0, i.numericLiteral)(0), !0);
  }
  return ra;
}
var ia = {}, pu;
function Qi() {
  if (pu) return ia;
  pu = 1, Object.defineProperty(ia, "__esModule", {
    value: !0
  }), ia.default = p;
  var i = tr(), l = bt();
  const {
    hasOwn: u
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function o(x, A, g, I) {
    return x && typeof x.type == "string" ? P(x, A, g, I) : x;
  }
  function f(x, A, g, I) {
    return Array.isArray(x) ? x.map((v) => o(v, A, g, I)) : o(x, A, g, I);
  }
  function p(x, A = !0, g = !1) {
    return P(x, A, g, /* @__PURE__ */ new Map());
  }
  function P(x, A = !0, g = !1, I) {
    if (!x) return x;
    const {
      type: v
    } = x, S = {
      type: x.type
    };
    if ((0, l.isIdentifier)(x))
      S.name = x.name, u(x, "optional") && typeof x.optional == "boolean" && (S.optional = x.optional), u(x, "typeAnnotation") && (S.typeAnnotation = A ? f(x.typeAnnotation, !0, g, I) : x.typeAnnotation), u(x, "decorators") && (S.decorators = A ? f(x.decorators, !0, g, I) : x.decorators);
    else if (u(i.NODE_FIELDS, v))
      for (const _ of Object.keys(i.NODE_FIELDS[v]))
        u(x, _) && (A ? S[_] = (0, l.isFile)(x) && _ === "comments" ? w(x.comments, A, g, I) : f(x[_], !0, g, I) : S[_] = x[_]);
    else
      throw new Error(`Unknown node type: "${v}"`);
    return u(x, "loc") && (g ? S.loc = null : S.loc = x.loc), u(x, "leadingComments") && (S.leadingComments = w(x.leadingComments, A, g, I)), u(x, "innerComments") && (S.innerComments = w(x.innerComments, A, g, I)), u(x, "trailingComments") && (S.trailingComments = w(x.trailingComments, A, g, I)), u(x, "extra") && (S.extra = Object.assign({}, x.extra)), S;
  }
  function w(x, A, g, I) {
    return !x || !A ? x : x.map((v) => {
      const S = I.get(v);
      if (S) return S;
      const {
        type: _,
        value: B,
        loc: y
      } = v, X = {
        type: _,
        value: B,
        loc: y
      };
      return g && (X.loc = null), I.set(v, X), X;
    });
  }
  return ia;
}
var na = {}, fu;
function Af() {
  if (fu) return na;
  fu = 1, Object.defineProperty(na, "__esModule", {
    value: !0
  }), na.default = l;
  var i = Qi();
  function l(u) {
    return (0, i.default)(u, !1);
  }
  return na;
}
var sa = {}, hu;
function Cf() {
  if (hu) return sa;
  hu = 1, Object.defineProperty(sa, "__esModule", {
    value: !0
  }), sa.default = l;
  var i = Qi();
  function l(u) {
    return (0, i.default)(u);
  }
  return sa;
}
var aa = {}, du;
function If() {
  if (du) return aa;
  du = 1, Object.defineProperty(aa, "__esModule", {
    value: !0
  }), aa.default = l;
  var i = Qi();
  function l(u) {
    return (0, i.default)(u, !0, !0);
  }
  return aa;
}
var oa = {}, mu;
function wf() {
  if (mu) return oa;
  mu = 1, Object.defineProperty(oa, "__esModule", {
    value: !0
  }), oa.default = l;
  var i = Qi();
  function l(u) {
    return (0, i.default)(u, !1, !0);
  }
  return oa;
}
var la = {}, ua = {}, yu;
function Np() {
  if (yu) return ua;
  yu = 1, Object.defineProperty(ua, "__esModule", {
    value: !0
  }), ua.default = i;
  function i(l, u, o) {
    if (!o || !l) return l;
    const f = `${u}Comments`;
    return l[f] ? u === "leading" ? l[f] = o.concat(l[f]) : l[f].push(...o) : l[f] = o, l;
  }
  return ua;
}
var Tu;
function Of() {
  if (Tu) return la;
  Tu = 1, Object.defineProperty(la, "__esModule", {
    value: !0
  }), la.default = l;
  var i = Np();
  function l(u, o, f, p) {
    return (0, i.default)(u, o, [{
      type: p ? "CommentLine" : "CommentBlock",
      value: f
    }]);
  }
  return la;
}
var ca = {}, pa = {}, Su;
function ol() {
  if (Su) return pa;
  Su = 1, Object.defineProperty(pa, "__esModule", {
    value: !0
  }), pa.default = i;
  function i(l, u, o) {
    u && o && (u[l] = Array.from(new Set([].concat(u[l], o[l]).filter(Boolean))));
  }
  return pa;
}
var gu;
function _p() {
  if (gu) return ca;
  gu = 1, Object.defineProperty(ca, "__esModule", {
    value: !0
  }), ca.default = l;
  var i = ol();
  function l(u, o) {
    (0, i.default)("innerComments", u, o);
  }
  return ca;
}
var fa = {}, bu;
function Dp() {
  if (bu) return fa;
  bu = 1, Object.defineProperty(fa, "__esModule", {
    value: !0
  }), fa.default = l;
  var i = ol();
  function l(u, o) {
    (0, i.default)("leadingComments", u, o);
  }
  return fa;
}
var ha = {}, da = {}, Eu;
function kp() {
  if (Eu) return da;
  Eu = 1, Object.defineProperty(da, "__esModule", {
    value: !0
  }), da.default = l;
  var i = ol();
  function l(u, o) {
    (0, i.default)("trailingComments", u, o);
  }
  return da;
}
var Pu;
function Lp() {
  if (Pu) return ha;
  Pu = 1, Object.defineProperty(ha, "__esModule", {
    value: !0
  }), ha.default = o;
  var i = kp(), l = Dp(), u = _p();
  function o(f, p) {
    return (0, i.default)(f, p), (0, l.default)(f, p), (0, u.default)(f, p), f;
  }
  return ha;
}
var ma = {}, xu;
function Nf() {
  if (xu) return ma;
  xu = 1, Object.defineProperty(ma, "__esModule", {
    value: !0
  }), ma.default = l;
  var i = zi();
  function l(u) {
    return i.COMMENT_KEYS.forEach((o) => {
      u[o] = null;
    }), u;
  }
  return ma;
}
var Oe = {}, vu;
function _f() {
  if (vu) return Oe;
  vu = 1, Object.defineProperty(Oe, "__esModule", {
    value: !0
  }), Oe.WHILE_TYPES = Oe.USERWHITESPACABLE_TYPES = Oe.UNARYLIKE_TYPES = Oe.TYPESCRIPT_TYPES = Oe.TSTYPE_TYPES = Oe.TSTYPEELEMENT_TYPES = Oe.TSENTITYNAME_TYPES = Oe.TSBASETYPE_TYPES = Oe.TERMINATORLESS_TYPES = Oe.STATEMENT_TYPES = Oe.STANDARDIZED_TYPES = Oe.SCOPABLE_TYPES = Oe.PUREISH_TYPES = Oe.PROPERTY_TYPES = Oe.PRIVATE_TYPES = Oe.PATTERN_TYPES = Oe.PATTERNLIKE_TYPES = Oe.OBJECTMEMBER_TYPES = Oe.MODULESPECIFIER_TYPES = Oe.MODULEDECLARATION_TYPES = Oe.MISCELLANEOUS_TYPES = Oe.METHOD_TYPES = Oe.LVAL_TYPES = Oe.LOOP_TYPES = Oe.LITERAL_TYPES = Oe.JSX_TYPES = Oe.IMPORTOREXPORTDECLARATION_TYPES = Oe.IMMUTABLE_TYPES = Oe.FUNCTION_TYPES = Oe.FUNCTIONPARENT_TYPES = Oe.FOR_TYPES = Oe.FORXSTATEMENT_TYPES = Oe.FLOW_TYPES = Oe.FLOWTYPE_TYPES = Oe.FLOWPREDICATE_TYPES = Oe.FLOWDECLARATION_TYPES = Oe.FLOWBASEANNOTATION_TYPES = Oe.EXPRESSION_TYPES = Oe.EXPRESSIONWRAPPER_TYPES = Oe.EXPORTDECLARATION_TYPES = Oe.ENUMMEMBER_TYPES = Oe.ENUMBODY_TYPES = Oe.DECLARATION_TYPES = Oe.CONDITIONAL_TYPES = Oe.COMPLETIONSTATEMENT_TYPES = Oe.CLASS_TYPES = Oe.BLOCK_TYPES = Oe.BLOCKPARENT_TYPES = Oe.BINARY_TYPES = Oe.ACCESSOR_TYPES = void 0;
  var i = tr();
  Oe.STANDARDIZED_TYPES = i.FLIPPED_ALIAS_KEYS.Standardized, Oe.EXPRESSION_TYPES = i.FLIPPED_ALIAS_KEYS.Expression, Oe.BINARY_TYPES = i.FLIPPED_ALIAS_KEYS.Binary, Oe.SCOPABLE_TYPES = i.FLIPPED_ALIAS_KEYS.Scopable, Oe.BLOCKPARENT_TYPES = i.FLIPPED_ALIAS_KEYS.BlockParent, Oe.BLOCK_TYPES = i.FLIPPED_ALIAS_KEYS.Block, Oe.STATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.Statement, Oe.TERMINATORLESS_TYPES = i.FLIPPED_ALIAS_KEYS.Terminatorless, Oe.COMPLETIONSTATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.CompletionStatement, Oe.CONDITIONAL_TYPES = i.FLIPPED_ALIAS_KEYS.Conditional, Oe.LOOP_TYPES = i.FLIPPED_ALIAS_KEYS.Loop, Oe.WHILE_TYPES = i.FLIPPED_ALIAS_KEYS.While, Oe.EXPRESSIONWRAPPER_TYPES = i.FLIPPED_ALIAS_KEYS.ExpressionWrapper, Oe.FOR_TYPES = i.FLIPPED_ALIAS_KEYS.For, Oe.FORXSTATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.ForXStatement, Oe.FUNCTION_TYPES = i.FLIPPED_ALIAS_KEYS.Function, Oe.FUNCTIONPARENT_TYPES = i.FLIPPED_ALIAS_KEYS.FunctionParent, Oe.PUREISH_TYPES = i.FLIPPED_ALIAS_KEYS.Pureish, Oe.DECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.Declaration, Oe.PATTERNLIKE_TYPES = i.FLIPPED_ALIAS_KEYS.PatternLike, Oe.LVAL_TYPES = i.FLIPPED_ALIAS_KEYS.LVal, Oe.TSENTITYNAME_TYPES = i.FLIPPED_ALIAS_KEYS.TSEntityName, Oe.LITERAL_TYPES = i.FLIPPED_ALIAS_KEYS.Literal, Oe.IMMUTABLE_TYPES = i.FLIPPED_ALIAS_KEYS.Immutable, Oe.USERWHITESPACABLE_TYPES = i.FLIPPED_ALIAS_KEYS.UserWhitespacable, Oe.METHOD_TYPES = i.FLIPPED_ALIAS_KEYS.Method, Oe.OBJECTMEMBER_TYPES = i.FLIPPED_ALIAS_KEYS.ObjectMember, Oe.PROPERTY_TYPES = i.FLIPPED_ALIAS_KEYS.Property, Oe.UNARYLIKE_TYPES = i.FLIPPED_ALIAS_KEYS.UnaryLike, Oe.PATTERN_TYPES = i.FLIPPED_ALIAS_KEYS.Pattern, Oe.CLASS_TYPES = i.FLIPPED_ALIAS_KEYS.Class;
  const l = Oe.IMPORTOREXPORTDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
  return Oe.EXPORTDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.ExportDeclaration, Oe.MODULESPECIFIER_TYPES = i.FLIPPED_ALIAS_KEYS.ModuleSpecifier, Oe.ACCESSOR_TYPES = i.FLIPPED_ALIAS_KEYS.Accessor, Oe.PRIVATE_TYPES = i.FLIPPED_ALIAS_KEYS.Private, Oe.FLOW_TYPES = i.FLIPPED_ALIAS_KEYS.Flow, Oe.FLOWTYPE_TYPES = i.FLIPPED_ALIAS_KEYS.FlowType, Oe.FLOWBASEANNOTATION_TYPES = i.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, Oe.FLOWDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.FlowDeclaration, Oe.FLOWPREDICATE_TYPES = i.FLIPPED_ALIAS_KEYS.FlowPredicate, Oe.ENUMBODY_TYPES = i.FLIPPED_ALIAS_KEYS.EnumBody, Oe.ENUMMEMBER_TYPES = i.FLIPPED_ALIAS_KEYS.EnumMember, Oe.JSX_TYPES = i.FLIPPED_ALIAS_KEYS.JSX, Oe.MISCELLANEOUS_TYPES = i.FLIPPED_ALIAS_KEYS.Miscellaneous, Oe.TYPESCRIPT_TYPES = i.FLIPPED_ALIAS_KEYS.TypeScript, Oe.TSTYPEELEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.TSTypeElement, Oe.TSTYPE_TYPES = i.FLIPPED_ALIAS_KEYS.TSType, Oe.TSBASETYPE_TYPES = i.FLIPPED_ALIAS_KEYS.TSBaseType, Oe.MODULEDECLARATION_TYPES = l, Oe;
}
var ya = {}, Ta = {}, Au;
function Mp() {
  if (Au) return Ta;
  Au = 1, Object.defineProperty(Ta, "__esModule", {
    value: !0
  }), Ta.default = u;
  var i = bt(), l = Vt();
  function u(o, f) {
    if ((0, i.isBlockStatement)(o))
      return o;
    let p = [];
    return (0, i.isEmptyStatement)(o) ? p = [] : ((0, i.isStatement)(o) || ((0, i.isFunction)(f) ? o = (0, l.returnStatement)(o) : o = (0, l.expressionStatement)(o)), p = [o]), (0, l.blockStatement)(p);
  }
  return Ta;
}
var Cu;
function Df() {
  if (Cu) return ya;
  Cu = 1, Object.defineProperty(ya, "__esModule", {
    value: !0
  }), ya.default = l;
  var i = Mp();
  function l(u, o = "body") {
    const f = (0, i.default)(u[o], u);
    return u[o] = f, f;
  }
  return ya;
}
var Sa = {}, ga = {}, Iu;
function Bp() {
  if (Iu) return ga;
  Iu = 1, Object.defineProperty(ga, "__esModule", {
    value: !0
  }), ga.default = u;
  var i = Ms(), l = to();
  function u(o) {
    o = o + "";
    let f = "";
    for (const p of o)
      f += (0, l.isIdentifierChar)(p.codePointAt(0)) ? p : "-";
    return f = f.replace(/^[-0-9]+/, ""), f = f.replace(/[-\s]+(.)?/g, function(p, P) {
      return P ? P.toUpperCase() : "";
    }), (0, i.default)(f) || (f = `_${f}`), f || "_";
  }
  return ga;
}
var wu;
function kf() {
  if (wu) return Sa;
  wu = 1, Object.defineProperty(Sa, "__esModule", {
    value: !0
  }), Sa.default = l;
  var i = Bp();
  function l(u) {
    return u = (0, i.default)(u), (u === "eval" || u === "arguments") && (u = "_" + u), u;
  }
  return Sa;
}
var ba = {}, Ou;
function Lf() {
  if (Ou) return ba;
  Ou = 1, Object.defineProperty(ba, "__esModule", {
    value: !0
  }), ba.default = u;
  var i = bt(), l = Vt();
  function u(o, f = o.key || o.property) {
    return !o.computed && (0, i.isIdentifier)(f) && (f = (0, l.stringLiteral)(f.name)), f;
  }
  return ba;
}
var hs = {}, Nu;
function Mf() {
  if (Nu) return hs;
  Nu = 1, Object.defineProperty(hs, "__esModule", {
    value: !0
  }), hs.default = void 0;
  var i = bt();
  hs.default = l;
  function l(u) {
    if ((0, i.isExpressionStatement)(u) && (u = u.expression), (0, i.isExpression)(u))
      return u;
    if ((0, i.isClass)(u) ? u.type = "ClassExpression" : (0, i.isFunction)(u) && (u.type = "FunctionExpression"), !(0, i.isExpression)(u))
      throw new Error(`cannot turn ${u.type} to an expression`);
    return u;
  }
  return hs;
}
var Ea = {}, Pa = {}, xa = {}, _u;
function Fp() {
  if (_u) return xa;
  _u = 1, Object.defineProperty(xa, "__esModule", {
    value: !0
  }), xa.default = l;
  var i = tr();
  function l(u, o, f) {
    if (!u) return;
    const p = i.VISITOR_KEYS[u.type];
    if (p) {
      f = f || {}, o(u, f);
      for (const P of p) {
        const w = u[P];
        if (Array.isArray(w))
          for (const x of w)
            l(x, o, f);
        else
          l(w, o, f);
      }
    }
  }
  return xa;
}
var va = {}, Du;
function Rp() {
  if (Du) return va;
  Du = 1, Object.defineProperty(va, "__esModule", {
    value: !0
  }), va.default = o;
  var i = zi();
  const l = ["tokens", "start", "end", "loc", "raw", "rawValue"], u = [...i.COMMENT_KEYS, "comments", ...l];
  function o(f, p = {}) {
    const P = p.preserveComments ? l : u;
    for (const x of P)
      f[x] != null && (f[x] = void 0);
    for (const x of Object.keys(f))
      x[0] === "_" && f[x] != null && (f[x] = void 0);
    const w = Object.getOwnPropertySymbols(f);
    for (const x of w)
      f[x] = null;
  }
  return va;
}
var ku;
function jp() {
  if (ku) return Pa;
  ku = 1, Object.defineProperty(Pa, "__esModule", {
    value: !0
  }), Pa.default = u;
  var i = Fp(), l = Rp();
  function u(o, f) {
    return (0, i.default)(o, l.default, f), o;
  }
  return Pa;
}
var Lu;
function Bf() {
  if (Lu) return Ea;
  Lu = 1, Object.defineProperty(Ea, "__esModule", {
    value: !0
  }), Ea.default = o;
  var i = bt(), l = Qi(), u = jp();
  function o(f, p = f.key) {
    let P;
    return f.kind === "method" ? o.increment() + "" : ((0, i.isIdentifier)(p) ? P = p.name : (0, i.isStringLiteral)(p) ? P = JSON.stringify(p.value) : P = JSON.stringify((0, u.default)((0, l.default)(p))), f.computed && (P = `[${P}]`), f.static && (P = `static:${P}`), P);
  }
  return o.uid = 0, o.increment = function() {
    return o.uid >= Number.MAX_SAFE_INTEGER ? o.uid = 0 : o.uid++;
  }, Ea;
}
var ds = {}, Mu;
function Ff() {
  if (Mu) return ds;
  Mu = 1, Object.defineProperty(ds, "__esModule", {
    value: !0
  }), ds.default = void 0;
  var i = bt(), l = Vt();
  ds.default = u;
  function u(o, f) {
    if ((0, i.isStatement)(o))
      return o;
    let p = !1, P;
    if ((0, i.isClass)(o))
      p = !0, P = "ClassDeclaration";
    else if ((0, i.isFunction)(o))
      p = !0, P = "FunctionDeclaration";
    else if ((0, i.isAssignmentExpression)(o))
      return (0, l.expressionStatement)(o);
    if (p && !o.id && (P = !1), !P) {
      if (f)
        return !1;
      throw new Error(`cannot turn ${o.type} to a statement`);
    }
    return o.type = P, o;
  }
  return ds;
}
var ms = {}, Bu;
function Rf() {
  if (Bu) return ms;
  Bu = 1, Object.defineProperty(ms, "__esModule", {
    value: !0
  }), ms.default = void 0;
  var i = Ms(), l = Vt();
  ms.default = p;
  const u = Function.call.bind(Object.prototype.toString);
  function o(P) {
    return u(P) === "[object RegExp]";
  }
  function f(P) {
    if (typeof P != "object" || P === null || Object.prototype.toString.call(P) !== "[object Object]")
      return !1;
    const w = Object.getPrototypeOf(P);
    return w === null || Object.getPrototypeOf(w) === null;
  }
  function p(P) {
    if (P === void 0)
      return (0, l.identifier)("undefined");
    if (P === !0 || P === !1)
      return (0, l.booleanLiteral)(P);
    if (P === null)
      return (0, l.nullLiteral)();
    if (typeof P == "string")
      return (0, l.stringLiteral)(P);
    if (typeof P == "number") {
      let w;
      if (Number.isFinite(P))
        w = (0, l.numericLiteral)(Math.abs(P));
      else {
        let x;
        Number.isNaN(P) ? x = (0, l.numericLiteral)(0) : x = (0, l.numericLiteral)(1), w = (0, l.binaryExpression)("/", x, (0, l.numericLiteral)(0));
      }
      return (P < 0 || Object.is(P, -0)) && (w = (0, l.unaryExpression)("-", w)), w;
    }
    if (o(P)) {
      const w = P.source, x = /\/([a-z]*)$/.exec(P.toString())[1];
      return (0, l.regExpLiteral)(w, x);
    }
    if (Array.isArray(P))
      return (0, l.arrayExpression)(P.map(p));
    if (f(P)) {
      const w = [];
      for (const x of Object.keys(P)) {
        let A;
        (0, i.default)(x) ? A = (0, l.identifier)(x) : A = (0, l.stringLiteral)(x), w.push((0, l.objectProperty)(A, p(P[x])));
      }
      return (0, l.objectExpression)(w);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return ms;
}
var Aa = {}, Fu;
function jf() {
  if (Fu) return Aa;
  Fu = 1, Object.defineProperty(Aa, "__esModule", {
    value: !0
  }), Aa.default = l;
  var i = Vt();
  function l(u, o, f = !1) {
    return u.object = (0, i.memberExpression)(u.object, u.property, u.computed), u.property = o, u.computed = !!f, u;
  }
  return Aa;
}
var Ca = {}, Ru;
function qf() {
  if (Ru) return Ca;
  Ru = 1, Object.defineProperty(Ca, "__esModule", {
    value: !0
  }), Ca.default = u;
  var i = zi(), l = Lp();
  function u(o, f) {
    if (!o || !f) return o;
    for (const p of i.INHERIT_KEYS.optional)
      o[p] == null && (o[p] = f[p]);
    for (const p of Object.keys(f))
      p[0] === "_" && p !== "__clone" && (o[p] = f[p]);
    for (const p of i.INHERIT_KEYS.force)
      o[p] = f[p];
    return (0, l.default)(o, f), o;
  }
  return Ca;
}
var Ia = {}, ju;
function Uf() {
  if (ju) return Ia;
  ju = 1, Object.defineProperty(Ia, "__esModule", {
    value: !0
  }), Ia.default = u;
  var i = Vt(), l = Ze();
  function u(o, f) {
    if ((0, l.isSuper)(o.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return o.object = (0, i.memberExpression)(f, o.object), o;
  }
  return Ia;
}
var wa = {}, qu;
function Vf() {
  if (qu) return wa;
  qu = 1, Object.defineProperty(wa, "__esModule", {
    value: !0
  }), wa.default = i;
  function i(l) {
    const u = [].concat(l), o = /* @__PURE__ */ Object.create(null);
    for (; u.length; ) {
      const f = u.pop();
      if (f)
        switch (f.type) {
          case "ArrayPattern":
            u.push(...f.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            u.push(f.left);
            break;
          case "ObjectPattern":
            u.push(...f.properties);
            break;
          case "ObjectProperty":
            u.push(f.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            u.push(f.argument);
            break;
          case "UnaryExpression":
            f.operator === "delete" && u.push(f.argument);
            break;
          case "Identifier":
            o[f.name] = f;
            break;
        }
    }
    return o;
  }
  return wa;
}
var Oa = {}, Uu;
function io() {
  if (Uu) return Oa;
  Uu = 1, Object.defineProperty(Oa, "__esModule", {
    value: !0
  }), Oa.default = l;
  var i = bt();
  function l(o, f, p, P) {
    const w = [].concat(o), x = /* @__PURE__ */ Object.create(null);
    for (; w.length; ) {
      const A = w.shift();
      if (!A || P && ((0, i.isAssignmentExpression)(A) || (0, i.isUnaryExpression)(A) || (0, i.isUpdateExpression)(A)))
        continue;
      if ((0, i.isIdentifier)(A)) {
        f ? (x[A.name] = x[A.name] || []).push(A) : x[A.name] = A;
        continue;
      }
      if ((0, i.isExportDeclaration)(A) && !(0, i.isExportAllDeclaration)(A)) {
        (0, i.isDeclaration)(A.declaration) && w.push(A.declaration);
        continue;
      }
      if (p) {
        if ((0, i.isFunctionDeclaration)(A)) {
          w.push(A.id);
          continue;
        }
        if ((0, i.isFunctionExpression)(A))
          continue;
      }
      const g = l.keys[A.type];
      if (g)
        for (let I = 0; I < g.length; I++) {
          const v = g[I], S = A[v];
          S && (Array.isArray(S) ? w.push(...S) : w.push(S));
        }
    }
    return x;
  }
  const u = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  return l.keys = u, Oa;
}
var ys = {}, Vu;
function Kf() {
  if (Vu) return ys;
  Vu = 1, Object.defineProperty(ys, "__esModule", {
    value: !0
  }), ys.default = void 0;
  var i = io();
  ys.default = l;
  function l(u, o) {
    return (0, i.default)(u, o, !0);
  }
  return ys;
}
var Na = {}, Ku;
function Wf() {
  if (Ku) return Na;
  Ku = 1, Object.defineProperty(Na, "__esModule", {
    value: !0
  }), Na.default = o;
  var i = bt();
  function l(f) {
    return (0, i.isNullLiteral)(f) ? "null" : (0, i.isRegExpLiteral)(f) ? `/${f.pattern}/${f.flags}` : (0, i.isTemplateLiteral)(f) ? f.quasis.map((p) => p.value.raw).join("") : f.value !== void 0 ? String(f.value) : null;
  }
  function u(f) {
    if (!f.computed || (0, i.isLiteral)(f.key))
      return f.key;
  }
  function o(f, p) {
    if ("id" in f && f.id)
      return {
        name: f.id.name,
        originalNode: f.id
      };
    let P = "", w;
    if ((0, i.isObjectProperty)(p, {
      value: f
    }) ? w = u(p) : (0, i.isObjectMethod)(f) || (0, i.isClassMethod)(f) ? (w = u(f), f.kind === "get" ? P = "get " : f.kind === "set" && (P = "set ")) : (0, i.isVariableDeclarator)(p, {
      init: f
    }) ? w = p.id : (0, i.isAssignmentExpression)(p, {
      operator: "=",
      right: f
    }) && (w = p.left), !w) return null;
    const x = (0, i.isLiteral)(w) ? l(w) : (0, i.isIdentifier)(w) ? w.name : (0, i.isPrivateName)(w) ? w.id.name : null;
    return x == null ? null : {
      name: P + x,
      originalNode: w
    };
  }
  return Na;
}
var _a = {}, Wu;
function $f() {
  if (Wu) return _a;
  Wu = 1, Object.defineProperty(_a, "__esModule", {
    value: !0
  }), _a.default = l;
  var i = tr();
  function l(o, f, p) {
    typeof f == "function" && (f = {
      enter: f
    });
    const {
      enter: P,
      exit: w
    } = f;
    u(o, P, w, p, []);
  }
  function u(o, f, p, P, w) {
    const x = i.VISITOR_KEYS[o.type];
    if (x) {
      f && f(o, w, P);
      for (const A of x) {
        const g = o[A];
        if (Array.isArray(g))
          for (let I = 0; I < g.length; I++) {
            const v = g[I];
            v && (w.push({
              node: o,
              key: A,
              index: I
            }), u(v, f, p, P, w), w.pop());
          }
        else g && (w.push({
          node: o,
          key: A
        }), u(g, f, p, P, w), w.pop());
      }
      p && p(o, w, P);
    }
  }
  return _a;
}
var Da = {}, $u;
function Jf() {
  if ($u) return Da;
  $u = 1, Object.defineProperty(Da, "__esModule", {
    value: !0
  }), Da.default = l;
  var i = io();
  function l(u, o, f) {
    if (f && u.type === "Identifier" && o.type === "ObjectProperty" && f.type === "ObjectExpression")
      return !1;
    const p = i.default.keys[o.type];
    if (p)
      for (let P = 0; P < p.length; P++) {
        const w = p[P], x = o[w];
        if (Array.isArray(x)) {
          if (x.includes(u)) return !0;
        } else if (x === u) return !0;
      }
    return !1;
  }
  return Da;
}
var ka = {}, La = {}, Ju;
function qp() {
  if (Ju) return La;
  Ju = 1, Object.defineProperty(La, "__esModule", {
    value: !0
  }), La.default = u;
  var i = bt(), l = zi();
  function u(o) {
    return (0, i.isVariableDeclaration)(o) && (o.kind !== "var" || o[l.BLOCK_SCOPED_SYMBOL]);
  }
  return La;
}
var Xu;
function Xf() {
  if (Xu) return ka;
  Xu = 1, Object.defineProperty(ka, "__esModule", {
    value: !0
  }), ka.default = u;
  var i = bt(), l = qp();
  function u(o) {
    return (0, i.isFunctionDeclaration)(o) || (0, i.isClassDeclaration)(o) || (0, l.default)(o);
  }
  return ka;
}
var Ma = {}, Yu;
function Yf() {
  if (Yu) return Ma;
  Yu = 1, Object.defineProperty(Ma, "__esModule", {
    value: !0
  }), Ma.default = u;
  var i = sl(), l = bt();
  function u(o) {
    return (0, i.default)(o.type, "Immutable") ? !0 : (0, l.isIdentifier)(o) ? o.name === "undefined" : !1;
  }
  return Ma;
}
var Ba = {}, Hu;
function Hf() {
  if (Hu) return Ba;
  Hu = 1, Object.defineProperty(Ba, "__esModule", {
    value: !0
  }), Ba.default = l;
  var i = tr();
  function l(u, o) {
    if (typeof u != "object" || typeof o != "object" || u == null || o == null)
      return u === o;
    if (u.type !== o.type)
      return !1;
    const f = Object.keys(i.NODE_FIELDS[u.type] || u.type), p = i.VISITOR_KEYS[u.type];
    for (const P of f) {
      const w = u[P], x = o[P];
      if (typeof w != typeof x)
        return !1;
      if (!(w == null && x == null)) {
        if (w == null || x == null)
          return !1;
        if (Array.isArray(w)) {
          if (!Array.isArray(x) || w.length !== x.length)
            return !1;
          for (let A = 0; A < w.length; A++)
            if (!l(w[A], x[A]))
              return !1;
          continue;
        }
        if (typeof w == "object" && !(p != null && p.includes(P))) {
          for (const A of Object.keys(w))
            if (w[A] !== x[A])
              return !1;
          continue;
        }
        if (!l(w, x))
          return !1;
      }
    }
    return !0;
  }
  return Ba;
}
var Fa = {}, Gu;
function Gf() {
  if (Gu) return Fa;
  Gu = 1, Object.defineProperty(Fa, "__esModule", {
    value: !0
  }), Fa.default = i;
  function i(l, u, o) {
    switch (u.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return u.property === l ? !!u.computed : u.object === l;
      case "JSXMemberExpression":
        return u.object === l;
      case "VariableDeclarator":
        return u.init === l;
      case "ArrowFunctionExpression":
        return u.body === l;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return u.key === l ? !!u.computed : !1;
      case "ObjectProperty":
        return u.key === l ? !!u.computed : !o || o.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return u.key === l ? !!u.computed : !0;
      case "ClassPrivateProperty":
        return u.key !== l;
      case "ClassDeclaration":
      case "ClassExpression":
        return u.superClass === l;
      case "AssignmentExpression":
        return u.right === l;
      case "AssignmentPattern":
        return u.right === l;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return o != null && o.source ? !1 : u.local === l;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return u.key !== l;
      case "TSEnumMember":
        return u.id !== l;
      case "TSPropertySignature":
        return u.key === l ? !!u.computed : !0;
    }
    return !0;
  }
  return Fa;
}
var Ra = {}, zu;
function zf() {
  if (zu) return Ra;
  zu = 1, Object.defineProperty(Ra, "__esModule", {
    value: !0
  }), Ra.default = l;
  var i = bt();
  function l(u, o) {
    return (0, i.isBlockStatement)(u) && ((0, i.isFunction)(o) || (0, i.isCatchClause)(o)) ? !1 : (0, i.isPattern)(u) && ((0, i.isFunction)(o) || (0, i.isCatchClause)(o)) ? !0 : (0, i.isScopable)(u);
  }
  return Ra;
}
var ja = {}, Qu;
function Qf() {
  if (Qu) return ja;
  Qu = 1, Object.defineProperty(ja, "__esModule", {
    value: !0
  }), ja.default = l;
  var i = bt();
  function l(u) {
    return (0, i.isImportDefaultSpecifier)(u) || (0, i.isIdentifier)(u.imported || u.exported, {
      name: "default"
    });
  }
  return ja;
}
var qa = {}, Zu;
function Zf() {
  if (Zu) return qa;
  Zu = 1, Object.defineProperty(qa, "__esModule", {
    value: !0
  }), qa.default = u;
  var i = Ms();
  const l = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function u(o) {
    return (0, i.default)(o) && !l.has(o);
  }
  return qa;
}
var Ua = {}, ec;
function eh() {
  if (ec) return Ua;
  ec = 1, Object.defineProperty(Ua, "__esModule", {
    value: !0
  }), Ua.default = u;
  var i = bt(), l = zi();
  function u(o) {
    return (0, i.isVariableDeclaration)(o, {
      kind: "var"
    }) && !o[l.BLOCK_SCOPED_SYMBOL];
  }
  return Ua;
}
var Va = {}, Ka = {}, tc;
function th() {
  if (tc) return Ka;
  tc = 1, Object.defineProperty(Ka, "__esModule", {
    value: !0
  }), Ka.default = p;
  var i = io(), l = bt(), u = Vt(), o = Op(), f = Qi();
  function p(P, w) {
    const x = [];
    let A = !0;
    for (const g of P)
      if ((0, l.isEmptyStatement)(g) || (A = !1), (0, l.isExpression)(g))
        x.push(g);
      else if ((0, l.isExpressionStatement)(g))
        x.push(g.expression);
      else if ((0, l.isVariableDeclaration)(g)) {
        if (g.kind !== "var") return;
        for (const I of g.declarations) {
          const v = (0, i.default)(I);
          for (const S of Object.keys(v))
            w.push({
              kind: g.kind,
              id: (0, f.default)(v[S])
            });
          I.init && x.push((0, u.assignmentExpression)("=", I.id, I.init));
        }
        A = !0;
      } else if ((0, l.isIfStatement)(g)) {
        const I = g.consequent ? p([g.consequent], w) : (0, o.buildUndefinedNode)(), v = g.alternate ? p([g.alternate], w) : (0, o.buildUndefinedNode)();
        if (!I || !v) return;
        x.push((0, u.conditionalExpression)(g.test, I, v));
      } else if ((0, l.isBlockStatement)(g)) {
        const I = p(g.body, w);
        if (!I) return;
        x.push(I);
      } else if ((0, l.isEmptyStatement)(g))
        P.indexOf(g) === 0 && (A = !0);
      else
        return;
    return A && x.push((0, o.buildUndefinedNode)()), x.length === 1 ? x[0] : (0, u.sequenceExpression)(x);
  }
  return Ka;
}
var rc;
function rh() {
  if (rc) return Va;
  rc = 1, Object.defineProperty(Va, "__esModule", {
    value: !0
  }), Va.default = l;
  var i = th();
  function l(u, o) {
    if (!(u != null && u.length)) return;
    const f = [], p = (0, i.default)(u, f);
    if (p) {
      for (const P of f)
        o.push(P);
      return p;
    }
  }
  return Va;
}
var ic;
function Ze() {
  return ic || (ic = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    });
    var l = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getAssignmentIdentifiers: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      getFunctionName: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
      __internal__deprecationWarning: !0
    };
    Object.defineProperty(i, "__internal__deprecationWarning", {
      enumerable: !0,
      get: function() {
        return De.default;
      }
    }), Object.defineProperty(i, "addComment", {
      enumerable: !0,
      get: function() {
        return X.default;
      }
    }), Object.defineProperty(i, "addComments", {
      enumerable: !0,
      get: function() {
        return Z.default;
      }
    }), Object.defineProperty(i, "appendToMemberExpression", {
      enumerable: !0,
      get: function() {
        return ae.default;
      }
    }), Object.defineProperty(i, "assertNode", {
      enumerable: !0,
      get: function() {
        return p.default;
      }
    }), Object.defineProperty(i, "buildMatchMemberExpression", {
      enumerable: !0,
      get: function() {
        return ge.default;
      }
    }), Object.defineProperty(i, "clone", {
      enumerable: !0,
      get: function() {
        return S.default;
      }
    }), Object.defineProperty(i, "cloneDeep", {
      enumerable: !0,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(i, "cloneDeepWithoutLoc", {
      enumerable: !0,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(i, "cloneNode", {
      enumerable: !0,
      get: function() {
        return v.default;
      }
    }), Object.defineProperty(i, "cloneWithoutLoc", {
      enumerable: !0,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(i, "createFlowUnionType", {
      enumerable: !0,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(i, "createTSUnionType", {
      enumerable: !0,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(i, "createTypeAnnotationBasedOnTypeof", {
      enumerable: !0,
      get: function() {
        return w.default;
      }
    }), Object.defineProperty(i, "createUnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(i, "ensureBlock", {
      enumerable: !0,
      get: function() {
        return N.default;
      }
    }), Object.defineProperty(i, "getAssignmentIdentifiers", {
      enumerable: !0,
      get: function() {
        return we.default;
      }
    }), Object.defineProperty(i, "getBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return Ie.default;
      }
    }), Object.defineProperty(i, "getFunctionName", {
      enumerable: !0,
      get: function() {
        return fe.default;
      }
    }), Object.defineProperty(i, "getOuterBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return Le.default;
      }
    }), Object.defineProperty(i, "inheritInnerComments", {
      enumerable: !0,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(i, "inheritLeadingComments", {
      enumerable: !0,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(i, "inheritTrailingComments", {
      enumerable: !0,
      get: function() {
        return ee.default;
      }
    }), Object.defineProperty(i, "inherits", {
      enumerable: !0,
      get: function() {
        return ce.default;
      }
    }), Object.defineProperty(i, "inheritsComments", {
      enumerable: !0,
      get: function() {
        return O.default;
      }
    }), Object.defineProperty(i, "is", {
      enumerable: !0,
      get: function() {
        return Je.default;
      }
    }), Object.defineProperty(i, "isBinding", {
      enumerable: !0,
      get: function() {
        return He.default;
      }
    }), Object.defineProperty(i, "isBlockScoped", {
      enumerable: !0,
      get: function() {
        return st.default;
      }
    }), Object.defineProperty(i, "isImmutable", {
      enumerable: !0,
      get: function() {
        return qe.default;
      }
    }), Object.defineProperty(i, "isLet", {
      enumerable: !0,
      get: function() {
        return Ge.default;
      }
    }), Object.defineProperty(i, "isNode", {
      enumerable: !0,
      get: function() {
        return at.default;
      }
    }), Object.defineProperty(i, "isNodesEquivalent", {
      enumerable: !0,
      get: function() {
        return it.default;
      }
    }), Object.defineProperty(i, "isPlaceholderType", {
      enumerable: !0,
      get: function() {
        return ft.default;
      }
    }), Object.defineProperty(i, "isReferenced", {
      enumerable: !0,
      get: function() {
        return Xe.default;
      }
    }), Object.defineProperty(i, "isScope", {
      enumerable: !0,
      get: function() {
        return Tt.default;
      }
    }), Object.defineProperty(i, "isSpecifierDefault", {
      enumerable: !0,
      get: function() {
        return be.default;
      }
    }), Object.defineProperty(i, "isType", {
      enumerable: !0,
      get: function() {
        return ve.default;
      }
    }), Object.defineProperty(i, "isValidES3Identifier", {
      enumerable: !0,
      get: function() {
        return j.default;
      }
    }), Object.defineProperty(i, "isValidIdentifier", {
      enumerable: !0,
      get: function() {
        return D.default;
      }
    }), Object.defineProperty(i, "isVar", {
      enumerable: !0,
      get: function() {
        return V.default;
      }
    }), Object.defineProperty(i, "matchesPattern", {
      enumerable: !0,
      get: function() {
        return le.default;
      }
    }), Object.defineProperty(i, "prependToMemberExpression", {
      enumerable: !0,
      get: function() {
        return ye.default;
      }
    }), i.react = void 0, Object.defineProperty(i, "removeComments", {
      enumerable: !0,
      get: function() {
        return L.default;
      }
    }), Object.defineProperty(i, "removeProperties", {
      enumerable: !0,
      get: function() {
        return he.default;
      }
    }), Object.defineProperty(i, "removePropertiesDeep", {
      enumerable: !0,
      get: function() {
        return Pe.default;
      }
    }), Object.defineProperty(i, "removeTypeDuplicates", {
      enumerable: !0,
      get: function() {
        return Ne.default;
      }
    }), Object.defineProperty(i, "shallowEqual", {
      enumerable: !0,
      get: function() {
        return Ue.default;
      }
    }), Object.defineProperty(i, "toBindingIdentifierName", {
      enumerable: !0,
      get: function() {
        return F.default;
      }
    }), Object.defineProperty(i, "toBlock", {
      enumerable: !0,
      get: function() {
        return ie.default;
      }
    }), Object.defineProperty(i, "toComputedKey", {
      enumerable: !0,
      get: function() {
        return re.default;
      }
    }), Object.defineProperty(i, "toExpression", {
      enumerable: !0,
      get: function() {
        return Q.default;
      }
    }), Object.defineProperty(i, "toIdentifier", {
      enumerable: !0,
      get: function() {
        return pe.default;
      }
    }), Object.defineProperty(i, "toKeyAlias", {
      enumerable: !0,
      get: function() {
        return ne.default;
      }
    }), Object.defineProperty(i, "toStatement", {
      enumerable: !0,
      get: function() {
        return R.default;
      }
    }), Object.defineProperty(i, "traverse", {
      enumerable: !0,
      get: function() {
        return Te.default;
      }
    }), Object.defineProperty(i, "traverseFast", {
      enumerable: !0,
      get: function() {
        return de.default;
      }
    }), Object.defineProperty(i, "validate", {
      enumerable: !0,
      get: function() {
        return me.default;
      }
    }), Object.defineProperty(i, "valueToNode", {
      enumerable: !0,
      get: function() {
        return C.default;
      }
    });
    var u = sf(), o = af(), f = Sf(), p = gf(), P = bf();
    Object.keys(P).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === P[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return P[Ce];
        }
      });
    });
    var w = Ef(), x = Pf(), A = vf(), g = Op();
    Object.keys(g).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === g[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return g[Ce];
        }
      });
    });
    var I = Vt();
    Object.keys(I).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === I[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return I[Ce];
        }
      });
    });
    var v = Qi(), S = Af(), _ = Cf(), B = If(), y = wf(), X = Of(), Z = Np(), J = _p(), G = Dp(), O = Lp(), ee = kp(), L = Nf(), q = _f();
    Object.keys(q).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === q[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return q[Ce];
        }
      });
    });
    var H = zi();
    Object.keys(H).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === H[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return H[Ce];
        }
      });
    });
    var N = Df(), F = kf(), ie = Mp(), re = Lf(), Q = Mf(), pe = Bp(), ne = Bf(), R = Ff(), C = Rf(), z = tr();
    Object.keys(z).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === z[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return z[Ce];
        }
      });
    });
    var ae = jf(), ce = qf(), ye = Uf(), he = Rp(), Pe = jp(), Ne = wp(), we = Vf(), Ie = io(), Le = Kf(), fe = Wf(), Te = $f();
    Object.keys(Te).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === Te[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return Te[Ce];
        }
      });
    });
    var de = Fp(), Ue = nl(), Je = Ls(), He = Jf(), st = Xf(), qe = Yf(), Ge = qp(), at = Ip(), it = Hf(), ft = vp(), Xe = Gf(), Tt = zf(), be = Qf(), ve = sl(), j = Zf(), D = Ms(), V = eh(), le = Pp(), me = al(), ge = xp(), xe = bt();
    Object.keys(xe).forEach(function(Ce) {
      Ce === "default" || Ce === "__esModule" || Object.prototype.hasOwnProperty.call(l, Ce) || Ce in i && i[Ce] === xe[Ce] || Object.defineProperty(i, Ce, {
        enumerable: !0,
        get: function() {
          return xe[Ce];
        }
      });
    });
    var De = eo(), We = rh();
    i.react = {
      isReactComponent: u.default,
      isCompatTag: o.default,
      buildChildren: f.default
    }, i.toSequenceExpression = We.default, process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
  }(Jo)), Jo;
}
var Xr = {}, gt = {}, nc;
function Up() {
  if (nc) return gt;
  nc = 1, Object.defineProperty(gt, "__esModule", {
    value: !0
  }), gt.isBindingIdentifier = H, gt.isBlockScoped = Q, gt.isExpression = F, gt.isFlow = z, gt.isForAwaitStatement = ye, gt.isGenerated = R, gt.isPure = C, gt.isReferenced = re, gt.isReferencedIdentifier = L, gt.isReferencedMemberExpression = q, gt.isRestProperty = ae, gt.isScope = ie, gt.isSpreadProperty = ce, gt.isStatement = N, gt.isUser = ne, gt.isVar = pe;
  var i = Ze();
  const {
    isBinding: l,
    isBlockScoped: u,
    isExportDeclaration: o,
    isExpression: f,
    isFlow: p,
    isForStatement: P,
    isForXStatement: w,
    isIdentifier: x,
    isImportDeclaration: A,
    isImportSpecifier: g,
    isJSXIdentifier: I,
    isJSXMemberExpression: v,
    isMemberExpression: S,
    isRestElement: _,
    isReferenced: B,
    isScope: y,
    isStatement: X,
    isVar: Z,
    isVariableDeclaration: J,
    react: G,
    isForOfStatement: O
  } = i, {
    isCompatTag: ee
  } = G;
  function L(he) {
    const {
      node: Pe,
      parent: Ne
    } = this;
    if (!x(Pe, he) && !v(Ne, he))
      if (I(Pe, he)) {
        if (ee(Pe.name)) return !1;
      } else
        return !1;
    return B(Pe, Ne, this.parentPath.parent);
  }
  function q() {
    const {
      node: he,
      parent: Pe
    } = this;
    return S(he) && B(he, Pe);
  }
  function H() {
    const {
      node: he,
      parent: Pe
    } = this, Ne = this.parentPath.parent;
    return x(he) && l(he, Pe, Ne);
  }
  function N() {
    const {
      node: he,
      parent: Pe
    } = this;
    return X(he) ? !(J(he) && (w(Pe, {
      left: he
    }) || P(Pe, {
      init: he
    }))) : !1;
  }
  function F() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : f(this.node);
  }
  function ie() {
    return y(this.node, this.parent);
  }
  function re() {
    return B(this.node, this.parent);
  }
  function Q() {
    return u(this.node);
  }
  function pe() {
    return Z(this.node);
  }
  function ne() {
    return this.node && !!this.node.loc;
  }
  function R() {
    return !this.isUser();
  }
  function C(he) {
    return this.scope.isPure(this.node, he);
  }
  function z() {
    const {
      node: he
    } = this;
    return p(he) ? !0 : A(he) ? he.importKind === "type" || he.importKind === "typeof" : o(he) ? he.exportKind === "type" : g(he) ? he.importKind === "type" || he.importKind === "typeof" : !1;
  }
  function ae() {
    var he;
    return _(this.node) && ((he = this.parentPath) == null ? void 0 : he.isObjectPattern());
  }
  function ce() {
    var he;
    return _(this.node) && ((he = this.parentPath) == null ? void 0 : he.isObjectExpression());
  }
  function ye() {
    return O(this.node, {
      await: !0
    });
  }
  return gt.isExistentialTypeParam = function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, gt.isNumericLiteralTypeAnnotation = function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, gt;
}
var sc;
function no() {
  if (sc) return Xr;
  sc = 1, Object.defineProperty(Xr, "__esModule", {
    value: !0
  }), Xr.environmentVisitor = ee, Xr.explode = I, Xr.isExplodedVisitor = g, Xr.merge = _, Xr.verify = v;
  var i = Ep(), l = Up(), u = Ze(), o = Ar();
  const {
    DEPRECATED_KEYS: f,
    DEPRECATED_ALIASES: p,
    FLIPPED_ALIAS_KEYS: P,
    TYPES: w,
    __internal__deprecationWarning: x
  } = u;
  function A(L) {
    return L in i;
  }
  function g(L) {
    return L == null ? void 0 : L._exploded;
  }
  function I(L) {
    if (g(L)) return L;
    L._exploded = !0;
    for (const q of Object.keys(L)) {
      if (J(q)) continue;
      const H = q.split("|");
      if (H.length === 1) continue;
      const N = L[q];
      delete L[q];
      for (const F of H)
        L[F] = N;
    }
    v(L), delete L.__esModule, y(L), X(L);
    for (const q of Object.keys(L)) {
      if (J(q) || !A(q)) continue;
      const H = L[q];
      for (const F of Object.keys(H))
        H[F] = Z(q, H[F]);
      delete L[q];
      const N = i[q];
      if (N !== null)
        for (const F of N)
          L[F] ? G(L[F], H) : L[F] = H;
      else
        G(L, H);
    }
    for (const q of Object.keys(L)) {
      if (J(q)) continue;
      let H = P[q];
      if (q in f) {
        const F = f[q];
        x(q, F, "Visitor "), H = [F];
      } else if (q in p) {
        const F = p[q];
        x(q, F, "Visitor "), H = P[F];
      }
      if (!H) continue;
      const N = L[q];
      delete L[q];
      for (const F of H) {
        const ie = L[F];
        ie ? G(ie, N) : L[F] = Object.assign({}, N);
      }
    }
    for (const q of Object.keys(L))
      J(q) || X(L[q]);
    return L;
  }
  function v(L) {
    if (!L._verified) {
      if (typeof L == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      for (const q of Object.keys(L)) {
        if ((q === "enter" || q === "exit") && S(q, L[q]), J(q)) continue;
        if (!w.includes(q))
          throw new Error(`You gave us a visitor for the node type ${q} but it's not a valid type in @babel/traverse 7.26.9`);
        const H = L[q];
        if (typeof H == "object")
          for (const N of Object.keys(H))
            if (N === "enter" || N === "exit")
              S(`${q}.${N}`, H[N]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${q} that has the invalid property ${N}`);
      }
      L._verified = !0;
    }
  }
  function S(L, q) {
    const H = [].concat(q);
    for (const N of H)
      if (typeof N != "function")
        throw new TypeError(`Non-function found defined in ${L} with type ${typeof N}`);
  }
  function _(L, q = [], H) {
    const N = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(N, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(N, "_verified", {
      enumerable: !1
    });
    for (let F = 0; F < L.length; F++) {
      const ie = I(L[F]), re = q[F];
      let Q = ie;
      (re || H) && (Q = B(Q, re, H)), G(N, Q);
      for (const pe of Object.keys(ie)) {
        if (J(pe)) continue;
        let ne = ie[pe];
        (re || H) && (ne = B(ne, re, H));
        const R = N[pe] || (N[pe] = {});
        G(R, ne);
      }
    }
    return N;
  }
  function B(L, q, H) {
    const N = {};
    for (const F of ["enter", "exit"]) {
      let ie = L[F];
      Array.isArray(ie) && (ie = ie.map(function(re) {
        let Q = re;
        return q && (Q = function(pe) {
          re.call(q, pe, q);
        }), H && (Q = H(q == null ? void 0 : q.key, F, Q)), Q !== re && (Q.toString = () => re.toString()), Q;
      }), N[F] = ie);
    }
    return N;
  }
  function y(L) {
    for (const q of Object.keys(L)) {
      if (J(q)) continue;
      const H = L[q];
      typeof H == "function" && (L[q] = {
        enter: H
      });
    }
  }
  function X(L) {
    L.enter && !Array.isArray(L.enter) && (L.enter = [L.enter]), L.exit && !Array.isArray(L.exit) && (L.exit = [L.exit]);
  }
  function Z(L, q) {
    const H = `is${L}`, N = l[H], F = function(ie) {
      if (N.call(ie))
        return q.apply(this, arguments);
    };
    return F.toString = () => q.toString(), F;
  }
  function J(L) {
    return L[0] === "_" || L === "enter" || L === "exit" || L === "shouldSkip" || L === "denylist" || L === "noScope" || L === "skipKeys" || L === "blacklist";
  }
  function G(L, q) {
    for (const H of ["enter", "exit"])
      q[H] && (L[H] = [].concat(L[H] || [], q[H]));
  }
  const O = {
    FunctionParent(L) {
      L.isArrowFunctionExpression() || (L.skip(), L.isMethod() && (L.requeueComputedKeyAndDecorators ? L.requeueComputedKeyAndDecorators() : o.requeueComputedKeyAndDecorators.call(L)));
    },
    Property(L) {
      L.isObjectProperty() || (L.skip(), L.requeueComputedKeyAndDecorators ? L.requeueComputedKeyAndDecorators() : o.requeueComputedKeyAndDecorators.call(L));
    }
  };
  function ee(L) {
    return _([O, L]);
  }
  return Xr;
}
var ac;
function ih() {
  if (ac) return us;
  ac = 1, Object.defineProperty(us, "__esModule", {
    value: !0
  }), us.default = void 0;
  var i = Ze(), l = i, u = pl(), o = no(), f = Ar();
  const {
    getAssignmentIdentifiers: p
  } = l, P = {
    ReferencedIdentifier({
      node: x
    }, A) {
      x.name === A.oldName && (x.name = A.newName);
    },
    Scope(x, A) {
      x.scope.bindingIdentifierEquals(A.oldName, A.binding.identifier) || (x.skip(), x.isMethod() && (x.requeueComputedKeyAndDecorators ? x.requeueComputedKeyAndDecorators() : f.requeueComputedKeyAndDecorators.call(x)));
    },
    ObjectProperty({
      node: x,
      scope: A
    }, g) {
      const {
        name: I
      } = x.key;
      if (x.shorthand && (I === g.oldName || I === g.newName) && A.getBindingIdentifier(I) === g.binding.identifier) {
        x.shorthand = !1;
        {
          var v;
          (v = x.extra) != null && v.shorthand && (x.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(x, A) {
      if (x.isVariableDeclaration()) return;
      const g = x.isAssignmentExpression() ? p(x.node) : x.getOuterBindingIdentifiers();
      for (const I in g)
        I === A.oldName && (g[I].name = A.newName);
    }
  };
  class w {
    constructor(A, g, I) {
      this.newName = I, this.oldName = g, this.binding = A;
    }
    maybeConvertFromExportDeclaration(A) {
      const g = A.parentPath;
      if (g.isExportDeclaration()) {
        if (g.isExportDefaultDeclaration()) {
          const {
            declaration: I
          } = g.node;
          if (i.isDeclaration(I) && !I.id)
            return;
        }
        g.isExportAllDeclaration() || g.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(A) {
      return A;
    }
    maybeConvertFromClassFunctionExpression(A) {
      return A;
    }
    rename() {
      const {
        binding: A,
        oldName: g,
        newName: I
      } = this, {
        scope: v,
        path: S
      } = A, _ = S.find((X) => X.isDeclaration() || X.isFunctionExpression() || X.isClassExpression());
      _ && _.getOuterBindingIdentifiers()[g] === A.identifier && this.maybeConvertFromExportDeclaration(_);
      const B = arguments[0] || v.block, y = {
        discriminant: !0
      };
      i.isMethod(B) && (B.computed && (y.key = !0), i.isObjectMethod(B) || (y.decorators = !0)), (0, u.traverseNode)(B, (0, o.explode)(P), v, this, v.path, y), arguments[0] || (v.removeOwnBinding(g), v.bindings[I] = A, this.binding.identifier.name = I), _ && (this.maybeConvertFromClassFunctionDeclaration(S), this.maybeConvertFromClassFunctionExpression(S));
    }
  }
  return us.default = w, us;
}
var Ts = {}, oc;
function nh() {
  if (oc) return Ts;
  oc = 1, Object.defineProperty(Ts, "__esModule", {
    value: !0
  }), Ts.default = void 0;
  class i {
    constructor({
      identifier: o,
      scope: f,
      path: p,
      kind: P
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = o, this.scope = f, this.path = p, this.kind = P, (P === "var" || P === "hoisted") && l(p) && this.reassign(p), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(o) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = o);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(o) {
      this.constant = !1, !this.constantViolations.includes(o) && this.constantViolations.push(o);
    }
    reference(o) {
      this.referencePaths.includes(o) || (this.referenced = !0, this.references++, this.referencePaths.push(o));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  }
  Ts.default = i;
  function l(u) {
    for (let {
      parentPath: o,
      key: f
    } = u; o; {
      parentPath: o,
      key: f
    } = o) {
      if (o.isFunctionParent()) return !1;
      if (o.isWhile() || o.isForXStatement() || o.isForStatement() && f === "body")
        return !0;
    }
    return !1;
  }
  return Ts;
}
const sh = { Array: !1, ArrayBuffer: !1, Atomics: !1, BigInt: !1, BigInt64Array: !1, BigUint64Array: !1, Boolean: !1, constructor: !1, DataView: !1, Date: !1, decodeURI: !1, decodeURIComponent: !1, encodeURI: !1, encodeURIComponent: !1, Error: !1, escape: !1, eval: !1, EvalError: !1, Float32Array: !1, Float64Array: !1, Function: !1, globalThis: !1, hasOwnProperty: !1, Infinity: !1, Int16Array: !1, Int32Array: !1, Int8Array: !1, isFinite: !1, isNaN: !1, isPrototypeOf: !1, JSON: !1, Map: !1, Math: !1, NaN: !1, Number: !1, Object: !1, parseFloat: !1, parseInt: !1, Promise: !1, propertyIsEnumerable: !1, Proxy: !1, RangeError: !1, ReferenceError: !1, Reflect: !1, RegExp: !1, Set: !1, SharedArrayBuffer: !1, String: !1, Symbol: !1, SyntaxError: !1, toLocaleString: !1, toString: !1, TypeError: !1, Uint16Array: !1, Uint32Array: !1, Uint8Array: !1, Uint8ClampedArray: !1, undefined: !1, unescape: !1, URIError: !1, valueOf: !1, WeakMap: !1, WeakSet: !1 }, ah = { Array: !1, Boolean: !1, constructor: !1, Date: !1, decodeURI: !1, decodeURIComponent: !1, encodeURI: !1, encodeURIComponent: !1, Error: !1, escape: !1, eval: !1, EvalError: !1, Function: !1, hasOwnProperty: !1, Infinity: !1, isFinite: !1, isNaN: !1, isPrototypeOf: !1, JSON: !1, Math: !1, NaN: !1, Number: !1, Object: !1, parseFloat: !1, parseInt: !1, propertyIsEnumerable: !1, RangeError: !1, ReferenceError: !1, RegExp: !1, String: !1, SyntaxError: !1, toLocaleString: !1, toString: !1, TypeError: !1, undefined: !1, unescape: !1, URIError: !1, valueOf: !1 }, oh = { Array: !1, ArrayBuffer: !1, Boolean: !1, constructor: !1, DataView: !1, Date: !1, decodeURI: !1, decodeURIComponent: !1, encodeURI: !1, encodeURIComponent: !1, Error: !1, escape: !1, eval: !1, EvalError: !1, Float32Array: !1, Float64Array: !1, Function: !1, hasOwnProperty: !1, Infinity: !1, Int16Array: !1, Int32Array: !1, Int8Array: !1, isFinite: !1, isNaN: !1, isPrototypeOf: !1, JSON: !1, Map: !1, Math: !1, NaN: !1, Number: !1, Object: !1, parseFloat: !1, parseInt: !1, Promise: !1, propertyIsEnumerable: !1, Proxy: !1, RangeError: !1, ReferenceError: !1, Reflect: !1, RegExp: !1, Set: !1, String: !1, Symbol: !1, SyntaxError: !1, toLocaleString: !1, toString: !1, TypeError: !1, Uint16Array: !1, Uint32Array: !1, Uint8Array: !1, Uint8ClampedArray: !1, undefined: !1, unescape: !1, URIError: !1, valueOf: !1, WeakMap: !1, WeakSet: !1 }, lh = { Array: !1, ArrayBuffer: !1, Atomics: !1, Boolean: !1, constructor: !1, DataView: !1, Date: !1, decodeURI: !1, decodeURIComponent: !1, encodeURI: !1, encodeURIComponent: !1, Error: !1, escape: !1, eval: !1, EvalError: !1, Float32Array: !1, Float64Array: !1, Function: !1, hasOwnProperty: !1, Infinity: !1, Int16Array: !1, Int32Array: !1, Int8Array: !1, isFinite: !1, isNaN: !1, isPrototypeOf: !1, JSON: !1, Map: !1, Math: !1, NaN: !1, Number: !1, Object: !1, parseFloat: !1, parseInt: !1, Promise: !1, propertyIsEnumerable: !1, Proxy: !1, RangeError: !1, ReferenceError: !1, Reflect: !1, RegExp: !1, Set: !1, SharedArrayBuffer: !1, String: !1, Symbol: !1, SyntaxError: !1, toLocaleString: !1, toString: !1, TypeError: !1, Uint16Array: !1, Uint32Array: !1, Uint8Array: !1, Uint8ClampedArray: !1, undefined: !1, unescape: !1, URIError: !1, valueOf: !1, WeakMap: !1, WeakSet: !1 }, uh = /* @__PURE__ */ JSON.parse('{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false}'), ch = { addEventListener: !1, applicationCache: !1, atob: !1, Blob: !1, BroadcastChannel: !1, btoa: !1, Cache: !1, caches: !1, clearInterval: !1, clearTimeout: !1, close: !0, console: !1, fetch: !1, FileReaderSync: !1, FormData: !1, Headers: !1, IDBCursor: !1, IDBCursorWithValue: !1, IDBDatabase: !1, IDBFactory: !1, IDBIndex: !1, IDBKeyRange: !1, IDBObjectStore: !1, IDBOpenDBRequest: !1, IDBRequest: !1, IDBTransaction: !1, IDBVersionChangeEvent: !1, ImageData: !1, importScripts: !0, indexedDB: !1, location: !1, MessageChannel: !1, MessagePort: !1, name: !1, navigator: !1, Notification: !1, onclose: !0, onconnect: !0, onerror: !0, onlanguagechange: !0, onmessage: !0, onoffline: !0, ononline: !0, onrejectionhandled: !0, onunhandledrejection: !0, performance: !1, Performance: !1, PerformanceEntry: !1, PerformanceMark: !1, PerformanceMeasure: !1, PerformanceNavigation: !1, PerformanceResourceTiming: !1, PerformanceTiming: !1, postMessage: !0, Promise: !1, queueMicrotask: !1, removeEventListener: !1, Request: !1, Response: !1, self: !0, ServiceWorkerRegistration: !1, setInterval: !1, setTimeout: !1, TextDecoder: !1, TextEncoder: !1, URL: !1, URLSearchParams: !1, WebSocket: !1, Worker: !1, WorkerGlobalScope: !1, XMLHttpRequest: !1 }, ph = { __dirname: !1, __filename: !1, Buffer: !1, clearImmediate: !1, clearInterval: !1, clearTimeout: !1, console: !1, exports: !0, global: !1, Intl: !1, module: !1, process: !1, queueMicrotask: !1, require: !1, setImmediate: !1, setInterval: !1, setTimeout: !1, TextDecoder: !1, TextEncoder: !1, URL: !1, URLSearchParams: !1 }, fh = { exports: !0, global: !1, module: !1, require: !1 }, hh = { define: !1, require: !1 }, dh = { after: !1, afterEach: !1, before: !1, beforeEach: !1, context: !1, describe: !1, it: !1, mocha: !1, run: !1, setup: !1, specify: !1, suite: !1, suiteSetup: !1, suiteTeardown: !1, teardown: !1, test: !1, xcontext: !1, xdescribe: !1, xit: !1, xspecify: !1 }, mh = { afterAll: !1, afterEach: !1, beforeAll: !1, beforeEach: !1, describe: !1, expect: !1, fail: !1, fdescribe: !1, fit: !1, it: !1, jasmine: !1, pending: !1, runs: !1, spyOn: !1, spyOnProperty: !1, waits: !1, waitsFor: !1, xdescribe: !1, xit: !1 }, yh = { afterAll: !1, afterEach: !1, beforeAll: !1, beforeEach: !1, describe: !1, expect: !1, fdescribe: !1, fit: !1, it: !1, jest: !1, pit: !1, require: !1, test: !1, xdescribe: !1, xit: !1, xtest: !1 }, Th = { asyncTest: !1, deepEqual: !1, equal: !1, expect: !1, module: !1, notDeepEqual: !1, notEqual: !1, notOk: !1, notPropEqual: !1, notStrictEqual: !1, ok: !1, propEqual: !1, QUnit: !1, raises: !1, start: !1, stop: !1, strictEqual: !1, test: !1, throws: !1 }, Sh = { console: !0, exports: !0, phantom: !0, require: !0, WebPage: !0 }, gh = { emit: !1, exports: !1, getRow: !1, log: !1, module: !1, provides: !1, require: !1, respond: !1, send: !1, start: !1, sum: !1 }, bh = { defineClass: !1, deserialize: !1, gc: !1, help: !1, importClass: !1, importPackage: !1, java: !1, load: !1, loadClass: !1, Packages: !1, print: !1, quit: !1, readFile: !1, readUrl: !1, runCommand: !1, seal: !1, serialize: !1, spawn: !1, sync: !1, toint32: !1, version: !1 }, Eh = { __DIR__: !1, __FILE__: !1, __LINE__: !1, com: !1, edu: !1, exit: !1, java: !1, Java: !1, javafx: !1, JavaImporter: !1, javax: !1, JSAdapter: !1, load: !1, loadWithNewGlobal: !1, org: !1, Packages: !1, print: !1, quit: !1 }, Ph = { ActiveXObject: !0, Enumerator: !0, GetObject: !0, ScriptEngine: !0, ScriptEngineBuildVersion: !0, ScriptEngineMajorVersion: !0, ScriptEngineMinorVersion: !0, VBArray: !0, WScript: !0, WSH: !0, XDomainRequest: !0 }, xh = { $: !1, jQuery: !1 }, vh = { YAHOO: !1, YAHOO_config: !1, YUI: !1, YUI_config: !1 }, Ah = { cat: !1, cd: !1, chmod: !1, config: !1, cp: !1, dirs: !1, echo: !1, env: !1, error: !1, exec: !1, exit: !1, find: !1, grep: !1, ln: !1, ls: !1, mkdir: !1, mv: !1, popd: !1, pushd: !1, pwd: !1, rm: !1, sed: !1, set: !1, target: !1, tempdir: !1, test: !1, touch: !1, which: !1 }, Ch = { $: !1, $$: !1, $A: !1, $break: !1, $continue: !1, $F: !1, $H: !1, $R: !1, $w: !1, Abstract: !1, Ajax: !1, Autocompleter: !1, Builder: !1, Class: !1, Control: !1, Draggable: !1, Draggables: !1, Droppables: !1, Effect: !1, Element: !1, Enumerable: !1, Event: !1, Field: !1, Form: !1, Hash: !1, Insertion: !1, ObjectRange: !1, PeriodicalExecuter: !1, Position: !1, Prototype: !1, Scriptaculous: !1, Selector: !1, Sortable: !1, SortableObserver: !1, Sound: !1, Template: !1, Toggle: !1, Try: !1 }, Ih = { _: !1, $: !1, Accounts: !1, AccountsClient: !1, AccountsCommon: !1, AccountsServer: !1, App: !1, Assets: !1, Blaze: !1, check: !1, Cordova: !1, DDP: !1, DDPRateLimiter: !1, DDPServer: !1, Deps: !1, EJSON: !1, Email: !1, HTTP: !1, Log: !1, Match: !1, Meteor: !1, Mongo: !1, MongoInternals: !1, Npm: !1, Package: !1, Plugin: !1, process: !1, Random: !1, ReactiveDict: !1, ReactiveVar: !1, Router: !1, ServiceConfiguration: !1, Session: !1, share: !1, Spacebars: !1, Template: !1, Tinytest: !1, Tracker: !1, UI: !1, Utils: !1, WebApp: !1, WebAppInternals: !1 }, wh = { _isWindows: !1, _rand: !1, BulkWriteResult: !1, cat: !1, cd: !1, connect: !1, db: !1, getHostName: !1, getMemInfo: !1, hostname: !1, ISODate: !1, listFiles: !1, load: !1, ls: !1, md5sumFile: !1, mkdir: !1, Mongo: !1, NumberInt: !1, NumberLong: !1, ObjectId: !1, PlanCache: !1, print: !1, printjson: !1, pwd: !1, quit: !1, removeFile: !1, rs: !1, sh: !1, UUID: !1, version: !1, WriteResult: !1 }, Oh = { $: !1, Application: !1, Automation: !1, console: !1, delay: !1, Library: !1, ObjC: !1, ObjectSpecifier: !1, Path: !1, Progress: !1, Ref: !1 }, Nh = { addEventListener: !1, applicationCache: !1, atob: !1, Blob: !1, BroadcastChannel: !1, btoa: !1, Cache: !1, caches: !1, CacheStorage: !1, clearInterval: !1, clearTimeout: !1, Client: !1, clients: !1, Clients: !1, close: !0, console: !1, ExtendableEvent: !1, ExtendableMessageEvent: !1, fetch: !1, FetchEvent: !1, FileReaderSync: !1, FormData: !1, Headers: !1, IDBCursor: !1, IDBCursorWithValue: !1, IDBDatabase: !1, IDBFactory: !1, IDBIndex: !1, IDBKeyRange: !1, IDBObjectStore: !1, IDBOpenDBRequest: !1, IDBRequest: !1, IDBTransaction: !1, IDBVersionChangeEvent: !1, ImageData: !1, importScripts: !1, indexedDB: !1, location: !1, MessageChannel: !1, MessagePort: !1, name: !1, navigator: !1, Notification: !1, onclose: !0, onconnect: !0, onerror: !0, onfetch: !0, oninstall: !0, onlanguagechange: !0, onmessage: !0, onmessageerror: !0, onnotificationclick: !0, onnotificationclose: !0, onoffline: !0, ononline: !0, onpush: !0, onpushsubscriptionchange: !0, onrejectionhandled: !0, onsync: !0, onunhandledrejection: !0, performance: !1, Performance: !1, PerformanceEntry: !1, PerformanceMark: !1, PerformanceMeasure: !1, PerformanceNavigation: !1, PerformanceResourceTiming: !1, PerformanceTiming: !1, postMessage: !0, Promise: !1, queueMicrotask: !1, registration: !1, removeEventListener: !1, Request: !1, Response: !1, self: !1, ServiceWorker: !1, ServiceWorkerContainer: !1, ServiceWorkerGlobalScope: !1, ServiceWorkerMessageEvent: !1, ServiceWorkerRegistration: !1, setInterval: !1, setTimeout: !1, skipWaiting: !1, TextDecoder: !1, TextEncoder: !1, URL: !1, URLSearchParams: !1, WebSocket: !1, WindowClient: !1, Worker: !1, WorkerGlobalScope: !1, XMLHttpRequest: !1 }, _h = { advanceClock: !1, fakeClearInterval: !1, fakeClearTimeout: !1, fakeSetInterval: !1, fakeSetTimeout: !1, resetTimeouts: !1, waitsForPromise: !1 }, Dh = { andThen: !1, click: !1, currentPath: !1, currentRouteName: !1, currentURL: !1, fillIn: !1, find: !1, findAll: !1, findWithAssert: !1, keyEvent: !1, pauseTest: !1, resumeTest: !1, triggerEvent: !1, visit: !1, wait: !1 }, kh = { $: !1, $$: !1, browser: !1, by: !1, By: !1, DartObject: !1, element: !1, protractor: !1 }, Lh = { browser: !1, chrome: !1, opr: !1 }, Mh = { cloneInto: !1, createObjectIn: !1, exportFunction: !1, GM: !1, GM_addStyle: !1, GM_deleteValue: !1, GM_getResourceText: !1, GM_getResourceURL: !1, GM_getValue: !1, GM_info: !1, GM_listValues: !1, GM_log: !1, GM_openInTab: !1, GM_registerMenuCommand: !1, GM_setClipboard: !1, GM_setValue: !1, GM_xmlhttpRequest: !1, unsafeWindow: !1 }, Bh = { $: !1, $_: !1, $$: !1, $0: !1, $1: !1, $2: !1, $3: !1, $4: !1, $x: !1, chrome: !1, clear: !1, copy: !1, debug: !1, dir: !1, dirxml: !1, getEventListeners: !1, inspect: !1, keys: !1, monitor: !1, monitorEvents: !1, profile: !1, profileEnd: !1, queryObjects: !1, table: !1, undebug: !1, unmonitor: !1, unmonitorEvents: !1, values: !1 }, Fh = {
  builtin: sh,
  es5: ah,
  es2015: oh,
  es2017: lh,
  browser: uh,
  worker: ch,
  node: ph,
  commonjs: fh,
  amd: hh,
  mocha: dh,
  jasmine: mh,
  jest: yh,
  qunit: Th,
  phantomjs: Sh,
  couch: gh,
  rhino: bh,
  nashorn: Eh,
  wsh: Ph,
  jquery: xh,
  yui: vh,
  shelljs: Ah,
  prototypejs: Ch,
  meteor: Ih,
  mongo: wh,
  applescript: Oh,
  serviceworker: Nh,
  atomtest: _h,
  embertest: Dh,
  protractor: kh,
  "shared-node-browser": { clearInterval: !1, clearTimeout: !1, console: !1, setInterval: !1, setTimeout: !1, URL: !1, URLSearchParams: !1 },
  webextensions: Lh,
  greasemonkey: Mh,
  devtools: Bh
};
var zo, lc;
function Rh() {
  return lc || (lc = 1, zo = Fh), zo;
}
var kt = {}, uc;
function ln() {
  if (uc) return kt;
  uc = 1, Object.defineProperty(kt, "__esModule", {
    value: !0
  }), kt.clear = l, kt.clearPath = u, kt.clearScope = o, kt.getCachedPaths = p, kt.getOrCreateCachedPaths = P, kt.scope = kt.path = void 0;
  let i = kt.path = /* @__PURE__ */ new WeakMap();
  kt.scope = /* @__PURE__ */ new WeakMap();
  function l() {
    u(), o();
  }
  function u() {
    kt.path = i = /* @__PURE__ */ new WeakMap();
  }
  function o() {
    kt.scope = /* @__PURE__ */ new WeakMap();
  }
  const f = Object.freeze({});
  function p(w, x) {
    var A, g;
    return w = null, (A = i.get((g = w) != null ? g : f)) == null ? void 0 : A.get(x);
  }
  function P(w, x) {
    var A, g;
    w = null;
    let I = i.get((A = w) != null ? A : f);
    I || i.set((g = w) != null ? g : f, I = /* @__PURE__ */ new WeakMap());
    let v = I.get(x);
    return v || I.set(x, v = /* @__PURE__ */ new Map()), v;
  }
  return kt;
}
var cc;
function Vp() {
  if (cc) return ls;
  cc = 1, Object.defineProperty(ls, "__esModule", {
    value: !0
  }), ls.default = void 0;
  var i = ih(), l = so(), u = nh(), o = Rh(), f = Ze(), p = f, P = ln(), w = no();
  const {
    NOT_LOCAL_BINDING: x,
    assignmentExpression: A,
    callExpression: g,
    cloneNode: I,
    getBindingIdentifiers: v,
    identifier: S,
    isArrayExpression: _,
    isBinary: B,
    isCallExpression: y,
    isClass: X,
    isClassBody: Z,
    isClassDeclaration: J,
    isExportAllDeclaration: G,
    isExportDefaultDeclaration: O,
    isExportNamedDeclaration: ee,
    isFunctionDeclaration: L,
    isIdentifier: q,
    isImportDeclaration: H,
    isLiteral: N,
    isMemberExpression: F,
    isMethod: ie,
    isModuleSpecifier: re,
    isNullLiteral: Q,
    isObjectExpression: pe,
    isProperty: ne,
    isPureish: R,
    isRegExpLiteral: C,
    isSuper: z,
    isTaggedTemplateExpression: ae,
    isTemplateLiteral: ce,
    isThisExpression: ye,
    isUnaryExpression: he,
    isVariableDeclaration: Pe,
    expressionStatement: Ne,
    matchesPattern: we,
    memberExpression: Ie,
    numericLiteral: Le,
    toIdentifier: fe,
    variableDeclaration: Te,
    variableDeclarator: de,
    isRecordExpression: Ue,
    isTupleExpression: Je,
    isObjectProperty: He,
    isTopicReference: st,
    isMetaProperty: qe,
    isPrivateName: Ge,
    isExportDeclaration: at,
    buildUndefinedNode: it,
    sequenceExpression: ft
  } = f;
  function Xe(j, D) {
    switch (j == null ? void 0 : j.type) {
      default:
        if (H(j) || at(j)) {
          var V;
          if ((G(j) || ee(j) || H(j)) && j.source)
            Xe(j.source, D);
          else if ((ee(j) || H(j)) && (V = j.specifiers) != null && V.length)
            for (const le of j.specifiers) Xe(le, D);
          else (O(j) || ee(j)) && j.declaration && Xe(j.declaration, D);
        } else re(j) ? Xe(j.local, D) : N(j) && !Q(j) && !C(j) && !ce(j) && D.push(j.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Xe(j.object, D), Xe(j.property, D);
        break;
      case "Identifier":
      case "JSXIdentifier":
        D.push(j.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Xe(j.callee, D);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const le of j.properties)
          Xe(le, D);
        break;
      case "SpreadElement":
      case "RestElement":
        Xe(j.argument, D);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Xe(j.key, D);
        break;
      case "ThisExpression":
        D.push("this");
        break;
      case "Super":
        D.push("super");
        break;
      case "Import":
        D.push("import");
        break;
      case "DoExpression":
        D.push("do");
        break;
      case "YieldExpression":
        D.push("yield"), Xe(j.argument, D);
        break;
      case "AwaitExpression":
        D.push("await"), Xe(j.argument, D);
        break;
      case "AssignmentExpression":
        Xe(j.left, D);
        break;
      case "VariableDeclarator":
        Xe(j.id, D);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Xe(j.id, D);
        break;
      case "PrivateName":
        Xe(j.id, D);
        break;
      case "ParenthesizedExpression":
        Xe(j.expression, D);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Xe(j.argument, D);
        break;
      case "MetaProperty":
        Xe(j.meta, D), Xe(j.property, D);
        break;
      case "JSXElement":
        Xe(j.openingElement, D);
        break;
      case "JSXOpeningElement":
        Xe(j.name, D);
        break;
      case "JSXFragment":
        Xe(j.openingFragment, D);
        break;
      case "JSXOpeningFragment":
        D.push("Fragment");
        break;
      case "JSXNamespacedName":
        Xe(j.namespace, D), Xe(j.name, D);
        break;
    }
  }
  const Tt = {
    ForStatement(j) {
      const D = j.get("init");
      if (D.isVar()) {
        const {
          scope: V
        } = j;
        (V.getFunctionParent() || V.getProgramParent()).registerBinding("var", D);
      }
    },
    Declaration(j) {
      if (j.isBlockScoped() || j.isImportDeclaration() || j.isExportDeclaration()) return;
      (j.scope.getFunctionParent() || j.scope.getProgramParent()).registerDeclaration(j);
    },
    ImportDeclaration(j) {
      j.scope.getBlockParent().registerDeclaration(j);
    },
    TSImportEqualsDeclaration(j) {
      j.scope.getBlockParent().registerDeclaration(j);
    },
    ReferencedIdentifier(j, D) {
      p.isTSQualifiedName(j.parent) && j.parent.right === j.node || j.parentPath.isTSImportEqualsDeclaration() || D.references.push(j);
    },
    ForXStatement(j, D) {
      const V = j.get("left");
      if (V.isPattern() || V.isIdentifier())
        D.constantViolations.push(j);
      else if (V.isVar()) {
        const {
          scope: le
        } = j;
        (le.getFunctionParent() || le.getProgramParent()).registerBinding("var", V);
      }
    },
    ExportDeclaration: {
      exit(j) {
        const {
          node: D,
          scope: V
        } = j;
        if (G(D)) return;
        const le = D.declaration;
        if (J(le) || L(le)) {
          const me = le.id;
          if (!me) return;
          const ge = V.getBinding(me.name);
          ge == null || ge.reference(j);
        } else if (Pe(le))
          for (const me of le.declarations)
            for (const ge of Object.keys(v(me))) {
              const xe = V.getBinding(ge);
              xe == null || xe.reference(j);
            }
      }
    },
    LabeledStatement(j) {
      j.scope.getBlockParent().registerDeclaration(j);
    },
    AssignmentExpression(j, D) {
      D.assignments.push(j);
    },
    UpdateExpression(j, D) {
      D.constantViolations.push(j);
    },
    UnaryExpression(j, D) {
      j.node.operator === "delete" && D.constantViolations.push(j);
    },
    BlockScoped(j) {
      let D = j.scope;
      if (D.path === j && (D = D.parent), D.getBlockParent().registerDeclaration(j), j.isClassDeclaration() && j.node.id) {
        const me = j.node.id.name;
        j.scope.bindings[me] = j.scope.parent.getBinding(me);
      }
    },
    CatchClause(j) {
      j.scope.registerBinding("let", j);
    },
    Function(j) {
      const D = j.get("params");
      for (const V of D)
        j.scope.registerBinding("param", V);
      j.isFunctionExpression() && j.node.id && !j.node.id[x] && j.scope.registerBinding("local", j.get("id"), j);
    },
    ClassExpression(j) {
      j.node.id && !j.node.id[x] && j.scope.registerBinding("local", j.get("id"), j);
    },
    TSTypeAnnotation(j) {
      j.skip();
    }
  };
  let be = 0;
  class ve {
    constructor(D) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const {
        node: V
      } = D, le = P.scope.get(V);
      if ((le == null ? void 0 : le.path) === D)
        return le;
      P.scope.set(V, this), this.uid = be++, this.block = V, this.path = D, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var D;
      let V, le = this.path;
      do {
        var me;
        const ge = le.key === "key" || le.listKey === "decorators";
        le = le.parentPath, ge && le.isMethod() && (le = le.parentPath), (me = le) != null && me.isScope() && (V = le);
      } while (le && !V);
      return (D = V) == null ? void 0 : D.scope;
    }
    generateDeclaredUidIdentifier(D) {
      const V = this.generateUidIdentifier(D);
      return this.push({
        id: V
      }), I(V);
    }
    generateUidIdentifier(D) {
      return S(this.generateUid(D));
    }
    generateUid(D = "temp") {
      D = fe(D).replace(/^_+/, "").replace(/\d+$/g, "");
      let V, le = 1;
      do
        V = `_${D}`, le > 1 && (V += le), le++;
      while (this.hasLabel(V) || this.hasBinding(V) || this.hasGlobal(V) || this.hasReference(V));
      const me = this.getProgramParent();
      return me.references[V] = !0, me.uids[V] = !0, V;
    }
    generateUidBasedOnNode(D, V) {
      const le = [];
      Xe(D, le);
      let me = le.join("$");
      return me = me.replace(/^_/, "") || V || "ref", this.generateUid(me.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(D, V) {
      return S(this.generateUidBasedOnNode(D, V));
    }
    isStatic(D) {
      if (ye(D) || z(D) || st(D))
        return !0;
      if (q(D)) {
        const V = this.getBinding(D.name);
        return V ? V.constant : this.hasBinding(D.name);
      }
      return !1;
    }
    maybeGenerateMemoised(D, V) {
      if (this.isStatic(D))
        return null;
      {
        const le = this.generateUidIdentifierBasedOnNode(D);
        return V ? le : (this.push({
          id: le
        }), I(le));
      }
    }
    checkBlockScopedCollisions(D, V, le, me) {
      if (V === "param" || D.kind === "local") return;
      if (V === "let" || D.kind === "let" || D.kind === "const" || D.kind === "module" || D.kind === "param" && V === "const")
        throw this.path.hub.buildError(me, `Duplicate declaration "${le}"`, TypeError);
    }
    rename(D, V) {
      const le = this.getBinding(D);
      le && (V || (V = this.generateUidIdentifier(D).name), new i.default(le, D, V).rename(arguments[2]));
    }
    dump() {
      const D = "-".repeat(60);
      console.log(D);
      let V = this;
      do {
        console.log("#", V.block.type);
        for (const le of Object.keys(V.bindings)) {
          const me = V.bindings[le];
          console.log(" -", le, {
            constant: me.constant,
            references: me.references,
            violations: me.constantViolations.length,
            kind: me.kind
          });
        }
      } while (V = V.parent);
      console.log(D);
    }
    hasLabel(D) {
      return !!this.getLabel(D);
    }
    getLabel(D) {
      return this.labels.get(D);
    }
    registerLabel(D) {
      this.labels.set(D.node.label.name, D);
    }
    registerDeclaration(D) {
      if (D.isLabeledStatement())
        this.registerLabel(D);
      else if (D.isFunctionDeclaration())
        this.registerBinding("hoisted", D.get("id"), D);
      else if (D.isVariableDeclaration()) {
        const V = D.get("declarations"), {
          kind: le
        } = D.node;
        for (const me of V)
          this.registerBinding(le === "using" || le === "await using" ? "const" : le, me);
      } else if (D.isClassDeclaration()) {
        if (D.node.declare) return;
        this.registerBinding("let", D);
      } else if (D.isImportDeclaration()) {
        const V = D.node.importKind === "type" || D.node.importKind === "typeof", le = D.get("specifiers");
        for (const me of le) {
          const ge = V || me.isImportSpecifier() && (me.node.importKind === "type" || me.node.importKind === "typeof");
          this.registerBinding(ge ? "unknown" : "module", me);
        }
      } else if (D.isExportDeclaration()) {
        const V = D.get("declaration");
        (V.isClassDeclaration() || V.isFunctionDeclaration() || V.isVariableDeclaration()) && this.registerDeclaration(V);
      } else
        this.registerBinding("unknown", D);
    }
    buildUndefinedNode() {
      return it();
    }
    registerConstantViolation(D) {
      const V = D.getAssignmentIdentifiers();
      for (const me of Object.keys(V)) {
        var le;
        (le = this.getBinding(me)) == null || le.reassign(D);
      }
    }
    registerBinding(D, V, le = V) {
      if (!D) throw new ReferenceError("no `kind`");
      if (V.isVariableDeclaration()) {
        const xe = V.get("declarations");
        for (const De of xe)
          this.registerBinding(D, De);
        return;
      }
      const me = this.getProgramParent(), ge = V.getOuterBindingIdentifiers(!0);
      for (const xe of Object.keys(ge)) {
        me.references[xe] = !0;
        for (const De of ge[xe]) {
          const We = this.getOwnBinding(xe);
          if (We) {
            if (We.identifier === De) continue;
            this.checkBlockScopedCollisions(We, D, xe, De);
          }
          We ? We.reassign(le) : this.bindings[xe] = new u.default({
            identifier: De,
            scope: this,
            path: le,
            kind: D
          });
        }
      }
    }
    addGlobal(D) {
      this.globals[D.name] = D;
    }
    hasUid(D) {
      let V = this;
      do
        if (V.uids[D]) return !0;
      while (V = V.parent);
      return !1;
    }
    hasGlobal(D) {
      let V = this;
      do
        if (V.globals[D]) return !0;
      while (V = V.parent);
      return !1;
    }
    hasReference(D) {
      return !!this.getProgramParent().references[D];
    }
    isPure(D, V) {
      if (q(D)) {
        const xe = this.getBinding(D.name);
        return xe ? V ? xe.constant : !0 : !1;
      } else {
        if (ye(D) || qe(D) || st(D) || Ge(D))
          return !0;
        if (X(D)) {
          var le;
          return D.superClass && !this.isPure(D.superClass, V) || ((le = D.decorators) == null ? void 0 : le.length) > 0 ? !1 : this.isPure(D.body, V);
        } else if (Z(D)) {
          for (const xe of D.body)
            if (!this.isPure(xe, V)) return !1;
          return !0;
        } else {
          if (B(D))
            return this.isPure(D.left, V) && this.isPure(D.right, V);
          if (_(D) || Je(D)) {
            for (const xe of D.elements)
              if (xe !== null && !this.isPure(xe, V)) return !1;
            return !0;
          } else if (pe(D) || Ue(D)) {
            for (const xe of D.properties)
              if (!this.isPure(xe, V)) return !1;
            return !0;
          } else if (ie(D)) {
            var me;
            return !(D.computed && !this.isPure(D.key, V) || ((me = D.decorators) == null ? void 0 : me.length) > 0);
          } else if (ne(D)) {
            var ge;
            return !(D.computed && !this.isPure(D.key, V) || ((ge = D.decorators) == null ? void 0 : ge.length) > 0 || (He(D) || D.static) && D.value !== null && !this.isPure(D.value, V));
          } else {
            if (he(D))
              return this.isPure(D.argument, V);
            if (ce(D)) {
              for (const xe of D.expressions)
                if (!this.isPure(xe, V)) return !1;
              return !0;
            } else return ae(D) ? we(D.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(D.quasi, V) : F(D) ? !D.computed && q(D.object) && D.object.name === "Symbol" && q(D.property) && D.property.name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : y(D) ? we(D.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && D.arguments.length === 1 && p.isStringLiteral(D.arguments[0]) : R(D);
          }
        }
      }
    }
    setData(D, V) {
      return this.data[D] = V;
    }
    getData(D) {
      let V = this;
      do {
        const le = V.data[D];
        if (le != null) return le;
      } while (V = V.parent);
    }
    removeData(D) {
      let V = this;
      do
        V.data[D] != null && (V.data[D] = null);
      while (V = V.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      const D = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let V = this;
      do {
        if (V.crawling) return;
        if (V.path.isProgram())
          break;
      } while (V = V.parent);
      const le = V, me = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, D.type !== "Program" && (0, w.isExplodedVisitor)(Tt)) {
        for (const xe of Tt.enter)
          xe.call(me, D, me);
        const ge = Tt[D.type];
        if (ge)
          for (const xe of ge.enter)
            xe.call(me, D, me);
      }
      D.traverse(Tt, me), this.crawling = !1;
      for (const ge of me.assignments) {
        const xe = ge.getAssignmentIdentifiers();
        for (const De of Object.keys(xe))
          ge.scope.getBinding(De) || le.addGlobal(xe[De]);
        ge.scope.registerConstantViolation(ge);
      }
      for (const ge of me.references) {
        const xe = ge.scope.getBinding(ge.node.name);
        xe ? xe.reference(ge) : le.addGlobal(ge.node);
      }
      for (const ge of me.constantViolations)
        ge.scope.registerConstantViolation(ge);
    }
    push(D) {
      let V = this.path;
      V.isPattern() ? V = this.getPatternParent().path : !V.isBlockStatement() && !V.isProgram() && (V = this.getBlockParent().path), V.isSwitchStatement() && (V = (this.getFunctionParent() || this.getProgramParent()).path);
      const {
        init: le,
        unique: me,
        kind: ge = "var",
        id: xe
      } = D;
      if (!le && !me && (ge === "var" || ge === "let") && V.isFunction() && !V.node.name && y(V.parent, {
        callee: V.node
      }) && V.parent.arguments.length <= V.node.params.length && q(xe)) {
        V.pushContainer("params", xe), V.scope.registerBinding("param", V.get("params")[V.node.params.length - 1]);
        return;
      }
      (V.isLoop() || V.isCatchClause() || V.isFunction()) && (V.ensureBlock(), V = V.get("body"));
      const De = D._blockHoist == null ? 2 : D._blockHoist, We = `declaration:${ge}:${De}`;
      let Ce = !me && V.getData(We);
      if (!Ce) {
        const et = Te(ge, []);
        et._blockHoist = De, [Ce] = V.unshiftContainer("body", [et]), me || V.setData(We, Ce);
      }
      const Ye = de(xe, le), $e = Ce.node.declarations.push(Ye);
      V.scope.registerBinding(ge, Ce.get("declarations")[$e - 1]);
    }
    getProgramParent() {
      let D = this;
      do
        if (D.path.isProgram())
          return D;
      while (D = D.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let D = this;
      do
        if (D.path.isFunctionParent())
          return D;
      while (D = D.parent);
      return null;
    }
    getBlockParent() {
      let D = this;
      do
        if (D.path.isBlockParent())
          return D;
      while (D = D.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let D = this;
      do
        if (!D.path.isPattern())
          return D.getBlockParent();
      while (D = D.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const D = /* @__PURE__ */ Object.create(null);
      let V = this;
      do {
        for (const le of Object.keys(V.bindings))
          le in D || (D[le] = V.bindings[le]);
        V = V.parent;
      } while (V);
      return D;
    }
    bindingIdentifierEquals(D, V) {
      return this.getBindingIdentifier(D) === V;
    }
    getBinding(D) {
      let V = this, le;
      do {
        const ge = V.getOwnBinding(D);
        if (ge) {
          var me;
          if (!((me = le) != null && me.isPattern() && ge.kind !== "param" && ge.kind !== "local")) return ge;
        } else if (!ge && D === "arguments" && V.path.isFunction() && !V.path.isArrowFunctionExpression())
          break;
        le = V.path;
      } while (V = V.parent);
    }
    getOwnBinding(D) {
      return this.bindings[D];
    }
    getBindingIdentifier(D) {
      var V;
      return (V = this.getBinding(D)) == null ? void 0 : V.identifier;
    }
    getOwnBindingIdentifier(D) {
      const V = this.bindings[D];
      return V == null ? void 0 : V.identifier;
    }
    hasOwnBinding(D) {
      return !!this.getOwnBinding(D);
    }
    hasBinding(D, V) {
      if (!D) return !1;
      let le = this;
      do
        if (le.hasOwnBinding(D))
          return !0;
      while (le = le.parent);
      let me, ge;
      return typeof V == "object" ? (me = V.noGlobals, ge = V.noUids) : typeof V == "boolean" && (me = V), !!(!ge && this.hasUid(D) || !me && ve.globals.includes(D) || !me && ve.contextVariables.includes(D));
    }
    parentHasBinding(D, V) {
      var le;
      return (le = this.parent) == null ? void 0 : le.hasBinding(D, V);
    }
    moveBindingTo(D, V) {
      const le = this.getBinding(D);
      le && (le.scope.removeOwnBinding(D), le.scope = V, V.bindings[D] = le);
    }
    removeOwnBinding(D) {
      delete this.bindings[D];
    }
    removeBinding(D) {
      var V;
      (V = this.getBinding(D)) == null || V.scope.removeOwnBinding(D);
      let le = this;
      do
        le.uids[D] && (le.uids[D] = !1);
      while (le = le.parent);
    }
    hoistVariables(D = (V) => this.push({
      id: V
    })) {
      this.crawl();
      const V = /* @__PURE__ */ new Set();
      for (const me of Object.keys(this.bindings)) {
        const ge = this.bindings[me];
        if (!ge) continue;
        const {
          path: xe
        } = ge;
        if (!xe.isVariableDeclarator()) continue;
        const {
          parent: De,
          parentPath: We
        } = xe;
        if (De.kind !== "var" || V.has(De)) continue;
        V.add(xe.parent);
        let Ce;
        const Ye = [];
        for (const $e of De.declarations) {
          var le;
          (le = Ce) != null || (Ce = $e.id), $e.init && Ye.push(A("=", $e.id, $e.init));
          const et = Object.keys(v($e, !1, !0, !0));
          for (const oe of et)
            D(S(oe), $e.init != null);
        }
        if (We.parentPath.isFor({
          left: De
        }))
          We.replaceWith(Ce);
        else if (Ye.length === 0)
          We.remove();
        else {
          const $e = Ye.length === 1 ? Ye[0] : ft(Ye);
          We.parentPath.isForStatement({
            init: De
          }) ? We.replaceWith($e) : We.replaceWith(Ne($e));
        }
      }
    }
  }
  return ls.default = ve, ve.globals = Object.keys(o.builtin), ve.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], ve.prototype._renameFromMap = function(D, V, le, me) {
    D[V] && (D[le] = me, D[V] = null);
  }, ve.prototype.traverse = function(j, D, V) {
    (0, l.default)(j, D, this, V, this.path);
  }, ve.prototype._generateUid = function(D, V) {
    let le = D;
    return V > 1 && (le += V), `_${le}`;
  }, ve.prototype.toArray = function(D, V, le) {
    if (q(D)) {
      const xe = this.getBinding(D.name);
      if (xe != null && xe.constant && xe.path.isGenericType("Array"))
        return D;
    }
    if (_(D))
      return D;
    if (q(D, {
      name: "arguments"
    }))
      return g(Ie(Ie(Ie(S("Array"), S("prototype")), S("slice")), S("call")), [D]);
    let me;
    const ge = [D];
    return V === !0 ? me = "toConsumableArray" : typeof V == "number" ? (ge.push(Le(V)), me = "slicedToArray") : me = "toArray", le && (ge.unshift(this.path.hub.addHelper(me)), me = "maybeArrayLike"), g(this.path.hub.addHelper(me), ge);
  }, ve.prototype.getAllBindingsOfKind = function(...D) {
    const V = /* @__PURE__ */ Object.create(null);
    for (const le of D) {
      let me = this;
      do {
        for (const ge of Object.keys(me.bindings)) {
          const xe = me.bindings[ge];
          xe.kind === le && (V[ge] = xe);
        }
        me = me.parent;
      } while (me);
    }
    return V;
  }, Object.defineProperties(ve.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  }), ls;
}
var Ss = {}, gs = {}, Ns = { exports: {} }, _s = { exports: {} }, jh = _s.exports, pc;
function qh() {
  return pc || (pc = 1, function(i, l) {
    (function(u, o) {
      o(l);
    })(jh, function(u) {
      class o {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      function f(A) {
        return A;
      }
      function p(A, g) {
        return A._indexes[g];
      }
      function P(A, g) {
        const I = p(A, g);
        if (I !== void 0)
          return I;
        const { array: v, _indexes: S } = A, _ = v.push(g);
        return S[g] = _ - 1;
      }
      function w(A) {
        const { array: g, _indexes: I } = A;
        if (g.length === 0)
          return;
        const v = g.pop();
        I[v] = void 0;
      }
      function x(A, g) {
        const I = p(A, g);
        if (I === void 0)
          return;
        const { array: v, _indexes: S } = A;
        for (let _ = I + 1; _ < v.length; _++) {
          const B = v[_];
          v[_ - 1] = B, S[B]--;
        }
        S[g] = void 0, v.pop();
      }
      u.SetArray = o, u.get = p, u.pop = w, u.put = P, u.remove = x, Object.defineProperty(u, "__esModule", { value: !0 });
    });
  }(_s, _s.exports)), _s.exports;
}
var Ds = { exports: {} }, Uh = Ds.exports, fc;
function Kp() {
  return fc || (fc = 1, function(i, l) {
    (function(u, o) {
      o(l);
    })(Uh, function(u) {
      const p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", P = new Uint8Array(64), w = new Uint8Array(128);
      for (let F = 0; F < p.length; F++) {
        const ie = p.charCodeAt(F);
        P[F] = ie, w[ie] = F;
      }
      function x(F, ie) {
        let re = 0, Q = 0, pe = 0;
        do {
          const R = F.next();
          pe = w[R], re |= (pe & 31) << Q, Q += 5;
        } while (pe & 32);
        const ne = re & 1;
        return re >>>= 1, ne && (re = -2147483648 | -re), ie + re;
      }
      function A(F, ie, re) {
        let Q = ie - re;
        Q = Q < 0 ? -Q << 1 | 1 : Q << 1;
        do {
          let pe = Q & 31;
          Q >>>= 5, Q > 0 && (pe |= 32), F.write(P[pe]);
        } while (Q > 0);
        return ie;
      }
      function g(F, ie) {
        return F.pos >= ie ? !1 : F.peek() !== 44;
      }
      const I = 1024 * 16, v = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(F) {
          return Buffer.from(F.buffer, F.byteOffset, F.byteLength).toString();
        }
      } : {
        decode(F) {
          let ie = "";
          for (let re = 0; re < F.length; re++)
            ie += String.fromCharCode(F[re]);
          return ie;
        }
      };
      class S {
        constructor() {
          this.pos = 0, this.out = "", this.buffer = new Uint8Array(I);
        }
        write(ie) {
          const { buffer: re } = this;
          re[this.pos++] = ie, this.pos === I && (this.out += v.decode(re), this.pos = 0);
        }
        flush() {
          const { buffer: ie, out: re, pos: Q } = this;
          return Q > 0 ? re + v.decode(ie.subarray(0, Q)) : re;
        }
      }
      class _ {
        constructor(ie) {
          this.pos = 0, this.buffer = ie;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(ie) {
          const { buffer: re, pos: Q } = this, pe = re.indexOf(ie, Q);
          return pe === -1 ? re.length : pe;
        }
      }
      const B = [];
      function y(F) {
        const { length: ie } = F, re = new _(F), Q = [], pe = [];
        let ne = 0;
        for (; re.pos < ie; re.pos++) {
          ne = x(re, ne);
          const R = x(re, 0);
          if (!g(re, ie)) {
            const he = pe.pop();
            he[2] = ne, he[3] = R;
            continue;
          }
          const C = x(re, 0), ce = x(re, 0) & 1 ? [ne, R, 0, 0, C, x(re, 0)] : [ne, R, 0, 0, C];
          let ye = B;
          if (g(re, ie)) {
            ye = [];
            do {
              const he = x(re, 0);
              ye.push(he);
            } while (g(re, ie));
          }
          ce.vars = ye, Q.push(ce), pe.push(ce);
        }
        return Q;
      }
      function X(F) {
        const ie = new S();
        for (let re = 0; re < F.length; )
          re = Z(F, re, ie, [0]);
        return ie.flush();
      }
      function Z(F, ie, re, Q) {
        const pe = F[ie], { 0: ne, 1: R, 2: C, 3: z, 4: ae, vars: ce } = pe;
        ie > 0 && re.write(44), Q[0] = A(re, ne, Q[0]), A(re, R, 0), A(re, ae, 0);
        const ye = pe.length === 6 ? 1 : 0;
        A(re, ye, 0), pe.length === 6 && A(re, pe[5], 0);
        for (const he of ce)
          A(re, he, 0);
        for (ie++; ie < F.length; ) {
          const he = F[ie], { 0: Pe, 1: Ne } = he;
          if (Pe > C || Pe === C && Ne >= z)
            break;
          ie = Z(F, ie, re, Q);
        }
        return re.write(44), Q[0] = A(re, C, Q[0]), A(re, z, 0), ie;
      }
      function J(F) {
        const { length: ie } = F, re = new _(F), Q = [], pe = [];
        let ne = 0, R = 0, C = 0, z = 0, ae = 0, ce = 0, ye = 0, he = 0;
        do {
          const Pe = re.indexOf(";");
          let Ne = 0;
          for (; re.pos < Pe; re.pos++) {
            if (Ne = x(re, Ne), !g(re, Pe)) {
              const Je = pe.pop();
              Je[2] = ne, Je[3] = Ne;
              continue;
            }
            const we = x(re, 0), Ie = we & 1, Le = we & 2, fe = we & 4;
            let Te = null, de = B, Ue;
            if (Ie) {
              const Je = x(re, R);
              C = x(re, R === Je ? C : 0), R = Je, Ue = [ne, Ne, 0, 0, Je, C];
            } else
              Ue = [ne, Ne, 0, 0];
            if (Ue.isScope = !!fe, Le) {
              const Je = z, He = ae;
              z = x(re, z);
              const st = Je === z;
              ae = x(re, st ? ae : 0), ce = x(re, st && He === ae ? ce : 0), Te = [z, ae, ce];
            }
            if (Ue.callsite = Te, g(re, Pe)) {
              de = [];
              do {
                ye = ne, he = Ne;
                const Je = x(re, 0);
                let He;
                if (Je < -1) {
                  He = [[x(re, 0)]];
                  for (let st = -1; st > Je; st--) {
                    const qe = ye;
                    ye = x(re, ye), he = x(re, ye === qe ? he : 0);
                    const Ge = x(re, 0);
                    He.push([Ge, ye, he]);
                  }
                } else
                  He = [[Je]];
                de.push(He);
              } while (g(re, Pe));
            }
            Ue.bindings = de, Q.push(Ue), pe.push(Ue);
          }
          ne++, re.pos = Pe + 1;
        } while (re.pos < ie);
        return Q;
      }
      function G(F) {
        if (F.length === 0)
          return "";
        const ie = new S();
        for (let re = 0; re < F.length; )
          re = O(F, re, ie, [0, 0, 0, 0, 0, 0, 0]);
        return ie.flush();
      }
      function O(F, ie, re, Q) {
        const pe = F[ie], { 0: ne, 1: R, 2: C, 3: z, isScope: ae, callsite: ce, bindings: ye } = pe;
        Q[0] < ne ? (ee(re, Q[0], ne), Q[0] = ne, Q[1] = 0) : ie > 0 && re.write(44), Q[1] = A(re, pe[1], Q[1]);
        const he = (pe.length === 6 ? 1 : 0) | (ce ? 2 : 0) | (ae ? 4 : 0);
        if (A(re, he, 0), pe.length === 6) {
          const { 4: Pe, 5: Ne } = pe;
          Pe !== Q[2] && (Q[3] = 0), Q[2] = A(re, Pe, Q[2]), Q[3] = A(re, Ne, Q[3]);
        }
        if (ce) {
          const { 0: Pe, 1: Ne, 2: we } = pe.callsite;
          Pe !== Q[4] ? (Q[5] = 0, Q[6] = 0) : Ne !== Q[5] && (Q[6] = 0), Q[4] = A(re, Pe, Q[4]), Q[5] = A(re, Ne, Q[5]), Q[6] = A(re, we, Q[6]);
        }
        if (ye)
          for (const Pe of ye) {
            Pe.length > 1 && A(re, -Pe.length, 0);
            const Ne = Pe[0][0];
            A(re, Ne, 0);
            let we = ne, Ie = R;
            for (let Le = 1; Le < Pe.length; Le++) {
              const fe = Pe[Le];
              we = A(re, fe[1], we), Ie = A(re, fe[2], Ie), A(re, fe[0], 0);
            }
          }
        for (ie++; ie < F.length; ) {
          const Pe = F[ie], { 0: Ne, 1: we } = Pe;
          if (Ne > C || Ne === C && we >= z)
            break;
          ie = O(F, ie, re, Q);
        }
        return Q[0] < C ? (ee(re, Q[0], C), Q[0] = C, Q[1] = 0) : re.write(44), Q[1] = A(re, z, Q[1]), ie;
      }
      function ee(F, ie, re) {
        do
          F.write(59);
        while (++ie < re);
      }
      function L(F) {
        const { length: ie } = F, re = new _(F), Q = [];
        let pe = 0, ne = 0, R = 0, C = 0, z = 0;
        do {
          const ae = re.indexOf(";"), ce = [];
          let ye = !0, he = 0;
          for (pe = 0; re.pos < ae; ) {
            let Pe;
            pe = x(re, pe), pe < he && (ye = !1), he = pe, g(re, ae) ? (ne = x(re, ne), R = x(re, R), C = x(re, C), g(re, ae) ? (z = x(re, z), Pe = [pe, ne, R, C, z]) : Pe = [pe, ne, R, C]) : Pe = [pe], ce.push(Pe), re.pos++;
          }
          ye || q(ce), Q.push(ce), re.pos = ae + 1;
        } while (re.pos <= ie);
        return Q;
      }
      function q(F) {
        F.sort(H);
      }
      function H(F, ie) {
        return F[0] - ie[0];
      }
      function N(F) {
        const ie = new S();
        let re = 0, Q = 0, pe = 0, ne = 0;
        for (let R = 0; R < F.length; R++) {
          const C = F[R];
          if (R > 0 && ie.write(59), C.length === 0)
            continue;
          let z = 0;
          for (let ae = 0; ae < C.length; ae++) {
            const ce = C[ae];
            ae > 0 && ie.write(44), z = A(ie, ce[0], z), ce.length !== 1 && (re = A(ie, ce[1], re), Q = A(ie, ce[2], Q), pe = A(ie, ce[3], pe), ce.length !== 4 && (ne = A(ie, ce[4], ne)));
          }
        }
        return ie.flush();
      }
      u.decode = L, u.decodeGeneratedRanges = J, u.decodeOriginalScopes = y, u.encode = N, u.encodeGeneratedRanges = G, u.encodeOriginalScopes = X, Object.defineProperty(u, "__esModule", { value: !0 });
    });
  }(Ds, Ds.exports)), Ds.exports;
}
var ks = { exports: {} }, Za = { exports: {} }, Vh = Za.exports, hc;
function Kh() {
  return hc || (hc = 1, function(i, l) {
    (function(u, o) {
      i.exports = o();
    })(Vh, function() {
      const u = /^[\w+.-]+:\/\//, o = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, f = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function p(Z) {
        return u.test(Z);
      }
      function P(Z) {
        return Z.startsWith("//");
      }
      function w(Z) {
        return Z.startsWith("/");
      }
      function x(Z) {
        return Z.startsWith("file:");
      }
      function A(Z) {
        return /^[.?#]/.test(Z);
      }
      function g(Z) {
        const J = o.exec(Z);
        return v(J[1], J[2] || "", J[3], J[4] || "", J[5] || "/", J[6] || "", J[7] || "");
      }
      function I(Z) {
        const J = f.exec(Z), G = J[2];
        return v("file:", "", J[1] || "", "", w(G) ? G : "/" + G, J[3] || "", J[4] || "");
      }
      function v(Z, J, G, O, ee, L, q) {
        return {
          scheme: Z,
          user: J,
          host: G,
          port: O,
          path: ee,
          query: L,
          hash: q,
          type: 7
        };
      }
      function S(Z) {
        if (P(Z)) {
          const G = g("http:" + Z);
          return G.scheme = "", G.type = 6, G;
        }
        if (w(Z)) {
          const G = g("http://foo.com" + Z);
          return G.scheme = "", G.host = "", G.type = 5, G;
        }
        if (x(Z))
          return I(Z);
        if (p(Z))
          return g(Z);
        const J = g("http://foo.com/" + Z);
        return J.scheme = "", J.host = "", J.type = Z ? Z.startsWith("?") ? 3 : Z.startsWith("#") ? 2 : 4 : 1, J;
      }
      function _(Z) {
        if (Z.endsWith("/.."))
          return Z;
        const J = Z.lastIndexOf("/");
        return Z.slice(0, J + 1);
      }
      function B(Z, J) {
        y(J, J.type), Z.path === "/" ? Z.path = J.path : Z.path = _(J.path) + Z.path;
      }
      function y(Z, J) {
        const G = J <= 4, O = Z.path.split("/");
        let ee = 1, L = 0, q = !1;
        for (let N = 1; N < O.length; N++) {
          const F = O[N];
          if (!F) {
            q = !0;
            continue;
          }
          if (q = !1, F !== ".") {
            if (F === "..") {
              L ? (q = !0, L--, ee--) : G && (O[ee++] = F);
              continue;
            }
            O[ee++] = F, L++;
          }
        }
        let H = "";
        for (let N = 1; N < ee; N++)
          H += "/" + O[N];
        (!H || q && !H.endsWith("/..")) && (H += "/"), Z.path = H;
      }
      function X(Z, J) {
        if (!Z && !J)
          return "";
        const G = S(Z);
        let O = G.type;
        if (J && O !== 7) {
          const L = S(J), q = L.type;
          switch (O) {
            case 1:
              G.hash = L.hash;
            // fall through
            case 2:
              G.query = L.query;
            // fall through
            case 3:
            case 4:
              B(G, L);
            // fall through
            case 5:
              G.user = L.user, G.host = L.host, G.port = L.port;
            // fall through
            case 6:
              G.scheme = L.scheme;
          }
          q > O && (O = q);
        }
        y(G, O);
        const ee = G.query + G.hash;
        switch (O) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return ee;
          case 4: {
            const L = G.path.slice(1);
            return L ? A(J || Z) && !A(L) ? "./" + L + ee : L + ee : ee || ".";
          }
          case 5:
            return G.path + ee;
          default:
            return G.scheme + "//" + G.user + G.host + G.port + G.path + ee;
        }
      }
      return X;
    });
  }(Za)), Za.exports;
}
var Wh = ks.exports, dc;
function Wp() {
  return dc || (dc = 1, function(i, l) {
    (function(u, o) {
      o(l, Kp(), Kh());
    })(Wh, function(u, o, f) {
      function p(be, ve) {
        return ve && !ve.endsWith("/") && (ve += "/"), f(be, ve);
      }
      function P(be) {
        if (!be)
          return "";
        const ve = be.lastIndexOf("/");
        return be.slice(0, ve + 1);
      }
      const w = 0, x = 1, A = 2, g = 3, I = 4, v = 1, S = 2;
      function _(be, ve) {
        const j = B(be, 0);
        if (j === be.length)
          return be;
        ve || (be = be.slice());
        for (let D = j; D < be.length; D = B(be, D + 1))
          be[D] = X(be[D], ve);
        return be;
      }
      function B(be, ve) {
        for (let j = ve; j < be.length; j++)
          if (!y(be[j]))
            return j;
        return be.length;
      }
      function y(be) {
        for (let ve = 1; ve < be.length; ve++)
          if (be[ve][w] < be[ve - 1][w])
            return !1;
        return !0;
      }
      function X(be, ve) {
        return ve || (be = be.slice()), be.sort(Z);
      }
      function Z(be, ve) {
        return be[w] - ve[w];
      }
      let J = !1;
      function G(be, ve, j, D) {
        for (; j <= D; ) {
          const V = j + (D - j >> 1), le = be[V][w] - ve;
          if (le === 0)
            return J = !0, V;
          le < 0 ? j = V + 1 : D = V - 1;
        }
        return J = !1, j - 1;
      }
      function O(be, ve, j) {
        for (let D = j + 1; D < be.length && be[D][w] === ve; j = D++)
          ;
        return j;
      }
      function ee(be, ve, j) {
        for (let D = j - 1; D >= 0 && be[D][w] === ve; j = D--)
          ;
        return j;
      }
      function L() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function q(be, ve, j, D) {
        const { lastKey: V, lastNeedle: le, lastIndex: me } = j;
        let ge = 0, xe = be.length - 1;
        if (D === V) {
          if (ve === le)
            return J = me !== -1 && be[me][w] === ve, me;
          ve >= le ? ge = me === -1 ? 0 : me : xe = me;
        }
        return j.lastKey = D, j.lastNeedle = ve, j.lastIndex = G(be, ve, ge, xe);
      }
      function H(be, ve) {
        const j = ve.map(F);
        for (let D = 0; D < be.length; D++) {
          const V = be[D];
          for (let le = 0; le < V.length; le++) {
            const me = V[le];
            if (me.length === 1)
              continue;
            const ge = me[x], xe = me[A], De = me[g], We = j[ge], Ce = We[xe] || (We[xe] = []), Ye = ve[ge];
            let $e = O(Ce, De, q(Ce, De, Ye, xe));
            Ye.lastIndex = ++$e, N(Ce, $e, [De, D, me[w]]);
          }
        }
        return j;
      }
      function N(be, ve, j) {
        for (let D = be.length; D > ve; D--)
          be[D] = be[D - 1];
        be[ve] = j;
      }
      function F() {
        return { __proto__: null };
      }
      const ie = function(be, ve) {
        const j = re(be);
        if (!("sections" in j))
          return new ye(j, ve);
        const D = [], V = [], le = [], me = [], ge = [];
        Q(j, ve, D, V, le, me, ge, 0, 0, 1 / 0, 1 / 0);
        const xe = {
          version: 3,
          file: j.file,
          names: me,
          sources: V,
          sourcesContent: le,
          mappings: D,
          ignoreList: ge
        };
        return He(xe);
      };
      function re(be) {
        return typeof be == "string" ? JSON.parse(be) : be;
      }
      function Q(be, ve, j, D, V, le, me, ge, xe, De, We) {
        const { sections: Ce } = be;
        for (let Ye = 0; Ye < Ce.length; Ye++) {
          const { map: $e, offset: et } = Ce[Ye];
          let oe = De, K = We;
          if (Ye + 1 < Ce.length) {
            const Ae = Ce[Ye + 1].offset;
            oe = Math.min(De, ge + Ae.line), oe === De ? K = Math.min(We, xe + Ae.column) : oe < De && (K = xe + Ae.column);
          }
          pe($e, ve, j, D, V, le, me, ge + et.line, xe + et.column, oe, K);
        }
      }
      function pe(be, ve, j, D, V, le, me, ge, xe, De, We) {
        const Ce = re(be);
        if ("sections" in Ce)
          return Q(...arguments);
        const Ye = new ye(Ce, ve), $e = D.length, et = le.length, oe = Ne(Ye), { resolvedSources: K, sourcesContent: Ae, ignoreList: Be } = Ye;
        if (ne(D, K), ne(le, Ye.names), Ae)
          ne(V, Ae);
        else
          for (let Ke = 0; Ke < K.length; Ke++)
            V.push(null);
        if (Be)
          for (let Ke = 0; Ke < Be.length; Ke++)
            me.push(Be[Ke] + $e);
        for (let Ke = 0; Ke < oe.length; Ke++) {
          const ct = ge + Ke;
          if (ct > De)
            return;
          const Lt = R(j, ct), Kt = Ke === 0 ? xe : 0, Nt = oe[Ke];
          for (let At = 0; At < Nt.length; At++) {
            const xt = Nt[At], Wt = Kt + xt[w];
            if (ct === De && Wt >= We)
              return;
            if (xt.length === 1) {
              Lt.push([Wt]);
              continue;
            }
            const $t = $e + xt[x], Jt = xt[A], rr = xt[g];
            Lt.push(xt.length === 4 ? [Wt, $t, Jt, rr] : [Wt, $t, Jt, rr, et + xt[I]]);
          }
        }
      }
      function ne(be, ve) {
        for (let j = 0; j < ve.length; j++)
          be.push(ve[j]);
      }
      function R(be, ve) {
        for (let j = be.length; j <= ve; j++)
          be[j] = [];
        return be[ve];
      }
      const C = "`line` must be greater than 0 (lines start at line 1)", z = "`column` must be greater than or equal to 0 (columns start at column 0)", ae = -1, ce = 1;
      class ye {
        constructor(ve, j) {
          const D = typeof ve == "string";
          if (!D && ve._decodedMemo)
            return ve;
          const V = D ? JSON.parse(ve) : ve, { version: le, file: me, names: ge, sourceRoot: xe, sources: De, sourcesContent: We } = V;
          this.version = le, this.file = me, this.names = ge || [], this.sourceRoot = xe, this.sources = De, this.sourcesContent = We, this.ignoreList = V.ignoreList || V.x_google_ignoreList || void 0;
          const Ce = p(xe || "", P(j));
          this.resolvedSources = De.map(($e) => p($e || "", Ce));
          const { mappings: Ye } = V;
          typeof Ye == "string" ? (this._encoded = Ye, this._decoded = void 0) : (this._encoded = void 0, this._decoded = _(Ye, D)), this._decodedMemo = L(), this._bySources = void 0, this._bySourceMemos = void 0;
        }
      }
      function he(be) {
        return be;
      }
      function Pe(be) {
        var ve, j;
        return (ve = (j = be)._encoded) !== null && ve !== void 0 ? ve : j._encoded = o.encode(be._decoded);
      }
      function Ne(be) {
        var ve;
        return (ve = be)._decoded || (ve._decoded = o.decode(be._encoded));
      }
      function we(be, ve, j) {
        const D = Ne(be);
        if (ve >= D.length)
          return null;
        const V = D[ve], le = ft(V, be._decodedMemo, ve, j, ce);
        return le === -1 ? null : V[le];
      }
      function Ie(be, ve) {
        let { line: j, column: D, bias: V } = ve;
        if (j--, j < 0)
          throw new Error(C);
        if (D < 0)
          throw new Error(z);
        const le = Ne(be);
        if (j >= le.length)
          return at(null, null, null, null);
        const me = le[j], ge = ft(me, be._decodedMemo, j, D, V || ce);
        if (ge === -1)
          return at(null, null, null, null);
        const xe = me[ge];
        if (xe.length === 1)
          return at(null, null, null, null);
        const { names: De, resolvedSources: We } = be;
        return at(We[xe[x]], xe[A] + 1, xe[g], xe.length === 5 ? De[xe[I]] : null);
      }
      function Le(be, ve) {
        const { source: j, line: D, column: V, bias: le } = ve;
        return Tt(be, j, D, V, le || ce, !1);
      }
      function fe(be, ve) {
        const { source: j, line: D, column: V, bias: le } = ve;
        return Tt(be, j, D, V, le || ae, !0);
      }
      function Te(be, ve) {
        const j = Ne(be), { names: D, resolvedSources: V } = be;
        for (let le = 0; le < j.length; le++) {
          const me = j[le];
          for (let ge = 0; ge < me.length; ge++) {
            const xe = me[ge], De = le + 1, We = xe[0];
            let Ce = null, Ye = null, $e = null, et = null;
            xe.length !== 1 && (Ce = V[xe[1]], Ye = xe[2] + 1, $e = xe[3]), xe.length === 5 && (et = D[xe[4]]), ve({
              generatedLine: De,
              generatedColumn: We,
              source: Ce,
              originalLine: Ye,
              originalColumn: $e,
              name: et
            });
          }
        }
      }
      function de(be, ve) {
        const { sources: j, resolvedSources: D } = be;
        let V = j.indexOf(ve);
        return V === -1 && (V = D.indexOf(ve)), V;
      }
      function Ue(be, ve) {
        const { sourcesContent: j } = be;
        if (j == null)
          return null;
        const D = de(be, ve);
        return D === -1 ? null : j[D];
      }
      function Je(be, ve) {
        const { ignoreList: j } = be;
        if (j == null)
          return !1;
        const D = de(be, ve);
        return D === -1 ? !1 : j.includes(D);
      }
      function He(be, ve) {
        const j = new ye(Ge(be, []), ve);
        return j._decoded = be.mappings, j;
      }
      function st(be) {
        return Ge(be, Ne(be));
      }
      function qe(be) {
        return Ge(be, Pe(be));
      }
      function Ge(be, ve) {
        return {
          version: be.version,
          file: be.file,
          names: be.names,
          sourceRoot: be.sourceRoot,
          sources: be.sources,
          sourcesContent: be.sourcesContent,
          mappings: ve,
          ignoreList: be.ignoreList || be.x_google_ignoreList
        };
      }
      function at(be, ve, j, D) {
        return { source: be, line: ve, column: j, name: D };
      }
      function it(be, ve) {
        return { line: be, column: ve };
      }
      function ft(be, ve, j, D, V) {
        let le = q(be, D, ve, j);
        return J ? le = (V === ae ? O : ee)(be, D, le) : V === ae && le++, le === -1 || le === be.length ? -1 : le;
      }
      function Xe(be, ve, j, D, V) {
        let le = ft(be, ve, j, D, ce);
        if (!J && V === ae && le++, le === -1 || le === be.length)
          return [];
        const me = J ? D : be[le][w];
        J || (le = ee(be, me, le));
        const ge = O(be, me, le), xe = [];
        for (; le <= ge; le++) {
          const De = be[le];
          xe.push(it(De[v] + 1, De[S]));
        }
        return xe;
      }
      function Tt(be, ve, j, D, V, le) {
        var me;
        if (j--, j < 0)
          throw new Error(C);
        if (D < 0)
          throw new Error(z);
        const { sources: ge, resolvedSources: xe } = be;
        let De = ge.indexOf(ve);
        if (De === -1 && (De = xe.indexOf(ve)), De === -1)
          return le ? [] : it(null, null);
        const Ce = ((me = be)._bySources || (me._bySources = H(Ne(be), be._bySourceMemos = ge.map(L))))[De][j];
        if (Ce == null)
          return le ? [] : it(null, null);
        const Ye = be._bySourceMemos[De];
        if (le)
          return Xe(Ce, Ye, j, D, V);
        const $e = ft(Ce, Ye, j, D, V);
        if ($e === -1)
          return it(null, null);
        const et = Ce[$e];
        return it(et[v] + 1, et[S]);
      }
      u.AnyMap = ie, u.GREATEST_LOWER_BOUND = ce, u.LEAST_UPPER_BOUND = ae, u.TraceMap = ye, u.allGeneratedPositionsFor = fe, u.decodedMap = st, u.decodedMappings = Ne, u.eachMapping = Te, u.encodedMap = qe, u.encodedMappings = Pe, u.generatedPositionFor = Le, u.isIgnored = Je, u.originalPositionFor = Ie, u.presortedDecodedMap = He, u.sourceContentFor = Ue, u.traceSegment = we;
    });
  }(ks, ks.exports)), ks.exports;
}
var $h = Ns.exports, mc;
function Jh() {
  return mc || (mc = 1, function(i, l) {
    (function(u, o) {
      o(l, qh(), Kp(), Wp());
    })($h, function(u, o, f, p) {
      class v {
        constructor({ file: C, sourceRoot: z } = {}) {
          this._names = new o.SetArray(), this._sources = new o.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = C, this.sourceRoot = z, this._ignoreList = new o.SetArray();
        }
      }
      function S(R) {
        return R;
      }
      function _(R, C, z, ae, ce, ye, he, Pe) {
        return q(!1, R, C, z, ae, ce, ye, he, Pe);
      }
      function B(R, C) {
        return ne(!1, R, C);
      }
      const y = (R, C, z, ae, ce, ye, he, Pe) => q(!0, R, C, z, ae, ce, ye, he, Pe), X = (R, C) => ne(!0, R, C);
      function Z(R, C, z) {
        const { _sources: ae, _sourcesContent: ce } = R, ye = o.put(ae, C);
        ce[ye] = z;
      }
      function J(R, C, z = !0) {
        const { _sources: ae, _sourcesContent: ce, _ignoreList: ye } = R, he = o.put(ae, C);
        he === ce.length && (ce[he] = null), z ? o.put(ye, he) : o.remove(ye, he);
      }
      function G(R) {
        const { _mappings: C, _sources: z, _sourcesContent: ae, _names: ce, _ignoreList: ye } = R;
        return ie(C), {
          version: 3,
          file: R.file || void 0,
          names: ce.array,
          sourceRoot: R.sourceRoot || void 0,
          sources: z.array,
          sourcesContent: ae,
          mappings: C,
          ignoreList: ye.array
        };
      }
      function O(R) {
        const C = G(R);
        return Object.assign(Object.assign({}, C), { mappings: f.encode(C.mappings) });
      }
      function ee(R) {
        const C = new p.TraceMap(R), z = new v({ file: C.file, sourceRoot: C.sourceRoot });
        return re(z._names, C.names), re(z._sources, C.sources), z._sourcesContent = C.sourcesContent || C.sources.map(() => null), z._mappings = p.decodedMappings(C), C.ignoreList && re(z._ignoreList, C.ignoreList), z;
      }
      function L(R) {
        const C = [], { _mappings: z, _sources: ae, _names: ce } = R;
        for (let ye = 0; ye < z.length; ye++) {
          const he = z[ye];
          for (let Pe = 0; Pe < he.length; Pe++) {
            const Ne = he[Pe], we = { line: ye + 1, column: Ne[0] };
            let Ie, Le, fe;
            Ne.length !== 1 && (Ie = ae.array[Ne[1]], Le = { line: Ne[2] + 1, column: Ne[3] }, Ne.length === 5 && (fe = ce.array[Ne[4]])), C.push({ generated: we, source: Ie, original: Le, name: fe });
          }
        }
        return C;
      }
      function q(R, C, z, ae, ce, ye, he, Pe, Ne) {
        const { _mappings: we, _sources: Ie, _sourcesContent: Le, _names: fe } = C, Te = H(we, z), de = N(Te, ae);
        if (!ce)
          return R && Q(Te, de) ? void 0 : F(Te, de, [ae]);
        const Ue = o.put(Ie, ce), Je = Pe ? o.put(fe, Pe) : -1;
        if (Ue === Le.length && (Le[Ue] = Ne ?? null), !(R && pe(Te, de, Ue, ye, he, Je)))
          return F(Te, de, Pe ? [ae, Ue, ye, he, Je] : [ae, Ue, ye, he]);
      }
      function H(R, C) {
        for (let z = R.length; z <= C; z++)
          R[z] = [];
        return R[C];
      }
      function N(R, C) {
        let z = R.length;
        for (let ae = z - 1; ae >= 0; z = ae--) {
          const ce = R[ae];
          if (C >= ce[0])
            break;
        }
        return z;
      }
      function F(R, C, z) {
        for (let ae = R.length; ae > C; ae--)
          R[ae] = R[ae - 1];
        R[C] = z;
      }
      function ie(R) {
        const { length: C } = R;
        let z = C;
        for (let ae = z - 1; ae >= 0 && !(R[ae].length > 0); z = ae, ae--)
          ;
        z < C && (R.length = z);
      }
      function re(R, C) {
        for (let z = 0; z < C.length; z++)
          o.put(R, C[z]);
      }
      function Q(R, C) {
        return C === 0 ? !0 : R[C - 1].length === 1;
      }
      function pe(R, C, z, ae, ce, ye) {
        if (C === 0)
          return !1;
        const he = R[C - 1];
        return he.length === 1 ? !1 : z === he[1] && ae === he[2] && ce === he[3] && ye === (he.length === 5 ? he[4] : -1);
      }
      function ne(R, C, z) {
        const { generated: ae, source: ce, original: ye, name: he, content: Pe } = z;
        return ce ? q(R, C, ae.line - 1, ae.column, ce, ye.line - 1, ye.column, he, Pe) : q(R, C, ae.line - 1, ae.column, null, null, null, null, null);
      }
      u.GenMapping = v, u.addMapping = B, u.addSegment = _, u.allMappings = L, u.fromMap = ee, u.maybeAddMapping = X, u.maybeAddSegment = y, u.setIgnore = J, u.setSourceContent = Z, u.toDecodedMap = G, u.toEncodedMap = O, Object.defineProperty(u, "__esModule", { value: !0 });
    });
  }(Ns, Ns.exports)), Ns.exports;
}
var yc;
function Xh() {
  if (yc) return gs;
  yc = 1, Object.defineProperty(gs, "__esModule", {
    value: !0
  }), gs.default = void 0;
  var i = Jh(), l = Wp();
  class u {
    constructor(f, p) {
      var P;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
      const w = this._map = new i.GenMapping({
        sourceRoot: f.sourceRoot
      });
      if (this._sourceFileName = (P = f.sourceFileName) == null ? void 0 : P.replace(/\\/g, "/"), this._rawMappings = void 0, f.inputSourceMap) {
        this._inputMap = new l.TraceMap(f.inputSourceMap);
        const A = this._inputMap.resolvedSources;
        if (A.length)
          for (let g = 0; g < A.length; g++) {
            var x;
            (0, i.setSourceContent)(w, A[g], (x = this._inputMap.sourcesContent) == null ? void 0 : x[g]);
          }
      }
      if (typeof p == "string" && !f.inputSourceMap)
        (0, i.setSourceContent)(w, this._sourceFileName, p);
      else if (typeof p == "object")
        for (const A of Object.keys(p))
          (0, i.setSourceContent)(w, A.replace(/\\/g, "/"), p[A]);
    }
    get() {
      return (0, i.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, i.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, i.allMappings)(this._map));
    }
    mark(f, p, P, w, x, A) {
      var g;
      this._rawMappings = void 0;
      let I;
      if (p != null)
        if (this._inputMap) {
          if (I = (0, l.originalPositionFor)(this._inputMap, {
            line: p,
            column: P
          }), !I.name && x) {
            const v = (0, l.originalPositionFor)(this._inputMap, x);
            v.name && (w = v.name);
          }
        } else
          I = {
            source: (A == null ? void 0 : A.replace(/\\/g, "/")) || this._sourceFileName,
            line: p,
            column: P
          };
      (0, i.maybeAddMapping)(this._map, {
        name: w,
        generated: f,
        source: (g = I) == null ? void 0 : g.source,
        original: I
      });
    }
  }
  return gs.default = u, gs;
}
var bs = {}, Es = {}, Tc;
function Yh() {
  if (Tc) return Es;
  Tc = 1, Object.defineProperty(Es, "__esModule", {
    value: !0
  }), Es.default = void 0;
  class i {
    constructor(u, o) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = u, this._indentChar = o;
      for (let f = 0; f < 64; f++)
        this._fastIndentations.push(o.repeat(f));
      this._allocQueue();
    }
    _allocQueue() {
      const u = this._queue;
      for (let o = 0; o < 16; o++)
        u.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(u, o, f, p, P) {
      const w = this._queueCursor;
      w === this._queue.length && this._allocQueue();
      const x = this._queue[w];
      x.char = u, x.repeat = o, x.line = f, x.column = p, x.filename = P, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const u = this._map, o = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: u == null ? void 0 : u.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          const f = u ? u.get() : null;
          return o.map = f, f;
        },
        set map(f) {
          Object.defineProperty(o, "map", {
            value: f,
            writable: !0
          });
        },
        get rawMappings() {
          const f = u == null ? void 0 : u.getRawMappings();
          return o.rawMappings = f, f;
        },
        set rawMappings(f) {
          Object.defineProperty(o, "rawMappings", {
            value: f,
            writable: !0
          });
        }
      };
      return o;
    }
    append(u, o) {
      this._flush(), this._append(u, this._sourcePosition, o);
    }
    appendChar(u) {
      this._flush(), this._appendChar(u, 1, this._sourcePosition);
    }
    queue(u) {
      if (u === 10)
        for (; this._queueCursor !== 0; ) {
          const f = this._queue[this._queueCursor - 1].char;
          if (f !== 32 && f !== 9)
            break;
          this._queueCursor--;
        }
      const o = this._sourcePosition;
      this._pushQueue(u, 1, o.line, o.column, o.filename);
    }
    queueIndentation(u) {
      u !== 0 && this._pushQueue(-1, u, void 0, void 0, void 0);
    }
    _flush() {
      const u = this._queueCursor, o = this._queue;
      for (let f = 0; f < u; f++) {
        const p = o[f];
        this._appendChar(p.char, p.repeat, p);
      }
      this._queueCursor = 0;
    }
    _appendChar(u, o, f) {
      if (this._last = u, u === -1) {
        const p = this._fastIndentations[o];
        p !== void 0 ? this._str += p : this._str += o > 1 ? this._indentChar.repeat(o) : this._indentChar;
      } else
        this._str += o > 1 ? String.fromCharCode(u).repeat(o) : String.fromCharCode(u);
      u !== 10 ? (this._mark(f.line, f.column, f.identifierName, f.identifierNamePos, f.filename), this._position.column += o) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (f.identifierName = void 0, f.identifierNamePos = void 0);
    }
    _append(u, o, f) {
      const p = u.length, P = this._position;
      if (this._last = u.charCodeAt(p - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = u, this._appendCount = 0) : this._str += u, !f && !this._map) {
        P.column += p;
        return;
      }
      const {
        column: w,
        identifierName: x,
        identifierNamePos: A,
        filename: g
      } = o;
      let I = o.line;
      (x != null || A != null) && this._canMarkIdName && (o.identifierName = void 0, o.identifierNamePos = void 0);
      let v = u.indexOf(`
`), S = 0;
      for (v !== 0 && this._mark(I, w, x, A, g); v !== -1; )
        P.line++, P.column = 0, S = v + 1, S < p && I !== void 0 && this._mark(++I, 0, null, null, g), v = u.indexOf(`
`, S);
      P.column += p - S;
    }
    _mark(u, o, f, p, P) {
      var w;
      (w = this._map) == null || w.mark(this._position, u, o, f, p, P);
    }
    removeTrailingNewline() {
      const u = this._queueCursor;
      u !== 0 && this._queue[u - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      const u = this._queueCursor;
      u !== 0 && this._queue[u - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      const u = this._queueCursor;
      return u !== 0 ? this._queue[u - 1].char : this._last;
    }
    getNewlineCount() {
      const u = this._queueCursor;
      let o = 0;
      if (u === 0) return this._last === 10 ? 1 : 0;
      for (let f = u - 1; f >= 0 && this._queue[f].char === 10; f--)
        o++;
      return o === u && this._last === 10 ? o + 1 : o;
    }
    endsWithCharAndNewline() {
      const u = this._queue, o = this._queueCursor;
      if (o !== 0)
        return u[o - 1].char !== 10 ? void 0 : o > 1 ? u[o - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(u, o) {
      if (!this._map) {
        o();
        return;
      }
      this.source("start", u);
      const f = u.identifierName, p = this._sourcePosition;
      f && (this._canMarkIdName = !1, p.identifierName = f), o(), f && (this._canMarkIdName = !0, p.identifierName = void 0, p.identifierNamePos = void 0), this.source("end", u);
    }
    source(u, o) {
      this._map && this._normalizePosition(u, o, 0);
    }
    sourceWithOffset(u, o, f) {
      this._map && this._normalizePosition(u, o, f);
    }
    _normalizePosition(u, o, f) {
      const p = o[u], P = this._sourcePosition;
      p && (P.line = p.line, P.column = Math.max(p.column + f, 0), P.filename = o.filename);
    }
    getCurrentColumn() {
      const u = this._queue, o = this._queueCursor;
      let f = -1, p = 0;
      for (let P = 0; P < o; P++) {
        const w = u[P];
        w.char === 10 && (f = p), p += w.repeat;
      }
      return f === -1 ? this._position.column + p : p - 1 - f;
    }
    getCurrentLine() {
      let u = 0;
      const o = this._queue;
      for (let f = 0; f < this._queueCursor; f++)
        o[f].char === 10 && u++;
      return this._position.line + u;
    }
  }
  return Es.default = i, Es;
}
var cr = {}, Ps = {}, Sc;
function Hh() {
  if (Sc) return Ps;
  Sc = 1, Object.defineProperty(Ps, "__esModule", {
    value: !0
  }), Ps.nodes = void 0;
  var i = Ze();
  const {
    FLIPPED_ALIAS_KEYS: l,
    isArrayExpression: u,
    isAssignmentExpression: o,
    isBinary: f,
    isBlockStatement: p,
    isCallExpression: P,
    isFunction: w,
    isIdentifier: x,
    isLiteral: A,
    isMemberExpression: g,
    isObjectExpression: I,
    isOptionalCallExpression: v,
    isOptionalMemberExpression: S,
    isStringLiteral: _
  } = i;
  function B(G, O) {
    return G && (g(G) || S(G) ? (B(G.object, O), G.computed && B(G.property, O)) : f(G) || o(G) ? (B(G.left, O), B(G.right, O)) : P(G) || v(G) ? (O.hasCall = !0, B(G.callee, O)) : w(G) ? O.hasFunction = !0 : x(G) && (O.hasHelper = O.hasHelper || G.callee && X(G.callee))), O;
  }
  function y(G) {
    return B(G, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  function X(G) {
    return G ? g(G) ? X(G.object) || X(G.property) : x(G) ? G.name === "require" || G.name.charCodeAt(0) === 95 : P(G) ? X(G.callee) : f(G) || o(G) ? x(G.left) && X(G.left) || X(G.right) : !1 : !1;
  }
  function Z(G) {
    return A(G) || I(G) || u(G) || x(G) || g(G);
  }
  const J = Ps.nodes = {
    AssignmentExpression(G) {
      const O = y(G.right);
      if (O.hasCall && O.hasHelper || O.hasFunction)
        return O.hasFunction ? 3 : 2;
    },
    SwitchCase(G, O) {
      return (G.consequent.length || O.cases[0] === G ? 1 : 0) | (!G.consequent.length && O.cases[O.cases.length - 1] === G ? 2 : 0);
    },
    LogicalExpression(G) {
      if (w(G.left) || w(G.right))
        return 2;
    },
    Literal(G) {
      if (_(G) && G.value === "use strict")
        return 2;
    },
    CallExpression(G) {
      if (w(G.callee) || X(G))
        return 3;
    },
    OptionalCallExpression(G) {
      if (w(G.callee))
        return 3;
    },
    VariableDeclaration(G) {
      for (let O = 0; O < G.declarations.length; O++) {
        const ee = G.declarations[O];
        let L = X(ee.id) && !Z(ee.init);
        if (!L && ee.init) {
          const q = y(ee.init);
          L = X(ee.init) && q.hasCall || q.hasFunction;
        }
        if (L)
          return 3;
      }
    },
    IfStatement(G) {
      if (p(G.consequent))
        return 3;
    }
  };
  return J.ObjectProperty = J.ObjectTypeProperty = J.ObjectMethod = function(G, O) {
    if (O.properties[0] === G)
      return 1;
  }, J.ObjectTypeCallProperty = function(G, O) {
    var ee;
    if (O.callProperties[0] === G && !((ee = O.properties) != null && ee.length))
      return 1;
  }, J.ObjectTypeIndexer = function(G, O) {
    var ee, L;
    if (O.indexers[0] === G && !((ee = O.properties) != null && ee.length) && !((L = O.callProperties) != null && L.length))
      return 1;
  }, J.ObjectTypeInternalSlot = function(G, O) {
    var ee, L, q;
    if (O.internalSlots[0] === G && !((ee = O.properties) != null && ee.length) && !((L = O.callProperties) != null && L.length) && !((q = O.indexers) != null && q.length))
      return 1;
  }, [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([G, O]) {
    [G].concat(l[G] || []).forEach(function(ee) {
      const L = O ? 3 : 0;
      J[ee] = () => L;
    });
  }), Ps;
}
var nt = {}, gc;
function Gh() {
  if (gc) return nt;
  gc = 1, Object.defineProperty(nt, "__esModule", {
    value: !0
  }), nt.AssignmentExpression = we, nt.Binary = L, nt.BinaryExpression = C, nt.ClassExpression = ce, nt.ArrowFunctionExpression = nt.ConditionalExpression = Pe, nt.DoExpression = ee, nt.FunctionExpression = he, nt.FunctionTypeAnnotation = Z, nt.Identifier = Le, nt.LogicalExpression = Ie, nt.NullableTypeAnnotation = X, nt.ObjectExpression = O, nt.OptionalIndexedAccessType = H, nt.OptionalCallExpression = nt.OptionalMemberExpression = Ne, nt.SequenceExpression = z, nt.TSSatisfiesExpression = nt.TSAsExpression = N, nt.TSConditionalType = F, nt.TSConstructorType = nt.TSFunctionType = R, nt.TSInferType = Q, nt.TSInstantiationExpression = ne, nt.TSIntersectionType = re, nt.UnaryLike = nt.TSTypeAssertion = ye, nt.TSTypeOperator = pe, nt.TSUnionType = ie, nt.IntersectionTypeAnnotation = nt.UnionTypeAnnotation = q, nt.UpdateExpression = J, nt.AwaitExpression = nt.YieldExpression = ae;
  var i = Ze(), l = Zi();
  const {
    isArrayTypeAnnotation: u,
    isBinaryExpression: o,
    isCallExpression: f,
    isForOfStatement: p,
    isIndexedAccessType: P,
    isMemberExpression: w,
    isObjectPattern: x,
    isOptionalMemberExpression: A,
    isYieldExpression: g,
    isStatement: I
  } = i, v = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function S(fe, Te) {
    if (Te === "BinaryExpression" || Te === "LogicalExpression")
      return v.get(fe.operator);
    if (Te === "TSAsExpression" || Te === "TSSatisfiesExpression")
      return v.get("in");
  }
  function _(fe) {
    return fe === "TSAsExpression" || fe === "TSSatisfiesExpression" || fe === "TSTypeAssertion";
  }
  const B = (fe, Te) => {
    const de = Te.type;
    return (de === "ClassDeclaration" || de === "ClassExpression") && Te.superClass === fe;
  }, y = (fe, Te) => {
    const de = Te.type;
    return (de === "MemberExpression" || de === "OptionalMemberExpression") && Te.object === fe || (de === "CallExpression" || de === "OptionalCallExpression" || de === "NewExpression") && Te.callee === fe || de === "TaggedTemplateExpression" && Te.tag === fe || de === "TSNonNullExpression";
  };
  function X(fe, Te) {
    return u(Te);
  }
  function Z(fe, Te, de) {
    const Ue = Te.type;
    return Ue === "UnionTypeAnnotation" || Ue === "IntersectionTypeAnnotation" || Ue === "ArrayTypeAnnotation" || !!(de & l.TokenContext.arrowFlowReturnType);
  }
  function J(fe, Te) {
    return y(fe, Te) || B(fe, Te);
  }
  function G(fe) {
    return !!(fe & (l.TokenContext.expressionStatement | l.TokenContext.arrowBody));
  }
  function O(fe, Te, de) {
    return G(de);
  }
  function ee(fe, Te, de) {
    return !fe.async && !!(de & l.TokenContext.expressionStatement);
  }
  function L(fe, Te) {
    const de = Te.type;
    if (fe.type === "BinaryExpression" && fe.operator === "**" && de === "BinaryExpression" && Te.operator === "**")
      return Te.left === fe;
    if (B(fe, Te) || y(fe, Te) || de === "UnaryExpression" || de === "SpreadElement" || de === "AwaitExpression")
      return !0;
    const Ue = S(Te, de);
    if (Ue != null) {
      const Je = S(fe, fe.type);
      if (Ue === Je && de === "BinaryExpression" && Te.right === fe || Ue > Je)
        return !0;
    }
  }
  function q(fe, Te) {
    const de = Te.type;
    return de === "ArrayTypeAnnotation" || de === "NullableTypeAnnotation" || de === "IntersectionTypeAnnotation" || de === "UnionTypeAnnotation";
  }
  function H(fe, Te) {
    return P(Te) && Te.objectType === fe;
  }
  function N(fe, Te) {
    return (Te.type === "AssignmentExpression" || Te.type === "AssignmentPattern") && Te.left === fe || Te.type === "BinaryExpression" && (Te.operator === "|" || Te.operator === "&") && fe === Te.left ? !0 : L(fe, Te);
  }
  function F(fe, Te) {
    const de = Te.type;
    return de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSOptionalType" || de === "TSTypeOperator" || de === "TSTypeParameter" || (de === "TSIntersectionType" || de === "TSUnionType") && Te.types[0] === fe || de === "TSConditionalType" && (Te.checkType === fe || Te.extendsType === fe);
  }
  function ie(fe, Te) {
    const de = Te.type;
    return de === "TSIntersectionType" || de === "TSTypeOperator" || de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSOptionalType";
  }
  function re(fe, Te) {
    const de = Te.type;
    return de === "TSTypeOperator" || de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSOptionalType";
  }
  function Q(fe, Te) {
    const de = Te.type;
    return !!(de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSOptionalType" || fe.typeParameter.constraint && (de === "TSIntersectionType" || de === "TSUnionType") && Te.types[0] === fe);
  }
  function pe(fe, Te) {
    const de = Te.type;
    return de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSOptionalType";
  }
  function ne(fe, Te) {
    const de = Te.type;
    return (de === "CallExpression" || de === "OptionalCallExpression" || de === "NewExpression" || de === "TSInstantiationExpression") && !!Te.typeParameters;
  }
  function R(fe, Te) {
    const de = Te.type;
    return de === "TSIntersectionType" || de === "TSUnionType" || de === "TSTypeOperator" || de === "TSOptionalType" || de === "TSArrayType" || de === "TSIndexedAccessType" && Te.objectType === fe || de === "TSConditionalType" && (Te.checkType === fe || Te.extendsType === fe);
  }
  function C(fe, Te, de, Ue) {
    return fe.operator === "in" && Ue;
  }
  function z(fe, Te) {
    const de = Te.type;
    return de === "SequenceExpression" || de === "ParenthesizedExpression" || de === "MemberExpression" && Te.property === fe || de === "OptionalMemberExpression" && Te.property === fe || de === "TemplateLiteral" ? !1 : de === "ClassDeclaration" ? !0 : de === "ForOfStatement" ? Te.right === fe : de === "ExportDefaultDeclaration" ? !0 : !I(Te);
  }
  function ae(fe, Te) {
    const de = Te.type;
    return de === "BinaryExpression" || de === "LogicalExpression" || de === "UnaryExpression" || de === "SpreadElement" || y(fe, Te) || de === "AwaitExpression" && g(fe) || de === "ConditionalExpression" && fe === Te.test || B(fe, Te) || _(de);
  }
  function ce(fe, Te, de) {
    return !!(de & (l.TokenContext.expressionStatement | l.TokenContext.exportDefault));
  }
  function ye(fe, Te) {
    return y(fe, Te) || o(Te) && Te.operator === "**" && Te.left === fe || B(fe, Te);
  }
  function he(fe, Te, de) {
    return !!(de & (l.TokenContext.expressionStatement | l.TokenContext.exportDefault));
  }
  function Pe(fe, Te) {
    const de = Te.type;
    return de === "UnaryExpression" || de === "SpreadElement" || de === "BinaryExpression" || de === "LogicalExpression" || de === "ConditionalExpression" && Te.test === fe || de === "AwaitExpression" || _(de) ? !0 : ye(fe, Te);
  }
  function Ne(fe, Te) {
    return f(Te) && Te.callee === fe || w(Te) && Te.object === fe;
  }
  function we(fe, Te, de) {
    return G(de) && x(fe.left) ? !0 : Pe(fe, Te);
  }
  function Ie(fe, Te) {
    const de = Te.type;
    if (_(de)) return !0;
    if (de !== "LogicalExpression") return !1;
    switch (fe.operator) {
      case "||":
        return Te.operator === "??" || Te.operator === "&&";
      case "&&":
        return Te.operator === "??";
      case "??":
        return Te.operator !== "??";
    }
  }
  function Le(fe, Te, de, Ue, Je) {
    var He;
    const st = Te.type;
    if ((He = fe.extra) != null && He.parenthesized && st === "AssignmentExpression" && Te.left === fe) {
      const qe = Te.right.type;
      if ((qe === "FunctionExpression" || qe === "ClassExpression") && Te.right.id == null)
        return !0;
    }
    return Je && Je(fe) !== fe.name ? !1 : fe.name === "let" ? (w(Te, {
      object: fe,
      computed: !0
    }) || A(Te, {
      object: fe,
      computed: !0,
      optional: !1
    })) && de & (l.TokenContext.expressionStatement | l.TokenContext.forHead | l.TokenContext.forInHead) ? !0 : !!(de & l.TokenContext.forOfHead) : fe.name === "async" && p(Te, {
      left: fe,
      await: !1
    });
  }
  return nt;
}
var bc;
function Zi() {
  if (bc) return cr;
  bc = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.TokenContext = void 0, cr.isLastChild = G, cr.needsParens = Z, cr.needsWhitespace = B, cr.needsWhitespaceAfter = X, cr.needsWhitespaceBefore = y;
  var i = Hh(), l = Gh(), u = Ze();
  const {
    FLIPPED_ALIAS_KEYS: o,
    VISITOR_KEYS: f,
    isCallExpression: p,
    isDecorator: P,
    isExpressionStatement: w,
    isMemberExpression: x,
    isNewExpression: A,
    isParenthesizedExpression: g
  } = u;
  cr.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function I(O) {
    const ee = /* @__PURE__ */ new Map();
    function L(q, H) {
      const N = ee.get(q);
      ee.set(q, N ? function(F, ie, re, Q, pe) {
        var ne;
        return (ne = N(F, ie, re, Q, pe)) != null ? ne : H(F, ie, re, Q, pe);
      } : H);
    }
    for (const q of Object.keys(O)) {
      const H = o[q];
      if (H)
        for (const N of H)
          L(N, O[q]);
      else
        L(q, O[q]);
    }
    return ee;
  }
  const v = I(l), S = I(i.nodes);
  function _(O) {
    return p(O) ? !0 : x(O) && _(O.object);
  }
  function B(O, ee, L) {
    var q;
    if (!O) return !1;
    w(O) && (O = O.expression);
    const H = (q = S.get(O.type)) == null ? void 0 : q(O, ee);
    return typeof H == "number" ? (H & L) !== 0 : !1;
  }
  function y(O, ee) {
    return B(O, ee, 1);
  }
  function X(O, ee) {
    return B(O, ee, 2);
  }
  function Z(O, ee, L, q, H) {
    var N;
    return ee ? A(ee) && ee.callee === O && _(O) ? !0 : P(ee) ? !J(O) && !(p(O) && J(O.callee)) && !g(O) : (N = v.get(O.type)) == null ? void 0 : N(O, ee, L, q, H) : !1;
  }
  function J(O) {
    switch (O.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !O.computed && O.property.type === "Identifier" && J(O.object);
      default:
        return !1;
    }
  }
  function G(O, ee) {
    const L = f[O.type];
    for (let q = L.length - 1; q >= 0; q--) {
      const H = O[L[q]];
      if (H === ee)
        return !0;
      if (Array.isArray(H)) {
        let N = H.length - 1;
        for (; N >= 0 && H[N] === null; ) N--;
        return N >= 0 && H[N] === ee;
      } else if (H)
        return !1;
    }
    return !1;
  }
  return cr;
}
var xs = {}, Ec;
function zh() {
  if (Ec) return xs;
  Ec = 1, Object.defineProperty(xs, "__esModule", {
    value: !0
  }), xs.TokenMap = void 0;
  var i = Ze();
  const {
    traverseFast: l,
    VISITOR_KEYS: u
  } = i;
  class o {
    constructor(P, w, x) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = w, this._source = x, l(P, (A) => {
        const g = this._getTokensIndexesOfNode(A);
        g.length > 0 && this._nodesToTokenIndexes.set(A, g);
      }), this._tokensCache = null;
    }
    has(P) {
      return this._nodesToTokenIndexes.has(P);
    }
    getIndexes(P) {
      return this._nodesToTokenIndexes.get(P);
    }
    find(P, w) {
      const x = this._nodesToTokenIndexes.get(P);
      if (x)
        for (let A = 0; A < x.length; A++) {
          const g = x[A], I = this._tokens[g];
          if (w(I, g)) return I;
        }
      return null;
    }
    findLastIndex(P, w) {
      const x = this._nodesToTokenIndexes.get(P);
      if (x)
        for (let A = x.length - 1; A >= 0; A--) {
          const g = x[A], I = this._tokens[g];
          if (w(I, g)) return g;
        }
      return -1;
    }
    findMatching(P, w, x = 0) {
      const A = this._nodesToTokenIndexes.get(P);
      if (A) {
        let g = 0;
        const I = x;
        if (I > 1) {
          const v = this._nodesOccurrencesCountCache.get(P);
          v && v.test === w && v.count < I && (g = v.i + 1, x -= v.count + 1);
        }
        for (; g < A.length; g++) {
          const v = this._tokens[A[g]];
          if (this.matchesOriginal(v, w)) {
            if (x === 0)
              return I > 0 && this._nodesOccurrencesCountCache.set(P, {
                test: w,
                count: I,
                i: g
              }), v;
            x--;
          }
        }
      }
      return null;
    }
    matchesOriginal(P, w) {
      return P.end - P.start !== w.length ? !1 : P.value != null ? P.value === w : this._source.startsWith(w, P.start);
    }
    startMatches(P, w) {
      const x = this._nodesToTokenIndexes.get(P);
      if (!x) return !1;
      const A = this._tokens[x[0]];
      return A.start !== P.start ? !1 : this.matchesOriginal(A, w);
    }
    endMatches(P, w) {
      const x = this._nodesToTokenIndexes.get(P);
      if (!x) return !1;
      const A = this._tokens[x[x.length - 1]];
      return A.end !== P.end ? !1 : this.matchesOriginal(A, w);
    }
    _getTokensIndexesOfNode(P) {
      if (P.start == null || P.end == null) return [];
      const {
        first: w,
        last: x
      } = this._findTokensOfNode(P, 0, this._tokens.length - 1);
      let A = w;
      const g = f(P);
      (P.type === "ExportNamedDeclaration" || P.type === "ExportDefaultDeclaration") && P.declaration && P.declaration.type === "ClassDeclaration" && g.next();
      const I = [];
      for (const v of g) {
        if (v == null || v.start == null || v.end == null) continue;
        const S = this._findTokensOfNode(v, A, x), _ = S.first;
        for (let B = A; B < _; B++) I.push(B);
        A = S.last + 1;
      }
      for (let v = A; v <= x; v++) I.push(v);
      return I;
    }
    _findTokensOfNode(P, w, x) {
      const A = this._tokensCache.get(P);
      if (A) return A;
      const g = this._findFirstTokenOfNode(P.start, w, x), I = this._findLastTokenOfNode(P.end, g, x);
      return this._tokensCache.set(P, {
        first: g,
        last: I
      }), {
        first: g,
        last: I
      };
    }
    _findFirstTokenOfNode(P, w, x) {
      for (; w <= x; ) {
        const A = x + w >> 1;
        if (P < this._tokens[A].start)
          x = A - 1;
        else if (P > this._tokens[A].start)
          w = A + 1;
        else
          return A;
      }
      return w;
    }
    _findLastTokenOfNode(P, w, x) {
      for (; w <= x; ) {
        const A = x + w >> 1;
        if (P < this._tokens[A].end)
          x = A - 1;
        else if (P > this._tokens[A].end)
          w = A + 1;
        else
          return A;
      }
      return x;
    }
  }
  xs.TokenMap = o;
  function* f(p) {
    if (p.type === "TemplateLiteral") {
      yield p.quasis[0];
      for (let w = 1; w < p.quasis.length; w++)
        yield p.expressions[w - 1], yield p.quasis[w];
      return;
    }
    const P = u[p.type];
    for (const w of P) {
      const x = p[w];
      x && (Array.isArray(x) ? yield* x : yield x);
    }
  }
  return xs;
}
var Qo = {}, Hi = {}, Pc;
function Qh() {
  if (Pc) return Hi;
  Pc = 1, Object.defineProperty(Hi, "__esModule", {
    value: !0
  }), Hi.TaggedTemplateExpression = i, Hi.TemplateElement = l, Hi.TemplateLiteral = o, Hi._printTemplate = u;
  function i(f) {
    this.print(f.tag), this.print(f.typeParameters), this.print(f.quasi);
  }
  function l() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function u(f, p) {
    const P = f.quasis;
    let w = "`";
    for (let x = 0; x < P.length - 1; x++)
      if (w += P[x].value.raw, this.token(w + "${", !0), this.print(p[x]), w = "}", this.tokenMap) {
        const A = this.tokenMap.findMatching(f, "}", x);
        A && this._catchUpTo(A.loc.start);
      }
    w += P[P.length - 1].value.raw, this.token(w + "`", !0);
  }
  function o(f) {
    this._printTemplate(f, f.expressions);
  }
  return Hi;
}
var lt = {}, xc;
function Zh() {
  if (xc) return lt;
  xc = 1, Object.defineProperty(lt, "__esModule", {
    value: !0
  }), lt.LogicalExpression = lt.BinaryExpression = lt.AssignmentExpression = F, lt.AssignmentPattern = N, lt.AwaitExpression = ee, lt.BindExpression = ie, lt.CallExpression = G, lt.ConditionalExpression = I, lt.Decorator = X, lt.DoExpression = x, lt.EmptyStatement = q, lt.ExpressionStatement = H, lt.Import = O, lt.MemberExpression = re, lt.MetaProperty = Q, lt.ModuleExpression = R, lt.NewExpression = v, lt.OptionalCallExpression = J, lt.OptionalMemberExpression = Z, lt.ParenthesizedExpression = A, lt.PrivateName = pe, lt.SequenceExpression = S, lt.Super = B, lt.ThisExpression = _, lt.UnaryExpression = w, lt.UpdateExpression = g, lt.V8IntrinsicIdentifier = ne, lt.YieldExpression = L, lt._shouldPrintDecoratorsBeforeExport = y;
  var i = Ze(), l = Zi();
  const {
    isCallExpression: u,
    isLiteral: o,
    isMemberExpression: f,
    isNewExpression: p,
    isPattern: P
  } = i;
  function w(C) {
    const {
      operator: z
    } = C;
    z === "void" || z === "delete" || z === "typeof" || z === "throw" ? (this.word(z), this.space()) : this.token(z), this.print(C.argument);
  }
  function x(C) {
    C.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(C.body);
  }
  function A(C) {
    this.tokenChar(40);
    const z = this.enterDelimited();
    this.print(C.expression), z(), this.rightParens(C);
  }
  function g(C) {
    C.prefix ? (this.token(C.operator), this.print(C.argument)) : (this.print(C.argument, !0), this.token(C.operator));
  }
  function I(C) {
    this.print(C.test), this.space(), this.tokenChar(63), this.space(), this.print(C.consequent), this.space(), this.tokenChar(58), this.space(), this.print(C.alternate);
  }
  function v(C, z) {
    if (this.word("new"), this.space(), this.print(C.callee), this.format.minified && C.arguments.length === 0 && !C.optional && !u(z, {
      callee: C
    }) && !f(z) && !p(z) || (this.print(C.typeArguments), this.print(C.typeParameters), C.optional && this.token("?."), C.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(C, ")")))
      return;
    this.tokenChar(40);
    const ae = this.enterDelimited();
    this.printList(C.arguments, this.shouldPrintTrailingComma(")")), ae(), this.rightParens(C);
  }
  function S(C) {
    this.printList(C.expressions);
  }
  function _() {
    this.word("this");
  }
  function B() {
    this.word("super");
  }
  function y(C) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof C.start == "number" && C.start === C.declaration.start;
  }
  function X(C) {
    this.tokenChar(64), this.print(C.expression), this.newline();
  }
  function Z(C) {
    let {
      computed: z
    } = C;
    const {
      optional: ae,
      property: ce
    } = C;
    if (this.print(C.object), !z && f(ce))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    o(ce) && typeof ce.value == "number" && (z = !0), ae && this.token("?."), z ? (this.tokenChar(91), this.print(ce), this.tokenChar(93)) : (ae || this.tokenChar(46), this.print(ce));
  }
  function J(C) {
    this.print(C.callee), this.print(C.typeParameters), C.optional && this.token("?."), this.print(C.typeArguments), this.tokenChar(40);
    const z = this.enterDelimited();
    this.printList(C.arguments), z(), this.rightParens(C);
  }
  function G(C) {
    this.print(C.callee), this.print(C.typeArguments), this.print(C.typeParameters), this.tokenChar(40);
    const z = this.enterDelimited();
    this.printList(C.arguments, this.shouldPrintTrailingComma(")")), z(), this.rightParens(C);
  }
  function O() {
    this.word("import");
  }
  function ee(C) {
    this.word("await"), C.argument && (this.space(), this.printTerminatorless(C.argument));
  }
  function L(C) {
    this.word("yield", !0), C.delegate ? (this.tokenChar(42), C.argument && (this.space(), this.print(C.argument))) : C.argument && (this.space(), this.printTerminatorless(C.argument));
  }
  function q() {
    this.semicolon(!0);
  }
  function H(C) {
    this.tokenContext |= l.TokenContext.expressionStatement, this.print(C.expression), this.semicolon();
  }
  function N(C) {
    this.print(C.left), (C.left.type === "Identifier" || P(C.left)) && (C.left.optional && this.tokenChar(63), this.print(C.left.typeAnnotation)), this.space(), this.tokenChar(61), this.space(), this.print(C.right);
  }
  function F(C) {
    this.print(C.left), this.space(), C.operator === "in" || C.operator === "instanceof" ? this.word(C.operator) : (this.token(C.operator), this._endsWithDiv = C.operator === "/"), this.space(), this.print(C.right);
  }
  function ie(C) {
    this.print(C.object), this.token("::"), this.print(C.callee);
  }
  function re(C) {
    if (this.print(C.object), !C.computed && f(C.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let z = C.computed;
    if (o(C.property) && typeof C.property.value == "number" && (z = !0), z) {
      const ae = this.enterDelimited();
      this.tokenChar(91), this.print(C.property), this.tokenChar(93), ae();
    } else
      this.tokenChar(46), this.print(C.property);
  }
  function Q(C) {
    this.print(C.meta), this.tokenChar(46), this.print(C.property);
  }
  function pe(C) {
    this.tokenChar(35), this.print(C.id);
  }
  function ne(C) {
    this.tokenChar(37), this.word(C.name);
  }
  function R(C) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    const {
      body: z
    } = C;
    (z.body.length || z.directives.length) && this.newline(), this.print(z), this.dedent(), this.rightBrace(C);
  }
  return lt;
}
var yt = {}, vc;
function ed() {
  if (vc) return yt;
  vc = 1, Object.defineProperty(yt, "__esModule", {
    value: !0
  }), yt.BreakStatement = _, yt.CatchClause = G, yt.ContinueStatement = B, yt.DebuggerStatement = L, yt.DoWhileStatement = v, yt.ForOfStatement = yt.ForInStatement = void 0, yt.ForStatement = A, yt.IfStatement = w, yt.LabeledStatement = Z, yt.ReturnStatement = y, yt.SwitchCase = ee, yt.SwitchStatement = O, yt.ThrowStatement = X, yt.TryStatement = J, yt.VariableDeclaration = q, yt.VariableDeclarator = H, yt.WhileStatement = g, yt.WithStatement = P;
  var i = Ze(), l = Zi();
  const {
    isFor: u,
    isForStatement: o,
    isIfStatement: f,
    isStatement: p
  } = i;
  function P(N) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(N.object), this.tokenChar(41), this.printBlock(N);
  }
  function w(N) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(N.test), this.tokenChar(41), this.space();
    const F = N.alternate && f(x(N.consequent));
    F && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(N.consequent), F && (this.dedent(), this.newline(), this.tokenChar(125)), N.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(N.alternate));
  }
  function x(N) {
    const {
      body: F
    } = N;
    return p(F) === !1 ? N : x(F);
  }
  function A(N) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      const F = this.enterForStatementInit();
      this.tokenContext |= l.TokenContext.forHead, this.print(N.init), F();
    }
    this.tokenChar(59), N.test && (this.space(), this.print(N.test)), this.token(";", !1, 1), N.update && (this.space(), this.print(N.update)), this.tokenChar(41), this.printBlock(N);
  }
  function g(N) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(N.test), this.tokenChar(41), this.printBlock(N);
  }
  function I(N) {
    this.word("for"), this.space();
    const F = N.type === "ForOfStatement";
    F && N.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      const ie = F ? null : this.enterForStatementInit();
      this.tokenContext |= F ? l.TokenContext.forOfHead : l.TokenContext.forInHead, this.print(N.left), ie == null || ie();
    }
    this.space(), this.word(F ? "of" : "in"), this.space(), this.print(N.right), this.tokenChar(41), this.printBlock(N);
  }
  yt.ForInStatement = I, yt.ForOfStatement = I;
  function v(N) {
    this.word("do"), this.space(), this.print(N.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(N.test), this.tokenChar(41), this.semicolon();
  }
  function S(N, F) {
    F && (N.space(), N.printTerminatorless(F)), N.semicolon();
  }
  function _(N) {
    this.word("break"), S(this, N.label);
  }
  function B(N) {
    this.word("continue"), S(this, N.label);
  }
  function y(N) {
    this.word("return"), S(this, N.argument);
  }
  function X(N) {
    this.word("throw"), S(this, N.argument);
  }
  function Z(N) {
    this.print(N.label), this.tokenChar(58), this.space(), this.print(N.body);
  }
  function J(N) {
    this.word("try"), this.space(), this.print(N.block), this.space(), N.handlers ? this.print(N.handlers[0]) : this.print(N.handler), N.finalizer && (this.space(), this.word("finally"), this.space(), this.print(N.finalizer));
  }
  function G(N) {
    this.word("catch"), this.space(), N.param && (this.tokenChar(40), this.print(N.param), this.print(N.param.typeAnnotation), this.tokenChar(41), this.space()), this.print(N.body);
  }
  function O(N) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(N.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(N.cases, !0, void 0, function(ie, re) {
      if (!ie && N.cases[N.cases.length - 1] === re) return -1;
    }), this.rightBrace(N);
  }
  function ee(N) {
    N.test ? (this.word("case"), this.space(), this.print(N.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), N.consequent.length && (this.newline(), this.printSequence(N.consequent, !0));
  }
  function L() {
    this.word("debugger"), this.semicolon();
  }
  function q(N, F) {
    N.declare && (this.word("declare"), this.space());
    const {
      kind: ie
    } = N;
    ie === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(ie, ie === "using"), this.space();
    let re = !1;
    if (!u(F))
      for (const Q of N.declarations)
        Q.init && (re = !0);
    if (this.printList(N.declarations, void 0, void 0, N.declarations.length > 1, re ? function(Q) {
      this.token(",", !1, Q), this.newline();
    } : void 0), u(F)) {
      if (o(F)) {
        if (F.init === N) return;
      } else if (F.left === N) return;
    }
    this.semicolon();
  }
  function H(N) {
    this.print(N.id), N.definite && this.tokenChar(33), this.print(N.id.typeAnnotation), N.init && (this.space(), this.tokenChar(61), this.space(), this.print(N.init));
  }
  return yt;
}
var Ft = {}, Ac;
function td() {
  if (Ac) return Ft;
  Ac = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.ClassAccessorProperty = w, Ft.ClassBody = f, Ft.ClassExpression = Ft.ClassDeclaration = o, Ft.ClassMethod = A, Ft.ClassPrivateMethod = g, Ft.ClassPrivateProperty = x, Ft.ClassProperty = P, Ft.StaticBlock = v, Ft._classMethodHead = I;
  var i = Ze();
  const {
    isExportDefaultDeclaration: l,
    isExportNamedDeclaration: u
  } = i;
  function o(S, _) {
    (!(l(_) || u(_)) || !this._shouldPrintDecoratorsBeforeExport(_)) && this.printJoin(S.decorators), S.declare && (this.word("declare"), this.space()), S.abstract && (this.word("abstract"), this.space()), this.word("class"), S.id && (this.space(), this.print(S.id)), this.print(S.typeParameters), S.superClass && (this.space(), this.word("extends"), this.space(), this.print(S.superClass), this.print(S.superTypeParameters)), S.implements && (this.space(), this.word("implements"), this.space(), this.printList(S.implements)), this.space(), this.print(S.body);
  }
  function f(S) {
    if (this.tokenChar(123), S.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      const _ = p(this, S);
      _ == null || _(-1);
      const B = this.enterDelimited();
      this.printJoin(S.body, !0, !0, _, !0), B(), this.endsWith(10) || this.newline(), this.rightBrace(S);
    }
  }
  function p(S, _) {
    if (!S.tokenMap || _.start == null || _.end == null)
      return null;
    const B = S.tokenMap.getIndexes(_);
    if (!B) return null;
    let y = 1, X = 0, Z = 0;
    const J = () => {
      for (; Z < _.body.length && _.body[Z].start == null; )
        Z++;
    };
    return J(), (G) => {
      Z <= G && (Z = G + 1, J());
      const O = Z === _.body.length ? _.end : _.body[Z].start;
      let ee;
      for (; y < B.length && S.tokenMap.matchesOriginal(ee = S._tokens[B[y]], ";") && ee.start < O; )
        S.token(";", void 0, X++), y++;
    };
  }
  function P(S) {
    if (this.printJoin(S.decorators), !S.static && !this.format.preserveFormat) {
      var _;
      const B = (_ = S.key.loc) == null || (_ = _.end) == null ? void 0 : _.line;
      B && this.catchUp(B);
    }
    this.tsPrintClassMemberModifiers(S), S.computed ? (this.tokenChar(91), this.print(S.key), this.tokenChar(93)) : (this._variance(S), this.print(S.key)), S.optional && this.tokenChar(63), S.definite && this.tokenChar(33), this.print(S.typeAnnotation), S.value && (this.space(), this.tokenChar(61), this.space(), this.print(S.value)), this.semicolon();
  }
  function w(S) {
    var _;
    this.printJoin(S.decorators);
    const B = (_ = S.key.loc) == null || (_ = _.end) == null ? void 0 : _.line;
    B && this.catchUp(B), this.tsPrintClassMemberModifiers(S), this.word("accessor", !0), this.space(), S.computed ? (this.tokenChar(91), this.print(S.key), this.tokenChar(93)) : (this._variance(S), this.print(S.key)), S.optional && this.tokenChar(63), S.definite && this.tokenChar(33), this.print(S.typeAnnotation), S.value && (this.space(), this.tokenChar(61), this.space(), this.print(S.value)), this.semicolon();
  }
  function x(S) {
    this.printJoin(S.decorators), this.tsPrintClassMemberModifiers(S), this.print(S.key), S.optional && this.tokenChar(63), S.definite && this.tokenChar(33), this.print(S.typeAnnotation), S.value && (this.space(), this.tokenChar(61), this.space(), this.print(S.value)), this.semicolon();
  }
  function A(S) {
    this._classMethodHead(S), this.space(), this.print(S.body);
  }
  function g(S) {
    this._classMethodHead(S), this.space(), this.print(S.body);
  }
  function I(S) {
    if (this.printJoin(S.decorators), !this.format.preserveFormat) {
      var _;
      const B = (_ = S.key.loc) == null || (_ = _.end) == null ? void 0 : _.line;
      B && this.catchUp(B);
    }
    this.tsPrintClassMemberModifiers(S), this._methodHead(S);
  }
  function v(S) {
    this.word("static"), this.space(), this.tokenChar(123), S.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(S.body, !0), this.rightBrace(S));
  }
  return Ft;
}
var Rt = {}, Cc;
function rd() {
  if (Cc) return Rt;
  Cc = 1, Object.defineProperty(Rt, "__esModule", {
    value: !0
  }), Rt.ArrowFunctionExpression = g, Rt.FunctionDeclaration = Rt.FunctionExpression = A, Rt._functionHead = x, Rt._methodHead = P, Rt._param = p, Rt._parameters = f, Rt._params = o, Rt._predicate = w, Rt._shouldPrintArrowParamsParens = I;
  var i = Ze(), l = Zi();
  const {
    isIdentifier: u
  } = i;
  function o(S, _, B) {
    this.print(S.typeParameters);
    const y = v.call(this, _, B);
    y && this.sourceIdentifierName(y.name, y.pos), this.tokenChar(40), this._parameters(S.params, ")");
    const X = S.type === "ArrowFunctionExpression";
    this.print(S.returnType, X), this._noLineTerminator = X;
  }
  function f(S, _) {
    const B = this.enterDelimited(), y = this.shouldPrintTrailingComma(_), X = S.length;
    for (let Z = 0; Z < X; Z++)
      this._param(S[Z]), (y || Z < X - 1) && (this.token(",", null, Z), this.space());
    this.token(_), B();
  }
  function p(S) {
    this.printJoin(S.decorators), this.print(S), S.optional && this.tokenChar(63), this.print(S.typeAnnotation);
  }
  function P(S) {
    const _ = S.kind, B = S.key;
    (_ === "get" || _ === "set") && (this.word(_), this.space()), S.async && (this.word("async", !0), this.space()), (_ === "method" || _ === "init") && S.generator && this.tokenChar(42), S.computed ? (this.tokenChar(91), this.print(B), this.tokenChar(93)) : this.print(B), S.optional && this.tokenChar(63), this._params(S, S.computed && S.key.type !== "StringLiteral" ? void 0 : S.key, void 0);
  }
  function w(S, _) {
    S.predicate && (S.returnType || this.tokenChar(58), this.space(), this.print(S.predicate, _));
  }
  function x(S, _) {
    S.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), S.generator && (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), S.id && this.print(S.id), this._params(S, S.id, _), S.type !== "TSDeclareFunction" && this._predicate(S);
  }
  function A(S, _) {
    this._functionHead(S, _), this.space(), this.print(S.body);
  }
  function g(S, _) {
    S.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(S) ? this._params(S, void 0, _) : this.print(S.params[0], !0), this._predicate(S, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= l.TokenContext.arrowBody, this.print(S.body);
  }
  function I(S) {
    var _, B;
    if (S.params.length !== 1 || S.typeParameters || S.returnType || S.predicate)
      return !0;
    const y = S.params[0];
    if (!u(y) || y.typeAnnotation || y.optional || (_ = y.leadingComments) != null && _.length || (B = y.trailingComments) != null && B.length)
      return !0;
    if (this.tokenMap) {
      if (S.loc == null || this.tokenMap.findMatching(S, "(") !== null) return !0;
      const X = this.tokenMap.findMatching(S, "=>");
      return (X == null ? void 0 : X.loc) == null ? !0 : X.loc.start.line !== S.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  function v(S, _) {
    let B = S;
    if (!B && _) {
      const O = _.type;
      O === "VariableDeclarator" ? B = _.id : O === "AssignmentExpression" || O === "AssignmentPattern" ? B = _.left : O === "ObjectProperty" || O === "ClassProperty" ? (!_.computed || _.key.type === "StringLiteral") && (B = _.key) : (O === "ClassPrivateProperty" || O === "ClassAccessorProperty") && (B = _.key);
    }
    if (!B) return;
    let y;
    if (B.type === "Identifier") {
      var X, Z;
      y = {
        pos: (X = B.loc) == null ? void 0 : X.start,
        name: ((Z = B.loc) == null ? void 0 : Z.identifierName) || B.name
      };
    } else if (B.type === "PrivateName") {
      var J;
      y = {
        pos: (J = B.loc) == null ? void 0 : J.start,
        name: "#" + B.id.name
      };
    } else if (B.type === "StringLiteral") {
      var G;
      y = {
        pos: (G = B.loc) == null ? void 0 : G.start,
        name: B.value
      };
    }
    return y;
  }
  return Rt;
}
var Ct = {}, Ic;
function $p() {
  if (Ic) return Ct;
  Ic = 1, Object.defineProperty(Ct, "__esModule", {
    value: !0
  }), Ct.ExportAllDeclaration = B, Ct.ExportDefaultDeclaration = Z, Ct.ExportDefaultSpecifier = g, Ct.ExportNamedDeclaration = X, Ct.ExportNamespaceSpecifier = v, Ct.ExportSpecifier = I, Ct.ImportAttribute = G, Ct.ImportDeclaration = J, Ct.ImportDefaultSpecifier = A, Ct.ImportExpression = ee, Ct.ImportNamespaceSpecifier = O, Ct.ImportSpecifier = x, Ct._printAttributes = _;
  var i = Ze(), l = Zi();
  const {
    isClassDeclaration: u,
    isExportDefaultSpecifier: o,
    isExportNamespaceSpecifier: f,
    isImportDefaultSpecifier: p,
    isImportNamespaceSpecifier: P,
    isStatement: w
  } = i;
  function x(L) {
    (L.importKind === "type" || L.importKind === "typeof") && (this.word(L.importKind), this.space()), this.print(L.imported), L.local && L.local.name !== L.imported.name && (this.space(), this.word("as"), this.space(), this.print(L.local));
  }
  function A(L) {
    this.print(L.local);
  }
  function g(L) {
    this.print(L.exported);
  }
  function I(L) {
    L.exportKind === "type" && (this.word("type"), this.space()), this.print(L.local), L.exported && L.local.name !== L.exported.name && (this.space(), this.word("as"), this.space(), this.print(L.exported));
  }
  function v(L) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(L.exported);
  }
  let S = !1;
  function _(L, q) {
    const {
      importAttributesKeyword: H
    } = this.format, {
      attributes: N,
      assertions: F
    } = L;
    N && !H && !S && (S = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    const ie = H === "assert" || !H && F;
    if (this.word(ie ? "assert" : "with"), this.space(), !ie && H !== "with") {
      this.printList(N || F);
      return;
    }
    const re = q ? 1 : 0;
    this.token("{", null, re), this.space(), this.printList(N || F, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, re);
  }
  function B(L) {
    var q, H;
    this.word("export"), this.space(), L.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (q = L.attributes) != null && q.length || (H = L.assertions) != null && H.length ? (this.print(L.source, !0), this.space(), this._printAttributes(L, !1)) : this.print(L.source), this.semicolon();
  }
  function y(L, q) {
    u(q.declaration) && L._shouldPrintDecoratorsBeforeExport(q) && L.printJoin(q.declaration.decorators);
  }
  function X(L) {
    if (y(this, L), this.word("export"), this.space(), L.declaration) {
      const N = L.declaration;
      this.print(N), w(N) || this.semicolon();
    } else {
      L.exportKind === "type" && (this.word("type"), this.space());
      const N = L.specifiers.slice(0);
      let F = !1;
      for (; ; ) {
        const re = N[0];
        if (o(re) || f(re))
          F = !0, this.print(N.shift()), N.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let ie = !1;
      if ((N.length || !N.length && !F) && (ie = !0, this.tokenChar(123), N.length && (this.space(), this.printList(N, this.shouldPrintTrailingComma("}")), this.space()), this.tokenChar(125)), L.source) {
        var q, H;
        this.space(), this.word("from"), this.space(), (q = L.attributes) != null && q.length || (H = L.assertions) != null && H.length ? (this.print(L.source, !0), this.space(), this._printAttributes(L, ie)) : this.print(L.source);
      }
      this.semicolon();
    }
  }
  function Z(L) {
    y(this, L), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |= l.TokenContext.exportDefault;
    const q = L.declaration;
    this.print(q), w(q) || this.semicolon();
  }
  function J(L) {
    var q, H;
    this.word("import"), this.space();
    const N = L.importKind === "type" || L.importKind === "typeof";
    N ? (this.noIndentInnerCommentsHere(), this.word(L.importKind), this.space()) : L.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : L.phase && (this.noIndentInnerCommentsHere(), this.word(L.phase), this.space());
    const F = L.specifiers.slice(0), ie = !!F.length;
    for (; ie; ) {
      const Q = F[0];
      if (p(Q) || P(Q))
        this.print(F.shift()), F.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let re = !1;
    F.length ? (re = !0, this.tokenChar(123), this.space(), this.printList(F, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(125)) : N && !ie && (re = !0, this.tokenChar(123), this.tokenChar(125)), (ie || N) && (this.space(), this.word("from"), this.space()), (q = L.attributes) != null && q.length || (H = L.assertions) != null && H.length ? (this.print(L.source, !0), this.space(), this._printAttributes(L, re)) : this.print(L.source), this.semicolon();
  }
  function G(L) {
    this.print(L.key), this.tokenChar(58), this.space(), this.print(L.value);
  }
  function O(L) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(L.local);
  }
  function ee(L) {
    this.word("import"), L.phase && (this.tokenChar(46), this.word(L.phase)), this.tokenChar(40), this.print(L.source), L.options != null && (this.tokenChar(44), this.space(), this.print(L.options)), this.tokenChar(41);
  }
  return Ct;
}
var ht = {}, Zo, wc;
function id() {
  if (wc) return Zo;
  wc = 1;
  const i = {}, l = i.hasOwnProperty, u = (q, H) => {
    for (const N in q)
      l.call(q, N) && H(N, q[N]);
  }, o = (q, H) => (H && u(H, (N, F) => {
    q[N] = F;
  }), q), f = (q, H) => {
    const N = q.length;
    let F = -1;
    for (; ++F < N; )
      H(q[F]);
  }, p = (q) => "\\u" + ("0000" + q).slice(-4), P = (q, H) => {
    let N = q.toString(16);
    return H ? N : N.toUpperCase();
  }, w = i.toString, x = Array.isArray, A = (q) => typeof Buffer == "function" && Buffer.isBuffer(q), g = (q) => w.call(q) == "[object Object]", I = (q) => typeof q == "string" || w.call(q) == "[object String]", v = (q) => typeof q == "number" || w.call(q) == "[object Number]", S = (q) => typeof q == "bigint", _ = (q) => typeof q == "function", B = (q) => w.call(q) == "[object Map]", y = (q) => w.call(q) == "[object Set]", X = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, Z = /[\\\b\f\n\r\t]/, J = /[0-9]/, G = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, O = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, ee = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, L = (q, H) => {
    const N = () => {
      R = ne, ++H.indentLevel, ne = H.indent.repeat(H.indentLevel);
    }, F = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, ie = H && H.json;
    ie && (F.quotes = "double", F.wrap = !0), H = o(F, H), H.quotes != "single" && H.quotes != "double" && H.quotes != "backtick" && (H.quotes = "single");
    const re = H.quotes == "double" ? '"' : H.quotes == "backtick" ? "`" : "'", Q = H.compact, pe = H.lowercaseHex;
    let ne = H.indent.repeat(H.indentLevel), R = "";
    const C = H.__inline1__, z = H.__inline2__, ae = Q ? "" : `
`;
    let ce, ye = !0;
    const he = H.numbers == "binary", Pe = H.numbers == "octal", Ne = H.numbers == "decimal", we = H.numbers == "hexadecimal";
    if (ie && q && _(q.toJSON) && (q = q.toJSON()), !I(q)) {
      if (B(q))
        return q.size == 0 ? "new Map()" : (Q || (H.__inline1__ = !0, H.__inline2__ = !1), "new Map(" + L(Array.from(q), H) + ")");
      if (y(q))
        return q.size == 0 ? "new Set()" : "new Set(" + L(Array.from(q), H) + ")";
      if (A(q))
        return q.length == 0 ? "Buffer.from([])" : "Buffer.from(" + L(Array.from(q), H) + ")";
      if (x(q))
        return ce = [], H.wrap = !0, C && (H.__inline1__ = !1, H.__inline2__ = !0), z || N(), f(q, (Le) => {
          ye = !1, z && (H.__inline2__ = !1), ce.push(
            (Q || z ? "" : ne) + L(Le, H)
          );
        }), ye ? "[]" : z ? "[" + ce.join(", ") + "]" : "[" + ae + ce.join("," + ae) + ae + (Q ? "" : R) + "]";
      if (v(q) || S(q)) {
        if (ie)
          return JSON.stringify(Number(q));
        let Le;
        if (Ne)
          Le = String(q);
        else if (we) {
          let fe = q.toString(16);
          pe || (fe = fe.toUpperCase()), Le = "0x" + fe;
        } else he ? Le = "0b" + q.toString(2) : Pe && (Le = "0o" + q.toString(8));
        return S(q) ? Le + "n" : Le;
      } else return S(q) ? ie ? JSON.stringify(Number(q)) : q + "n" : g(q) ? (ce = [], H.wrap = !0, N(), u(q, (Le, fe) => {
        ye = !1, ce.push(
          (Q ? "" : ne) + L(Le, H) + ":" + (Q ? "" : " ") + L(fe, H)
        );
      }), ye ? "{}" : "{" + ae + ce.join("," + ae) + ae + (Q ? "" : R) + "}") : ie ? JSON.stringify(q) || "null" : String(q);
    }
    const Ie = H.escapeEverything ? O : ee;
    return ce = q.replace(Ie, (Le, fe, Te, de, Ue, Je) => {
      if (fe) {
        if (H.minimal) return fe;
        const st = fe.charCodeAt(0), qe = fe.charCodeAt(1);
        if (H.es6) {
          const Ge = (st - 55296) * 1024 + qe - 56320 + 65536;
          return "\\u{" + P(Ge, pe) + "}";
        }
        return p(P(st, pe)) + p(P(qe, pe));
      }
      if (Te)
        return p(P(Te.charCodeAt(0), pe));
      if (Le == "\0" && !ie && !J.test(Je.charAt(Ue + 1)))
        return "\\0";
      if (de)
        return de == re || H.escapeEverything ? "\\" + de : de;
      if (Z.test(Le))
        return X[Le];
      if (H.minimal && !G.test(Le))
        return Le;
      const He = P(Le.charCodeAt(0), pe);
      return ie || He.length > 2 ? p(He) : "\\x" + ("00" + He).slice(-2);
    }), re == "`" && (ce = ce.replace(/\$\{/g, "\\${")), H.isScriptContext && (ce = ce.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, ie ? "\\u003C!--" : "\\x3C!--")), H.wrap && (ce = re + ce + re), ce;
  };
  return L.version = "3.0.2", Zo = L, Zo;
}
var Oc;
function Jp() {
  if (Oc) return ht;
  Oc = 1, Object.defineProperty(ht, "__esModule", {
    value: !0
  }), ht.ArgumentPlaceholder = x, ht.ArrayPattern = ht.ArrayExpression = S, ht.BigIntLiteral = O, ht.BooleanLiteral = X, ht.Identifier = w, ht.NullLiteral = Z, ht.NumericLiteral = J, ht.ObjectPattern = ht.ObjectExpression = g, ht.ObjectMethod = I, ht.ObjectProperty = v, ht.PipelineBareFunction = H, ht.PipelinePrimaryTopicReference = N, ht.PipelineTopicExpression = q, ht.RecordExpression = _, ht.RegExpLiteral = y, ht.SpreadElement = ht.RestElement = A, ht.StringLiteral = G, ht.TopicReference = L, ht.TupleExpression = B, ht._getRawIdentifier = P;
  var i = Ze(), l = id();
  const {
    isAssignmentPattern: u,
    isIdentifier: o
  } = i;
  let f = null, p = "";
  function P(F) {
    if (F === f) return p;
    f = F;
    const {
      name: ie
    } = F, re = this.tokenMap.find(F, (Q) => Q.value === ie);
    return re ? (p = this._originalCode.slice(re.start, re.end), p) : p = F.name;
  }
  function w(F) {
    var ie;
    this.sourceIdentifierName(((ie = F.loc) == null ? void 0 : ie.identifierName) || F.name), this.word(this.tokenMap ? this._getRawIdentifier(F) : F.name);
  }
  function x() {
    this.tokenChar(63);
  }
  function A(F) {
    this.token("..."), this.print(F.argument);
  }
  function g(F) {
    const ie = F.properties;
    if (this.tokenChar(123), ie.length) {
      const re = this.enterDelimited();
      this.space(), this.printList(ie, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), re();
    }
    this.sourceWithOffset("end", F.loc, -1), this.tokenChar(125);
  }
  function I(F) {
    this.printJoin(F.decorators), this._methodHead(F), this.space(), this.print(F.body);
  }
  function v(F) {
    if (this.printJoin(F.decorators), F.computed)
      this.tokenChar(91), this.print(F.key), this.tokenChar(93);
    else {
      if (u(F.value) && o(F.key) && F.key.name === F.value.left.name) {
        this.print(F.value);
        return;
      }
      if (this.print(F.key), F.shorthand && o(F.key) && o(F.value) && F.key.name === F.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(F.value);
  }
  function S(F) {
    const ie = F.elements, re = ie.length;
    this.tokenChar(91);
    const Q = this.enterDelimited();
    for (let pe = 0; pe < ie.length; pe++) {
      const ne = ie[pe];
      ne ? (pe > 0 && this.space(), this.print(ne), (pe < re - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, pe)) : this.token(",", !1, pe);
    }
    Q(), this.tokenChar(93);
  }
  function _(F) {
    const ie = F.properties;
    let re, Q;
    if (this.format.recordAndTupleSyntaxType === "bar")
      re = "{|", Q = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      re = "#{", Q = "}";
    }
    this.token(re), ie.length && (this.space(), this.printList(ie, this.shouldPrintTrailingComma(Q), !0, !0), this.space()), this.token(Q);
  }
  function B(F) {
    const ie = F.elements, re = ie.length;
    let Q, pe;
    if (this.format.recordAndTupleSyntaxType === "bar")
      Q = "[|", pe = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      Q = "#[", pe = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(Q);
    for (let ne = 0; ne < ie.length; ne++) {
      const R = ie[ne];
      R && (ne > 0 && this.space(), this.print(R), (ne < re - 1 || this.shouldPrintTrailingComma(pe)) && this.token(",", !1, ne));
    }
    this.token(pe);
  }
  function y(F) {
    this.word(`/${F.pattern}/${F.flags}`);
  }
  function X(F) {
    this.word(F.value ? "true" : "false");
  }
  function Z() {
    this.word("null");
  }
  function J(F) {
    const ie = this.getPossibleRaw(F), re = this.format.jsescOption, Q = F.value, pe = Q + "";
    re.numbers ? this.number(l(Q, re), Q) : ie == null ? this.number(pe, Q) : this.format.minified ? this.number(ie.length < pe.length ? ie : pe, Q) : this.number(ie, Q);
  }
  function G(F) {
    const ie = this.getPossibleRaw(F);
    if (!this.format.minified && ie !== void 0) {
      this.token(ie);
      return;
    }
    const re = l(F.value, this.format.jsescOption);
    this.token(re);
  }
  function O(F) {
    const ie = this.getPossibleRaw(F);
    if (!this.format.minified && ie !== void 0) {
      this.word(ie);
      return;
    }
    this.word(F.value + "n");
  }
  const ee = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function L() {
    const {
      topicToken: F
    } = this.format;
    if (ee.has(F))
      this.token(F);
    else {
      const ie = JSON.stringify(F), re = Array.from(ee, (Q) => JSON.stringify(Q));
      throw new Error(`The "topicToken" generator option must be one of ${re.join(", ")} (${ie} received instead).`);
    }
  }
  function q(F) {
    this.print(F.expression);
  }
  function H(F) {
    this.print(F.callee);
  }
  function N() {
    this.tokenChar(35);
  }
  return ht;
}
var el = {}, Nc;
function nd() {
  return Nc || (Nc = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), i.AnyTypeAnnotation = w, i.ArrayTypeAnnotation = x, i.BooleanLiteralTypeAnnotation = g, i.BooleanTypeAnnotation = A, i.DeclareClass = v, i.DeclareExportAllDeclaration = L, i.DeclareExportDeclaration = ee, i.DeclareFunction = S, i.DeclareInterface = y, i.DeclareModule = X, i.DeclareModuleExports = Z, i.DeclareOpaqueType = G, i.DeclareTypeAlias = J, i.DeclareVariable = O, i.DeclaredPredicate = B, i.EmptyTypeAnnotation = Ue, i.EnumBooleanBody = F, i.EnumBooleanMember = R, i.EnumDeclaration = q, i.EnumDefaultedMember = pe, i.EnumNumberBody = ie, i.EnumNumberMember = C, i.EnumStringBody = re, i.EnumStringMember = z, i.EnumSymbolBody = Q, i.ExistsTypeAnnotation = ce, i.FunctionTypeAnnotation = ye, i.FunctionTypeParam = he, i.IndexedAccessType = et, i.InferredPredicate = _, i.InterfaceDeclaration = Ie, i.GenericTypeAnnotation = i.ClassImplements = i.InterfaceExtends = Pe, i.InterfaceTypeAnnotation = fe, i.IntersectionTypeAnnotation = Te, i.MixedTypeAnnotation = de, i.NullLiteralTypeAnnotation = I, i.NullableTypeAnnotation = Je, Object.defineProperty(i, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return f.NumericLiteral;
      }
    }), i.NumberTypeAnnotation = He, i.ObjectTypeAnnotation = ve, i.ObjectTypeCallProperty = D, i.ObjectTypeIndexer = V, i.ObjectTypeInternalSlot = j, i.ObjectTypeProperty = le, i.ObjectTypeSpreadProperty = me, i.OpaqueType = be, i.OptionalIndexedAccessType = oe, i.QualifiedTypeIdentifier = ge, Object.defineProperty(i, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return f.StringLiteral;
      }
    }), i.StringTypeAnnotation = st, i.SymbolTypeAnnotation = xe, i.ThisTypeAnnotation = qe, i.TupleTypeAnnotation = Ge, i.TypeAlias = it, i.TypeAnnotation = ft, i.TypeCastExpression = Ce, i.TypeParameter = Tt, i.TypeParameterDeclaration = i.TypeParameterInstantiation = Xe, i.TypeofTypeAnnotation = at, i.UnionTypeAnnotation = We, i.Variance = Ye, i.VoidTypeAnnotation = $e, i._interfaceish = Ne, i._variance = we;
    var l = Ze(), u = $p(), o = Zi(), f = Jp();
    const {
      isDeclareExportDeclaration: p,
      isStatement: P
    } = l;
    function w() {
      this.word("any");
    }
    function x(K) {
      this.print(K.elementType, !0), this.tokenChar(91), this.tokenChar(93);
    }
    function A() {
      this.word("boolean");
    }
    function g(K) {
      this.word(K.value ? "true" : "false");
    }
    function I() {
      this.word("null");
    }
    function v(K, Ae) {
      p(Ae) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(K);
    }
    function S(K, Ae) {
      p(Ae) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(K.id), this.print(K.id.typeAnnotation.typeAnnotation), K.predicate && (this.space(), this.print(K.predicate)), this.semicolon();
    }
    function _() {
      this.tokenChar(37), this.word("checks");
    }
    function B(K) {
      this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(K.value), this.tokenChar(41);
    }
    function y(K) {
      this.word("declare"), this.space(), this.InterfaceDeclaration(K);
    }
    function X(K) {
      this.word("declare"), this.space(), this.word("module"), this.space(), this.print(K.id), this.space(), this.print(K.body);
    }
    function Z(K) {
      this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(K.typeAnnotation);
    }
    function J(K) {
      this.word("declare"), this.space(), this.TypeAlias(K);
    }
    function G(K, Ae) {
      p(Ae) || (this.word("declare"), this.space()), this.OpaqueType(K);
    }
    function O(K, Ae) {
      p(Ae) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(K.id), this.print(K.id.typeAnnotation), this.semicolon();
    }
    function ee(K) {
      this.word("declare"), this.space(), this.word("export"), this.space(), K.default && (this.word("default"), this.space()), ae.call(this, K);
    }
    function L(K) {
      this.word("declare"), this.space(), u.ExportAllDeclaration.call(this, K);
    }
    function q(K) {
      const {
        id: Ae,
        body: Be
      } = K;
      this.word("enum"), this.space(), this.print(Ae), this.print(Be);
    }
    function H(K, Ae, Be) {
      Be && (K.space(), K.word("of"), K.space(), K.word(Ae)), K.space();
    }
    function N(K, Ae) {
      const {
        members: Be
      } = Ae;
      K.token("{"), K.indent(), K.newline();
      for (const Ke of Be)
        K.print(Ke), K.newline();
      Ae.hasUnknownMembers && (K.token("..."), K.newline()), K.dedent(), K.token("}");
    }
    function F(K) {
      const {
        explicitType: Ae
      } = K;
      H(this, "boolean", Ae), N(this, K);
    }
    function ie(K) {
      const {
        explicitType: Ae
      } = K;
      H(this, "number", Ae), N(this, K);
    }
    function re(K) {
      const {
        explicitType: Ae
      } = K;
      H(this, "string", Ae), N(this, K);
    }
    function Q(K) {
      H(this, "symbol", !0), N(this, K);
    }
    function pe(K) {
      const {
        id: Ae
      } = K;
      this.print(Ae), this.tokenChar(44);
    }
    function ne(K, Ae) {
      K.print(Ae.id), K.space(), K.token("="), K.space(), K.print(Ae.init), K.token(",");
    }
    function R(K) {
      ne(this, K);
    }
    function C(K) {
      ne(this, K);
    }
    function z(K) {
      ne(this, K);
    }
    function ae(K) {
      if (K.declaration) {
        const Ae = K.declaration;
        this.print(Ae), P(Ae) || this.semicolon();
      } else
        this.tokenChar(123), K.specifiers.length && (this.space(), this.printList(K.specifiers), this.space()), this.tokenChar(125), K.source && (this.space(), this.word("from"), this.space(), this.print(K.source)), this.semicolon();
    }
    function ce() {
      this.tokenChar(42);
    }
    function ye(K, Ae) {
      this.print(K.typeParameters), this.tokenChar(40), K.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(K.this.typeAnnotation), (K.params.length || K.rest) && (this.tokenChar(44), this.space())), this.printList(K.params), K.rest && (K.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(K.rest)), this.tokenChar(41);
      const Be = Ae == null ? void 0 : Ae.type;
      Be != null && (Be === "ObjectTypeCallProperty" || Be === "ObjectTypeInternalSlot" || Be === "DeclareFunction" || Be === "ObjectTypeProperty" && Ae.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(K.returnType);
    }
    function he(K) {
      this.print(K.name), K.optional && this.tokenChar(63), K.name && (this.tokenChar(58), this.space()), this.print(K.typeAnnotation);
    }
    function Pe(K) {
      this.print(K.id), this.print(K.typeParameters, !0);
    }
    function Ne(K) {
      var Ae;
      if (this.print(K.id), this.print(K.typeParameters), (Ae = K.extends) != null && Ae.length && (this.space(), this.word("extends"), this.space(), this.printList(K.extends)), K.type === "DeclareClass") {
        var Be, Ke;
        (Be = K.mixins) != null && Be.length && (this.space(), this.word("mixins"), this.space(), this.printList(K.mixins)), (Ke = K.implements) != null && Ke.length && (this.space(), this.word("implements"), this.space(), this.printList(K.implements));
      }
      this.space(), this.print(K.body);
    }
    function we(K) {
      var Ae;
      const Be = (Ae = K.variance) == null ? void 0 : Ae.kind;
      Be != null && (Be === "plus" ? this.tokenChar(43) : Be === "minus" && this.tokenChar(45));
    }
    function Ie(K) {
      this.word("interface"), this.space(), this._interfaceish(K);
    }
    function Le(K) {
      this.space(), this.token("&", !1, K), this.space();
    }
    function fe(K) {
      var Ae;
      this.word("interface"), (Ae = K.extends) != null && Ae.length && (this.space(), this.word("extends"), this.space(), this.printList(K.extends)), this.space(), this.print(K.body);
    }
    function Te(K) {
      this.printJoin(K.types, void 0, void 0, Le);
    }
    function de() {
      this.word("mixed");
    }
    function Ue() {
      this.word("empty");
    }
    function Je(K) {
      this.tokenChar(63), this.print(K.typeAnnotation);
    }
    function He() {
      this.word("number");
    }
    function st() {
      this.word("string");
    }
    function qe() {
      this.word("this");
    }
    function Ge(K) {
      this.tokenChar(91), this.printList(K.types), this.tokenChar(93);
    }
    function at(K) {
      this.word("typeof"), this.space(), this.print(K.argument);
    }
    function it(K) {
      this.word("type"), this.space(), this.print(K.id), this.print(K.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(K.right), this.semicolon();
    }
    function ft(K, Ae) {
      this.tokenChar(58), this.space(), Ae.type === "ArrowFunctionExpression" ? this.tokenContext |= o.TokenContext.arrowFlowReturnType : K.optional && this.tokenChar(63), this.print(K.typeAnnotation);
    }
    function Xe(K) {
      this.tokenChar(60), this.printList(K.params), this.tokenChar(62);
    }
    function Tt(K) {
      this._variance(K), this.word(K.name), K.bound && this.print(K.bound), K.default && (this.space(), this.tokenChar(61), this.space(), this.print(K.default));
    }
    function be(K) {
      this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(K.id), this.print(K.typeParameters), K.supertype && (this.tokenChar(58), this.space(), this.print(K.supertype)), K.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(K.impltype)), this.semicolon();
    }
    function ve(K) {
      K.exact ? this.token("{|") : this.tokenChar(123);
      const Ae = [...K.properties, ...K.callProperties || [], ...K.indexers || [], ...K.internalSlots || []];
      Ae.length && (this.newline(), this.space(), this.printJoin(Ae, !0, !0, void 0, void 0, function(Ke) {
        if (Ke && !Ae[0]) return 1;
      }, () => {
        (Ae.length !== 1 || K.inexact) && (this.tokenChar(44), this.space());
      }), this.space()), K.inexact && (this.indent(), this.token("..."), Ae.length && this.newline(), this.dedent()), K.exact ? this.token("|}") : this.tokenChar(125);
    }
    function j(K) {
      K.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(K.id), this.tokenChar(93), this.tokenChar(93), K.optional && this.tokenChar(63), K.method || (this.tokenChar(58), this.space()), this.print(K.value);
    }
    function D(K) {
      K.static && (this.word("static"), this.space()), this.print(K.value);
    }
    function V(K) {
      K.static && (this.word("static"), this.space()), this._variance(K), this.tokenChar(91), K.id && (this.print(K.id), this.tokenChar(58), this.space()), this.print(K.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(K.value);
    }
    function le(K) {
      K.proto && (this.word("proto"), this.space()), K.static && (this.word("static"), this.space()), (K.kind === "get" || K.kind === "set") && (this.word(K.kind), this.space()), this._variance(K), this.print(K.key), K.optional && this.tokenChar(63), K.method || (this.tokenChar(58), this.space()), this.print(K.value);
    }
    function me(K) {
      this.token("..."), this.print(K.argument);
    }
    function ge(K) {
      this.print(K.qualification), this.tokenChar(46), this.print(K.id);
    }
    function xe() {
      this.word("symbol");
    }
    function De(K) {
      this.space(), this.token("|", !1, K), this.space();
    }
    function We(K) {
      this.printJoin(K.types, void 0, void 0, De);
    }
    function Ce(K) {
      this.tokenChar(40), this.print(K.expression), this.print(K.typeAnnotation), this.tokenChar(41);
    }
    function Ye(K) {
      K.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
    }
    function $e() {
      this.word("void");
    }
    function et(K) {
      this.print(K.objectType, !0), this.tokenChar(91), this.print(K.indexType), this.tokenChar(93);
    }
    function oe(K) {
      this.print(K.objectType), K.optional && this.token("?."), this.tokenChar(91), this.print(K.indexType), this.tokenChar(93);
    }
  }(el)), el;
}
var pr = {}, _c;
function sd() {
  if (_c) return pr;
  _c = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.BlockStatement = u, pr.Directive = o, pr.DirectiveLiteral = P, pr.File = i, pr.InterpreterDirective = w, pr.Placeholder = x, pr.Program = l;
  function i(A) {
    A.program && this.print(A.program.interpreter), this.print(A.program);
  }
  function l(A) {
    var g;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    const I = (g = A.directives) == null ? void 0 : g.length;
    if (I) {
      var v;
      const S = A.body.length ? 2 : 1;
      this.printSequence(A.directives, void 0, S), (v = A.directives[I - 1].trailingComments) != null && v.length || this.newline(S);
    }
    this.printSequence(A.body);
  }
  function u(A) {
    var g;
    this.tokenChar(123);
    const I = this.enterDelimited(), v = (g = A.directives) == null ? void 0 : g.length;
    if (v) {
      var S;
      const _ = A.body.length ? 2 : 1;
      this.printSequence(A.directives, !0, _), (S = A.directives[v - 1].trailingComments) != null && S.length || this.newline(_);
    }
    this.printSequence(A.body, !0), I(), this.rightBrace(A);
  }
  function o(A) {
    this.print(A.value), this.semicolon();
  }
  const f = /(?:^|[^\\])(?:\\\\)*'/, p = /(?:^|[^\\])(?:\\\\)*"/;
  function P(A) {
    const g = this.getPossibleRaw(A);
    if (!this.format.minified && g !== void 0) {
      this.token(g);
      return;
    }
    const {
      value: I
    } = A;
    if (!p.test(I))
      this.token(`"${I}"`);
    else if (!f.test(I))
      this.token(`'${I}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  function w(A) {
    this.token(`#!${A.value}`), this.newline(1, !0);
  }
  function x(A) {
    this.token("%%"), this.print(A.name), this.token("%%"), A.expectedNode === "Statement" && this.semicolon();
  }
  return pr;
}
var Et = {}, Dc;
function ad() {
  if (Dc) return Et;
  Dc = 1, Object.defineProperty(Et, "__esModule", {
    value: !0
  }), Et.JSXAttribute = i, Et.JSXClosingElement = I, Et.JSXClosingFragment = B, Et.JSXElement = x, Et.JSXEmptyExpression = v, Et.JSXExpressionContainer = p, Et.JSXFragment = S, Et.JSXIdentifier = l, Et.JSXMemberExpression = o, Et.JSXNamespacedName = u, Et.JSXOpeningElement = g, Et.JSXOpeningFragment = _, Et.JSXSpreadAttribute = f, Et.JSXSpreadChild = P, Et.JSXText = w;
  function i(y) {
    this.print(y.name), y.value && (this.tokenChar(61), this.print(y.value));
  }
  function l(y) {
    this.word(y.name);
  }
  function u(y) {
    this.print(y.namespace), this.tokenChar(58), this.print(y.name);
  }
  function o(y) {
    this.print(y.object), this.tokenChar(46), this.print(y.property);
  }
  function f(y) {
    this.tokenChar(123), this.token("..."), this.print(y.argument), this.rightBrace(y);
  }
  function p(y) {
    this.tokenChar(123), this.print(y.expression), this.rightBrace(y);
  }
  function P(y) {
    this.tokenChar(123), this.token("..."), this.print(y.expression), this.rightBrace(y);
  }
  function w(y) {
    const X = this.getPossibleRaw(y);
    X !== void 0 ? this.token(X, !0) : this.token(y.value, !0);
  }
  function x(y) {
    const X = y.openingElement;
    if (this.print(X), !X.selfClosing) {
      this.indent();
      for (const Z of y.children)
        this.print(Z);
      this.dedent(), this.print(y.closingElement);
    }
  }
  function A() {
    this.space();
  }
  function g(y) {
    this.tokenChar(60), this.print(y.name), y.typeArguments && this.print(y.typeArguments), this.print(y.typeParameters), y.attributes.length > 0 && (this.space(), this.printJoin(y.attributes, void 0, void 0, A)), y.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(62);
  }
  function I(y) {
    this.tokenChar(60), this.tokenChar(47), this.print(y.name), this.tokenChar(62);
  }
  function v() {
    this.printInnerComments();
  }
  function S(y) {
    this.print(y.openingFragment), this.indent();
    for (const X of y.children)
      this.print(X);
    this.dedent(), this.print(y.closingFragment);
  }
  function _() {
    this.tokenChar(60), this.tokenChar(62);
  }
  function B() {
    this.token("</"), this.tokenChar(62);
  }
  return Et;
}
var Me = {}, kc;
function od() {
  if (kc) return Me;
  kc = 1, Object.defineProperty(Me, "__esModule", {
    value: !0
  }), Me.TSAnyKeyword = _, Me.TSArrayType = z, Me.TSSatisfiesExpression = Me.TSAsExpression = ft, Me.TSBigIntKeyword = B, Me.TSBooleanKeyword = J, Me.TSCallSignatureDeclaration = w, Me.TSInterfaceHeritage = Me.TSClassImplements = qe, Me.TSConditionalType = Ie, Me.TSConstructSignatureDeclaration = A, Me.TSConstructorType = re, Me.TSDeclareFunction = f, Me.TSDeclareMethod = p, Me.TSEnumBody = ve, Me.TSEnumDeclaration = be, Me.TSEnumMember = j, Me.TSExportAssignment = De, Me.TSExternalModuleReference = ge, Me.TSFunctionType = ie, Me.TSImportEqualsDeclaration = me, Me.TSImportType = le, Me.TSIndexSignature = S, Me.TSIndexedAccessType = de, Me.TSInferType = Le, Me.TSInstantiationExpression = Tt, Me.TSInterfaceBody = at, Me.TSInterfaceDeclaration = Ge, Me.TSIntersectionType = Ne, Me.TSIntrinsicKeyword = N, Me.TSLiteralType = st, Me.TSMappedType = Ue, Me.TSMethodSignature = v, Me.TSModuleBlock = V, Me.TSModuleDeclaration = D, Me.TSNamedTupleMember = he, Me.TSNamespaceExportDeclaration = We, Me.TSNeverKeyword = H, Me.TSNonNullExpression = xe, Me.TSNullKeyword = q, Me.TSNumberKeyword = X, Me.TSObjectKeyword = Z, Me.TSOptionalType = ce, Me.TSParameterProperty = o, Me.TSParenthesizedType = fe, Me.TSPropertySignature = g, Me.TSQualifiedName = P, Me.TSRestType = ye, Me.TSStringKeyword = G, Me.TSSymbolKeyword = O, Me.TSTemplateLiteralType = He, Me.TSThisType = F, Me.TSTupleType = ae, Me.TSTypeAliasDeclaration = it, Me.TSTypeAnnotation = i, Me.TSTypeAssertion = Xe, Me.TSTypeLiteral = C, Me.TSTypeOperator = Te, Me.TSTypeParameter = u, Me.TSTypeParameterDeclaration = Me.TSTypeParameterInstantiation = l, Me.TSTypePredicate = ne, Me.TSTypeQuery = R, Me.TSTypeReference = pe, Me.TSUndefinedKeyword = L, Me.TSUnionType = Pe, Me.TSUnknownKeyword = y, Me.TSVoidKeyword = ee, Me.tsPrintClassMemberModifiers = Ye, Me.tsPrintFunctionOrConstructorType = Q, Me.tsPrintPropertyOrMethodName = I, Me.tsPrintSignatureDeclarationBase = Ce;
  function i(oe, K) {
    this.token((K.type === "TSFunctionType" || K.type === "TSConstructorType") && K.typeAnnotation === oe ? "=>" : ":"), this.space(), oe.optional && this.tokenChar(63), this.print(oe.typeAnnotation);
  }
  function l(oe, K) {
    this.tokenChar(60);
    let Ae = K.type === "ArrowFunctionExpression" && oe.params.length === 1;
    this.tokenMap && oe.start != null && oe.end != null && (Ae && (Ae = !!this.tokenMap.find(oe, (Be) => this.tokenMap.matchesOriginal(Be, ","))), Ae || (Ae = this.shouldPrintTrailingComma(">"))), this.printList(oe.params, Ae), this.tokenChar(62);
  }
  function u(oe) {
    oe.in && (this.word("in"), this.space()), oe.out && (this.word("out"), this.space()), this.word(oe.name), oe.constraint && (this.space(), this.word("extends"), this.space(), this.print(oe.constraint)), oe.default && (this.space(), this.tokenChar(61), this.space(), this.print(oe.default));
  }
  function o(oe) {
    oe.accessibility && (this.word(oe.accessibility), this.space()), oe.readonly && (this.word("readonly"), this.space()), this._param(oe.parameter);
  }
  function f(oe, K) {
    oe.declare && (this.word("declare"), this.space()), this._functionHead(oe, K), this.semicolon();
  }
  function p(oe) {
    this._classMethodHead(oe), this.semicolon();
  }
  function P(oe) {
    this.print(oe.left), this.tokenChar(46), this.print(oe.right);
  }
  function w(oe) {
    this.tsPrintSignatureDeclarationBase(oe), x(this, oe);
  }
  function x(oe, K) {
    if (!oe.tokenMap || !K.start || !K.end) {
      oe.semicolon();
      return;
    }
    oe.tokenMap.endMatches(K, ",") ? oe.token(",") : oe.tokenMap.endMatches(K, ";") && oe.semicolon();
  }
  function A(oe) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(oe), x(this, oe);
  }
  function g(oe) {
    const {
      readonly: K
    } = oe;
    K && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(oe), this.print(oe.typeAnnotation), x(this, oe);
  }
  function I(oe) {
    oe.computed && this.tokenChar(91), this.print(oe.key), oe.computed && this.tokenChar(93), oe.optional && this.tokenChar(63);
  }
  function v(oe) {
    const {
      kind: K
    } = oe;
    (K === "set" || K === "get") && (this.word(K), this.space()), this.tsPrintPropertyOrMethodName(oe), this.tsPrintSignatureDeclarationBase(oe), x(this, oe);
  }
  function S(oe) {
    const {
      readonly: K,
      static: Ae
    } = oe;
    Ae && (this.word("static"), this.space()), K && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(oe.parameters, "]"), this.print(oe.typeAnnotation), x(this, oe);
  }
  function _() {
    this.word("any");
  }
  function B() {
    this.word("bigint");
  }
  function y() {
    this.word("unknown");
  }
  function X() {
    this.word("number");
  }
  function Z() {
    this.word("object");
  }
  function J() {
    this.word("boolean");
  }
  function G() {
    this.word("string");
  }
  function O() {
    this.word("symbol");
  }
  function ee() {
    this.word("void");
  }
  function L() {
    this.word("undefined");
  }
  function q() {
    this.word("null");
  }
  function H() {
    this.word("never");
  }
  function N() {
    this.word("intrinsic");
  }
  function F() {
    this.word("this");
  }
  function ie(oe) {
    this.tsPrintFunctionOrConstructorType(oe);
  }
  function re(oe) {
    oe.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(oe);
  }
  function Q(oe) {
    const {
      typeParameters: K
    } = oe, Ae = oe.parameters;
    this.print(K), this.tokenChar(40), this._parameters(Ae, ")"), this.space();
    const Be = oe.typeAnnotation;
    this.print(Be);
  }
  function pe(oe) {
    const K = oe.typeParameters;
    this.print(oe.typeName, !!K), this.print(K);
  }
  function ne(oe) {
    oe.asserts && (this.word("asserts"), this.space()), this.print(oe.parameterName), oe.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(oe.typeAnnotation.typeAnnotation));
  }
  function R(oe) {
    this.word("typeof"), this.space(), this.print(oe.exprName);
    const K = oe.typeParameters;
    K && this.print(K);
  }
  function C(oe) {
    $e(this, oe, () => this.printJoin(oe.members, !0, !0));
  }
  function z(oe) {
    this.print(oe.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  function ae(oe) {
    this.tokenChar(91), this.printList(oe.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  function ce(oe) {
    this.print(oe.typeAnnotation), this.tokenChar(63);
  }
  function ye(oe) {
    this.token("..."), this.print(oe.typeAnnotation);
  }
  function he(oe) {
    this.print(oe.label), oe.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(oe.elementType);
  }
  function Pe(oe) {
    we(this, oe, "|");
  }
  function Ne(oe) {
    we(this, oe, "&");
  }
  function we(oe, K, Ae) {
    var Be;
    let Ke = 0;
    (Be = oe.tokenMap) != null && Be.startMatches(K, Ae) && (Ke = 1, oe.token(Ae)), oe.printJoin(K.types, void 0, void 0, function(ct) {
      this.space(), this.token(Ae, null, ct + Ke), this.space();
    });
  }
  function Ie(oe) {
    this.print(oe.checkType), this.space(), this.word("extends"), this.space(), this.print(oe.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(oe.trueType), this.space(), this.tokenChar(58), this.space(), this.print(oe.falseType);
  }
  function Le(oe) {
    this.word("infer"), this.print(oe.typeParameter);
  }
  function fe(oe) {
    this.tokenChar(40), this.print(oe.typeAnnotation), this.tokenChar(41);
  }
  function Te(oe) {
    this.word(oe.operator), this.space(), this.print(oe.typeAnnotation);
  }
  function de(oe) {
    this.print(oe.objectType, !0), this.tokenChar(91), this.print(oe.indexType), this.tokenChar(93);
  }
  function Ue(oe) {
    const {
      nameType: K,
      optional: Ae,
      readonly: Be,
      typeAnnotation: Ke
    } = oe;
    this.tokenChar(123);
    const ct = this.enterDelimited();
    this.space(), Be && (Je(this, Be), this.word("readonly"), this.space()), this.tokenChar(91), this.word(oe.typeParameter.name), this.space(), this.word("in"), this.space(), this.print(oe.typeParameter.constraint), K && (this.space(), this.word("as"), this.space(), this.print(K)), this.tokenChar(93), Ae && (Je(this, Ae), this.tokenChar(63)), Ke && (this.tokenChar(58), this.space(), this.print(Ke)), this.space(), ct(), this.tokenChar(125);
  }
  function Je(oe, K) {
    K !== !0 && oe.token(K);
  }
  function He(oe) {
    this._printTemplate(oe, oe.types);
  }
  function st(oe) {
    this.print(oe.literal);
  }
  function qe(oe) {
    this.print(oe.expression), this.print(oe.typeArguments);
  }
  function Ge(oe) {
    const {
      declare: K,
      id: Ae,
      typeParameters: Be,
      extends: Ke,
      body: ct
    } = oe;
    K && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(Ae), this.print(Be), Ke != null && Ke.length && (this.space(), this.word("extends"), this.space(), this.printList(Ke)), this.space(), this.print(ct);
  }
  function at(oe) {
    $e(this, oe, () => this.printJoin(oe.body, !0, !0));
  }
  function it(oe) {
    const {
      declare: K,
      id: Ae,
      typeParameters: Be,
      typeAnnotation: Ke
    } = oe;
    K && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(Ae), this.print(Be), this.space(), this.tokenChar(61), this.space(), this.print(Ke), this.semicolon();
  }
  function ft(oe) {
    const {
      type: K,
      expression: Ae,
      typeAnnotation: Be
    } = oe;
    this.print(Ae, !0), this.space(), this.word(K === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(Be);
  }
  function Xe(oe) {
    const {
      typeAnnotation: K,
      expression: Ae
    } = oe;
    this.tokenChar(60), this.print(K), this.tokenChar(62), this.space(), this.print(Ae);
  }
  function Tt(oe) {
    this.print(oe.expression), this.print(oe.typeParameters);
  }
  function be(oe) {
    const {
      declare: K,
      const: Ae,
      id: Be
    } = oe;
    K && (this.word("declare"), this.space()), Ae && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(Be), this.space(), ve.call(this, oe);
  }
  function ve(oe) {
    $e(this, oe, () => {
      var K;
      return this.printList(oe.members, (K = this.shouldPrintTrailingComma("}")) != null ? K : !0, !0, !0);
    });
  }
  function j(oe) {
    const {
      id: K,
      initializer: Ae
    } = oe;
    this.print(K), Ae && (this.space(), this.tokenChar(61), this.space(), this.print(Ae));
  }
  function D(oe) {
    const {
      declare: K,
      id: Ae,
      kind: Be
    } = oe;
    K && (this.word("declare"), this.space());
    {
      if (oe.global || (this.word(Be ?? (Ae.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(Ae), !oe.body) {
        this.semicolon();
        return;
      }
      let Ke = oe.body;
      for (; Ke.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(Ke.id), Ke = Ke.body;
      this.space(), this.print(Ke);
    }
  }
  function V(oe) {
    $e(this, oe, () => this.printSequence(oe.body, !0));
  }
  function le(oe) {
    const {
      argument: K,
      qualifier: Ae,
      options: Be
    } = oe;
    this.word("import"), this.tokenChar(40), this.print(K), Be && (this.tokenChar(44), this.print(Be)), this.tokenChar(41), Ae && (this.tokenChar(46), this.print(Ae));
    const Ke = oe.typeParameters;
    Ke && this.print(Ke);
  }
  function me(oe) {
    const {
      id: K,
      moduleReference: Ae
    } = oe;
    oe.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(K), this.space(), this.tokenChar(61), this.space(), this.print(Ae), this.semicolon();
  }
  function ge(oe) {
    this.token("require("), this.print(oe.expression), this.tokenChar(41);
  }
  function xe(oe) {
    this.print(oe.expression), this.tokenChar(33);
  }
  function De(oe) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(oe.expression), this.semicolon();
  }
  function We(oe) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(oe.id), this.semicolon();
  }
  function Ce(oe) {
    const {
      typeParameters: K
    } = oe, Ae = oe.parameters;
    this.print(K), this.tokenChar(40), this._parameters(Ae, ")");
    const Be = oe.typeAnnotation;
    this.print(Be);
  }
  function Ye(oe) {
    const K = oe.type === "ClassPrivateProperty", Ae = oe.type === "ClassAccessorProperty" || oe.type === "ClassProperty";
    et(this, oe, [Ae && oe.declare && "declare", !K && oe.accessibility]), oe.static && (this.word("static"), this.space()), et(this, oe, [!K && oe.override && "override", !K && oe.abstract && "abstract", (Ae || K) && oe.readonly && "readonly"]);
  }
  function $e(oe, K, Ae) {
    oe.token("{");
    const Be = oe.enterDelimited();
    Ae(), Be(), oe.rightBrace(K);
  }
  function et(oe, K, Ae) {
    var Be;
    const Ke = /* @__PURE__ */ new Set();
    for (const ct of Ae)
      ct && Ke.add(ct);
    (Be = oe.tokenMap) == null || Be.find(K, (ct) => {
      if (Ke.has(ct.value))
        return oe.token(ct.value), oe.space(), Ke.delete(ct.value), Ke.size === 0;
    });
    for (const ct of Ke)
      oe.word(ct), oe.space();
  }
  return Me;
}
var Lc;
function ld() {
  return Lc || (Lc = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    });
    var l = Qh();
    Object.keys(l).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === l[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return l[v];
        }
      });
    });
    var u = Zh();
    Object.keys(u).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === u[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return u[v];
        }
      });
    });
    var o = ed();
    Object.keys(o).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === o[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return o[v];
        }
      });
    });
    var f = td();
    Object.keys(f).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === f[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return f[v];
        }
      });
    });
    var p = rd();
    Object.keys(p).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === p[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return p[v];
        }
      });
    });
    var P = $p();
    Object.keys(P).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === P[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return P[v];
        }
      });
    });
    var w = Jp();
    Object.keys(w).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === w[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return w[v];
        }
      });
    });
    var x = nd();
    Object.keys(x).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === x[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return x[v];
        }
      });
    });
    var A = sd();
    Object.keys(A).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === A[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return A[v];
        }
      });
    });
    var g = ad();
    Object.keys(g).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === g[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return g[v];
        }
      });
    });
    var I = od();
    Object.keys(I).forEach(function(v) {
      v === "default" || v === "__esModule" || v in i && i[v] === I[v] || Object.defineProperty(i, v, {
        enumerable: !0,
        get: function() {
          return I[v];
        }
      });
    });
  }(Qo)), Qo;
}
var Wa = {}, Mc;
function ud() {
  if (Mc) return Wa;
  Mc = 1, Object.defineProperty(Wa, "__esModule", {
    value: !0
  }), Wa.addDeprecatedGenerators = i;
  function i(l) {
    {
      const u = {
        Noop() {
        },
        TSExpressionWithTypeArguments(o) {
          this.print(o.expression), this.print(o.typeParameters);
        },
        DecimalLiteral(o) {
          const f = this.getPossibleRaw(o);
          if (!this.format.minified && f !== void 0) {
            this.word(f);
            return;
          }
          this.word(o.value + "m");
        }
      };
      Object.assign(l.prototype, u);
    }
  }
  return Wa;
}
var Bc;
function cd() {
  if (Bc) return bs;
  Bc = 1, Object.defineProperty(bs, "__esModule", {
    value: !0
  }), bs.default = void 0;
  var i = Yh(), l = Zi(), u = Ze(), o = zh(), f = ld(), p = ud();
  const {
    isExpression: P,
    isFunction: w,
    isStatement: x,
    isClassBody: A,
    isTSInterfaceBody: g,
    isTSEnumMember: I
  } = u, v = /e/i, S = /\.0+$/, _ = /[\n\r\u2028\u2029]/, B = /[\n\r\u2028\u2029]|\*\//;
  function y(G) {
    return G.type === "CommentLine" || _.test(G.value);
  }
  const {
    needsParens: X
  } = l;
  class Z {
    constructor(O, ee, L, q) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier = this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = O, this._tokens = L, this._originalCode = q, this._indentRepeat = O.indent.style.length, this._inputMap = ee == null ? void 0 : ee._inputMap, this._buf = new i.default(ee, O.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      const O = this.inForStatementInit, ee = this._noLineTerminatorAfterNode;
      return O === !1 && ee === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = O, this._noLineTerminatorAfterNode = ee;
      });
    }
    generate(O) {
      return this.format.preserveFormat && (this.tokenMap = new o.TokenMap(O, this._tokens, this._originalCode)), this.print(O), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      const {
        format: O
      } = this;
      O.preserveFormat || O.compact || O.concise || this._indent++;
    }
    dedent() {
      const {
        format: O
      } = this;
      O.preserveFormat || O.compact || O.concise || this._indent--;
    }
    semicolon(O = !1) {
      if (this._maybeAddAuxComment(), O) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        const ee = this._currentNode;
        if (ee.start != null && ee.end != null) {
          if (!this.tokenMap.endMatches(ee, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          const L = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[L[L.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(O) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", O.loc, -1), this.tokenChar(125);
    }
    rightParens(O) {
      this.sourceWithOffset("end", O.loc, -1), this.tokenChar(41);
    }
    space(O = !1) {
      const {
        format: ee
      } = this;
      if (!(ee.compact || ee.preserveFormat)) {
        if (O)
          this._space();
        else if (this._buf.hasContent()) {
          const L = this.getLastChar();
          L !== 32 && L !== 10 && this._space();
        }
      }
    }
    word(O, ee = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(O), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(O), (this._endsWithWord || this._endsWithDiv && O.charCodeAt(0) === 47) && this._space(), this._append(O, !1), this._endsWithWord = !0, this._noLineTerminator = ee;
    }
    number(O, ee) {
      function L(q) {
        if (q.length > 2 && q.charCodeAt(0) === 48) {
          const H = q.charCodeAt(1);
          return H === 98 || H === 111 || H === 120;
        }
        return !1;
      }
      this.word(O), this._endsWithInteger = Number.isInteger(ee) && !L(O) && !v.test(O) && !S.test(O) && O.charCodeAt(O.length - 1) !== 46;
    }
    token(O, ee = !1, L = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(O, L), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(O, L);
      const q = this.getLastChar(), H = O.charCodeAt(0);
      (q === 33 && (O === "--" || H === 61) || H === 43 && q === 43 || H === 45 && q === 45 || H === 46 && this._endsWithInteger) && this._space(), this._append(O, ee), this._noLineTerminator = !1;
    }
    tokenChar(O) {
      this.tokenContext = 0;
      const ee = String.fromCharCode(O);
      this._maybePrintInnerComments(ee), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(ee);
      const L = this.getLastChar();
      (O === 43 && L === 43 || O === 45 && L === 45 || O === 46 && this._endsWithInteger) && this._space(), this._appendChar(O), this._noLineTerminator = !1;
    }
    newline(O = 1, ee) {
      if (!(O <= 0)) {
        if (!ee) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        O > 2 && (O = 2), O -= this._buf.getNewlineCount();
        for (let L = 0; L < O; L++)
          this._newline();
      }
    }
    endsWith(O) {
      return this.getLastChar() === O;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(O, ee) {
      if (!O) {
        ee();
        return;
      }
      this._catchUp("start", O), this._buf.exactSource(O, ee);
    }
    source(O, ee) {
      ee && (this._catchUp(O, ee), this._buf.source(O, ee));
    }
    sourceWithOffset(O, ee, L) {
      !ee || this.format.preserveFormat || (this._catchUp(O, ee), this._buf.sourceWithOffset(O, ee, L));
    }
    sourceIdentifierName(O, ee) {
      if (!this._buf._canMarkIdName) return;
      const L = this._buf._sourcePosition;
      L.identifierNamePos = ee, L.identifierName = O;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(O, ee = 0) {
      const L = this.tokenMap.findMatching(this._currentNode, O, ee);
      L && this._catchUpTo(L.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() && (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(O, ee) {
      this._maybeIndent(O.charCodeAt(0)), this._buf.append(O, ee), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(O) {
      this._maybeIndent(O), this._buf.appendChar(O), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(O) {
      this._maybeIndent(O), this._buf.queue(O), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(O) {
      this._indent && O !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(O) {
      if (this._indent && O !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(O) {
      if (!this.format.retainLines) return;
      const ee = O - this._buf.getCurrentLine();
      for (let L = 0; L < ee; L++)
        this._newline();
    }
    _catchUp(O, ee) {
      const {
        format: L
      } = this;
      if (!L.preserveFormat) {
        L.retainLines && ee != null && ee[O] && this.catchUp(ee[O].line);
        return;
      }
      const q = ee == null ? void 0 : ee[O];
      q != null && this._catchUpTo(q);
    }
    _catchUpTo({
      line: O,
      column: ee,
      index: L
    }) {
      const q = O - this._buf.getCurrentLine();
      if (q > 0 && this._noLineTerminator)
        return;
      for (let N = 0; N < q; N++)
        this._newline();
      const H = q > 0 ? ee : ee - this._buf.getCurrentColumn();
      if (H > 0) {
        const N = this._originalCode ? this._originalCode.slice(L - H, L).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(H);
        this._append(N, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(O) {
      this._noLineTerminator = !0, this.print(O);
    }
    print(O, ee, L) {
      var q, H, N;
      if (!O) return;
      this._endsWithInnerRaw = !1;
      const F = O.type, ie = this.format, re = ie.concise;
      O._compact && (ie.concise = !0);
      const Q = this[F];
      if (Q === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(F)} with constructor ${JSON.stringify(O.constructor.name)}`);
      const pe = this._currentNode;
      this._currentNode = O, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      const ne = this._insideAux;
      this._insideAux = O.loc == null, this._maybeAddAuxComment(this._insideAux && !ne);
      const R = (q = O.extra) == null ? void 0 : q.parenthesized;
      let C = R && ie.preserveFormat || R && ie.retainFunctionParens && F === "FunctionExpression" || X(O, pe, this.tokenContext, this.inForStatementInit, ie.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!C && R && (H = O.leadingComments) != null && H.length && O.leadingComments[0].type === "CommentBlock")
        switch (pe == null ? void 0 : pe.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (pe.callee !== O) break;
          default:
            C = !0;
        }
      let z = !1;
      !C && this._noLineTerminator && ((N = O.leadingComments) != null && N.some(y) || this.format.retainLines && O.loc && O.loc.start.line > this._buf.getCurrentLine()) && (C = !0, z = !0);
      let ae, ce;
      if (!C && (ee || (ee = pe && this._noLineTerminatorAfterNode === pe && l.isLastChild(pe, O)), ee)) {
        var ye;
        (ye = O.trailingComments) != null && ye.some(y) ? P(O) && (C = !0) : (ae = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = O);
      }
      C && (this.tokenChar(40), z && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (ce = !0, this.inForStatementInit = !1), ae = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(O, pe);
      const he = F === "Program" || F === "File" ? null : O.loc;
      this.exactSource(he, Q.bind(this, O, pe)), C ? (this._printTrailingComments(O, pe), z && (this.dedent(), this.newline()), this.tokenChar(41), this._noLineTerminator = ee, ce && (this.inForStatementInit = !0)) : ee && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(O, pe)) : this._printTrailingComments(O, pe, L), this._currentNode = pe, ie.concise = re, this._insideAux = ne, ae !== void 0 && (this._noLineTerminatorAfterNode = ae), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(O) {
      O && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      const O = this.format.auxiliaryCommentBefore;
      O && this._printComment({
        type: "CommentBlock",
        value: O
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      const O = this.format.auxiliaryCommentAfter;
      O && this._printComment({
        type: "CommentBlock",
        value: O
      }, 0);
    }
    getPossibleRaw(O) {
      const ee = O.extra;
      if ((ee == null ? void 0 : ee.raw) != null && ee.rawValue != null && O.value === ee.rawValue)
        return ee.raw;
    }
    printJoin(O, ee, L, q, H, N, F, ie) {
      if (!(O != null && O.length)) return;
      if (L == null && this.format.retainLines) {
        var re;
        const z = (re = O[0].loc) == null ? void 0 : re.start.line;
        z != null && z !== this._buf.getCurrentLine() && (L = !0);
      }
      L && this.indent();
      const Q = {
        addNewlines: N,
        nextNodeStartLine: 0
      }, pe = q == null ? void 0 : q.bind(this), ne = O.length;
      for (let z = 0; z < ne; z++) {
        const ae = O[z];
        if (ae && (ee && this._printNewline(z === 0, Q), this.print(ae, void 0, ie || 0), F == null || F(ae, z), pe != null && (z < ne - 1 ? pe(z, !1) : H && pe(z, !0)), ee)) {
          var R;
          if ((R = ae.trailingComments) != null && R.length || (this._lastCommentLine = 0), z + 1 === ne)
            this.newline(1);
          else {
            var C;
            const ce = O[z + 1];
            Q.nextNodeStartLine = ((C = ce.loc) == null ? void 0 : C.start.line) || 0, this._printNewline(!0, Q);
          }
        }
      }
      L && this.dedent();
    }
    printAndIndentOnComments(O) {
      const ee = O.leadingComments && O.leadingComments.length > 0;
      ee && this.indent(), this.print(O), ee && this.dedent();
    }
    printBlock(O) {
      const ee = O.body;
      ee.type !== "EmptyStatement" && this.space(), this.print(ee);
    }
    _printTrailingComments(O, ee, L) {
      const {
        innerComments: q,
        trailingComments: H
      } = O;
      q != null && q.length && this._printComments(2, q, O, ee, L), H != null && H.length && this._printComments(2, H, O, ee, L);
    }
    _printLeadingComments(O, ee) {
      const L = O.leadingComments;
      L != null && L.length && this._printComments(0, L, O, ee);
    }
    _maybePrintInnerComments(O, ee) {
      if (this._endsWithInnerRaw) {
        var L;
        this.printInnerComments((L = this.tokenMap) == null ? void 0 : L.findMatching(this._currentNode, O, ee));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(O) {
      const ee = this._currentNode, L = ee.innerComments;
      if (!(L != null && L.length)) return;
      const q = this.endsWith(32), H = this._indentInnerComments, N = this._printedComments.size;
      H && this.indent(), this._printComments(1, L, ee, void 0, void 0, O), q && N !== this._printedComments.size && this.space(), H && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(O, ee, L, q) {
      this.printJoin(O, !0, ee ?? !1, void 0, void 0, q, void 0, L);
    }
    printList(O, ee, L, q, H, N) {
      this.printJoin(O, L, q, H ?? J, ee, void 0, N);
    }
    shouldPrintTrailingComma(O) {
      if (!this.tokenMap) return null;
      const ee = this.tokenMap.findLastIndex(this._currentNode, (L) => this.tokenMap.matchesOriginal(L, O));
      return ee <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[ee - 1], ",");
    }
    _printNewline(O, ee) {
      const L = this.format;
      if (L.retainLines || L.compact) return;
      if (L.concise) {
        this.space();
        return;
      }
      if (!O)
        return;
      const q = ee.nextNodeStartLine, H = this._lastCommentLine;
      if (q > 0 && H > 0) {
        const N = q - H;
        if (N >= 0) {
          this.newline(N || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(O, ee) {
      if (O.ignore || this._printedComments.has(O)) return 0;
      if (this._noLineTerminator && B.test(O.value))
        return 2;
      if (ee && this.tokenMap) {
        const L = this.tokenMap.find(this._currentNode, (q) => q.value === O.value);
        if (L && L.start > ee.start)
          return 2;
      }
      return this._printedComments.add(O), this.format.shouldPrintComment(O.value) ? 1 : 0;
    }
    _printComment(O, ee) {
      const L = this._noLineTerminator, q = O.type === "CommentBlock", H = q && ee !== 1 && !this._noLineTerminator;
      H && this._buf.hasContent() && ee !== 2 && this.newline(1);
      const N = this.getLastChar();
      N !== 91 && N !== 123 && N !== 40 && this.space();
      let F;
      if (q) {
        if (F = `/*${O.value}*/`, this.format.indent.adjustMultilineComment) {
          var ie;
          const re = (ie = O.loc) == null ? void 0 : ie.start.column;
          if (re) {
            const Q = new RegExp("\\n\\s{1," + re + "}", "g");
            F = F.replace(Q, `
`);
          }
          if (this.format.concise)
            F = F.replace(/\n(?!$)/g, `
`);
          else {
            let Q = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (Q += this._getIndent()), F = F.replace(/\n(?!$)/g, `
${" ".repeat(Q)}`);
          }
        }
      } else L ? F = `/*${O.value}*/` : F = `//${O.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        const {
          _printSemicolonBeforeNextToken: re,
          _printSemicolonBeforeNextNode: Q
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", O.loc), this._append(F, q), this._printSemicolonBeforeNextNode = Q, this._printSemicolonBeforeNextToken = re;
      } else
        this.source("start", O.loc), this._append(F, q);
      !q && !L && this.newline(1, !0), H && ee !== 3 && this.newline(1);
    }
    _printComments(O, ee, L, q, H = 0, N) {
      const F = L.loc, ie = ee.length;
      let re = !!F;
      const Q = re ? F.start.line : 0, pe = re ? F.end.line : 0;
      let ne = 0, R = 0;
      const C = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let z = 0; z < ie; z++) {
        const ae = ee[z], ce = this._shouldPrintComment(ae, N);
        if (ce === 2) {
          re = !1;
          break;
        }
        if (re && ae.loc && ce === 1) {
          const ye = ae.loc.start.line, he = ae.loc.end.line;
          if (O === 0) {
            let Pe = 0;
            z === 0 ? this._buf.hasContent() && (ae.type === "CommentLine" || ye !== he) && (Pe = R = 1) : Pe = ye - ne, ne = he, C(Pe), this._printComment(ae, 1), z + 1 === ie && (C(Math.max(Q - ne, R)), ne = Q);
          } else if (O === 1) {
            const Pe = ye - (z === 0 ? Q : ne);
            ne = he, C(Pe), this._printComment(ae, 1), z + 1 === ie && (C(Math.min(1, pe - ne)), ne = pe);
          } else {
            const Pe = ye - (z === 0 ? pe - H : ne);
            ne = he, C(Pe), this._printComment(ae, 1);
          }
        } else {
          if (re = !1, ce !== 1)
            continue;
          if (ie === 1) {
            const ye = ae.loc ? ae.loc.start.line === ae.loc.end.line : !_.test(ae.value), he = ye && !x(L) && !A(q) && !g(q) && !I(L);
            O === 0 ? this._printComment(ae, he && L.type !== "ObjectExpression" || ye && w(q, {
              body: L
            }) ? 1 : 0) : he && O === 2 ? this._printComment(ae, 1) : this._printComment(ae, 0);
          } else O === 1 && !(L.type === "ObjectExpression" && L.properties.length > 1) && L.type !== "ClassBody" && L.type !== "TSInterfaceBody" ? this._printComment(ae, z === 0 ? 2 : z === ie - 1 ? 3 : 0) : this._printComment(ae, 0);
        }
      }
      O === 2 && re && ne && (this._lastCommentLine = ne);
    }
  }
  Object.assign(Z.prototype, f), (0, p.addDeprecatedGenerators)(Z), bs.default = Z;
  function J(G, O) {
    this.token(",", !1, G), O || this.space();
  }
  return bs;
}
var Fc;
function pd() {
  if (Fc) return Ss;
  Fc = 1, Object.defineProperty(Ss, "__esModule", {
    value: !0
  }), Ss.default = o;
  var i = Xh(), l = cd();
  function u(f, p, P) {
    if (p.experimental_preserveFormat) {
      if (typeof f != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!p.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (p.compact && p.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (p.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (p.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(P.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
    }
    const w = {
      auxiliaryCommentBefore: p.auxiliaryCommentBefore,
      auxiliaryCommentAfter: p.auxiliaryCommentAfter,
      shouldPrintComment: p.shouldPrintComment,
      preserveFormat: p.experimental_preserveFormat,
      retainLines: p.retainLines,
      retainFunctionParens: p.retainFunctionParens,
      comments: p.comments == null || p.comments,
      compact: p.compact,
      minified: p.minified,
      concise: p.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, p.jsescOption),
      topicToken: p.topicToken,
      importAttributesKeyword: p.importAttributesKeyword
    };
    {
      var x;
      w.decoratorsBeforeExport = p.decoratorsBeforeExport, w.jsescOption.json = p.jsonCompatibleStrings, w.recordAndTupleSyntaxType = (x = p.recordAndTupleSyntaxType) != null ? x : "hash";
    }
    w.minified ? (w.compact = !0, w.shouldPrintComment = w.shouldPrintComment || (() => w.comments)) : w.shouldPrintComment = w.shouldPrintComment || ((v) => w.comments || v.includes("@license") || v.includes("@preserve")), w.compact === "auto" && (w.compact = typeof f == "string" && f.length > 5e5, w.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${p.filename} as it exceeds the max of 500KB.`)), (w.compact || w.preserveFormat) && (w.indent.adjustMultilineComment = !1);
    const {
      auxiliaryCommentBefore: A,
      auxiliaryCommentAfter: g,
      shouldPrintComment: I
    } = w;
    return A && !I(A) && (w.auxiliaryCommentBefore = void 0), g && !I(g) && (w.auxiliaryCommentAfter = void 0), w;
  }
  Ss.CodeGenerator = class {
    constructor(p, P = {}, w) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = p, this._format = u(w, P, p), this._map = P.sourceMaps ? new i.default(P, w) : null;
    }
    generate() {
      return new l.default(this._format, this._map).generate(this._ast);
    }
  };
  function o(f, p = {}, P) {
    const w = u(P, p, f), x = p.sourceMaps ? new i.default(p, P) : null;
    return new l.default(w, x, f.tokens, typeof P == "string" ? P : null).generate(f);
  }
  return Ss;
}
var jt = {}, Rc;
function fd() {
  if (Rc) return jt;
  Rc = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.find = o, jt.findParent = u, jt.getAncestry = x, jt.getDeepestCommonAncestorFrom = w, jt.getEarliestCommonAncestorFrom = P, jt.getFunctionParent = f, jt.getStatementParent = p, jt.inType = I, jt.isAncestor = A, jt.isDescendant = g;
  var i = Ze();
  const {
    VISITOR_KEYS: l
  } = i;
  function u(v) {
    let S = this;
    for (; S = S.parentPath; )
      if (v(S)) return S;
    return null;
  }
  function o(v) {
    let S = this;
    do
      if (v(S)) return S;
    while (S = S.parentPath);
    return null;
  }
  function f() {
    return this.findParent((v) => v.isFunction());
  }
  function p() {
    let v = this;
    do {
      if (!v.parentPath || Array.isArray(v.container) && v.isStatement())
        break;
      v = v.parentPath;
    } while (v);
    if (v && (v.isProgram() || v.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return v;
  }
  function P(v) {
    return this.getDeepestCommonAncestorFrom(v, function(S, _, B) {
      let y;
      const X = l[S.type];
      for (const Z of B) {
        const J = Z[_ + 1];
        if (!y) {
          y = J;
          continue;
        }
        if (J.listKey && y.listKey === J.listKey && J.key < y.key) {
          y = J;
          continue;
        }
        const G = X.indexOf(y.parentKey), O = X.indexOf(J.parentKey);
        G > O && (y = J);
      }
      return y;
    });
  }
  function w(v, S) {
    if (!v.length)
      return this;
    if (v.length === 1)
      return v[0];
    let _ = 1 / 0, B, y;
    const X = v.map((J) => {
      const G = [];
      do
        G.unshift(J);
      while ((J = J.parentPath) && J !== this);
      return G.length < _ && (_ = G.length), G;
    }), Z = X[0];
    e: for (let J = 0; J < _; J++) {
      const G = Z[J];
      for (const O of X)
        if (O[J] !== G)
          break e;
      B = J, y = G;
    }
    if (y)
      return S ? S(y, B, X) : y;
    throw new Error("Couldn't find intersection");
  }
  function x() {
    let v = this;
    const S = [];
    do
      S.push(v);
    while (v = v.parentPath);
    return S;
  }
  function A(v) {
    return v.isDescendant(this);
  }
  function g(v) {
    return !!this.findParent((S) => S === v);
  }
  function I(...v) {
    let S = this;
    for (; S; ) {
      for (const _ of v)
        if (S.node.type === _) return !0;
      S = S.parentPath;
    }
    return !1;
  }
  return jt;
}
var Er = {}, tl = {}, $a = {}, Ja = {}, jc;
function Xp() {
  if (jc) return Ja;
  jc = 1, Object.defineProperty(Ja, "__esModule", {
    value: !0
  }), Ja.createUnionType = P;
  var i = Ze();
  const {
    createFlowUnionType: l,
    createTSUnionType: u,
    createUnionTypeAnnotation: o,
    isFlowType: f,
    isTSType: p
  } = i;
  function P(w) {
    {
      if (w.every((x) => f(x)))
        return l ? l(w) : o(w);
      if (w.every((x) => p(x)) && u)
        return u(w);
    }
  }
  return Ja;
}
var qc;
function hd() {
  if (qc) return $a;
  qc = 1, Object.defineProperty($a, "__esModule", {
    value: !0
  }), $a.default = P;
  var i = Ze(), l = Xp();
  const {
    BOOLEAN_NUMBER_BINARY_OPERATORS: u,
    createTypeAnnotationBasedOnTypeof: o,
    numberTypeAnnotation: f,
    voidTypeAnnotation: p
  } = i;
  function P(v) {
    if (!this.isReferenced()) return;
    const S = this.scope.getBinding(v.name);
    if (S)
      return S.identifier.typeAnnotation ? S.identifier.typeAnnotation : w(S, this, v.name);
    if (v.name === "undefined")
      return p();
    if (v.name === "NaN" || v.name === "Infinity")
      return f();
    v.name;
  }
  function w(v, S, _) {
    const B = [], y = [];
    let X = x(v, S, y);
    const Z = I(v, S, _);
    if (Z) {
      const J = x(v, Z.ifStatement);
      X = X.filter((G) => !J.includes(G)), B.push(Z.typeAnnotation);
    }
    if (X.length) {
      X.push(...y);
      for (const J of X)
        B.push(J.getTypeAnnotation());
    }
    if (B.length)
      return (0, l.createUnionType)(B);
  }
  function x(v, S, _) {
    const B = v.constantViolations.slice();
    return B.unshift(v.path), B.filter((y) => {
      y = y.resolve();
      const X = y._guessExecutionStatusRelativeTo(S);
      return _ && X === "unknown" && _.push(y), X === "before";
    });
  }
  function A(v, S) {
    const _ = S.node.operator, B = S.get("right").resolve(), y = S.get("left").resolve();
    let X;
    if (y.isIdentifier({
      name: v
    }) ? X = B : B.isIdentifier({
      name: v
    }) && (X = y), X)
      return _ === "===" ? X.getTypeAnnotation() : u.includes(_) ? f() : void 0;
    if (_ !== "===" && _ !== "==") return;
    let Z, J;
    if (y.isUnaryExpression({
      operator: "typeof"
    }) ? (Z = y, J = B) : B.isUnaryExpression({
      operator: "typeof"
    }) && (Z = B, J = y), !Z || !Z.get("argument").isIdentifier({
      name: v
    }) || (J = J.resolve(), !J.isLiteral())) return;
    const G = J.node.value;
    if (typeof G == "string")
      return o(G);
  }
  function g(v, S, _) {
    let B;
    for (; B = S.parentPath; ) {
      if (B.isIfStatement() || B.isConditionalExpression())
        return S.key === "test" ? void 0 : B;
      if (B.isFunction() && B.parentPath.scope.getBinding(_) !== v)
        return;
      S = B;
    }
  }
  function I(v, S, _) {
    const B = g(v, S, _);
    if (!B) return;
    const X = [B.get("test")], Z = [];
    for (let J = 0; J < X.length; J++) {
      const G = X[J];
      if (G.isLogicalExpression())
        G.node.operator === "&&" && (X.push(G.get("left")), X.push(G.get("right")));
      else if (G.isBinaryExpression()) {
        const O = A(_, G);
        O && Z.push(O);
      }
    }
    return Z.length ? {
      typeAnnotation: (0, l.createUnionType)(Z),
      ifStatement: B
    } : I(v, B, _);
  }
  return $a;
}
var Uc;
function dd() {
  return Uc || (Uc = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), i.ArrayExpression = we, i.AssignmentExpression = C, i.BinaryExpression = re, i.BooleanLiteral = ye, i.CallExpression = Je, i.ConditionalExpression = pe, i.ClassDeclaration = i.ClassExpression = i.FunctionDeclaration = i.ArrowFunctionExpression = i.FunctionExpression = Le, Object.defineProperty(i, "Identifier", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), i.LogicalExpression = Q, i.NewExpression = N, i.NullLiteral = he, i.NumericLiteral = ce, i.ObjectExpression = Ne, i.ParenthesizedExpression = R, i.RegExpLiteral = Pe, i.RestElement = Ie, i.SequenceExpression = ne, i.StringLiteral = ae, i.TSAsExpression = q, i.TSNonNullExpression = H, i.TaggedTemplateExpression = He, i.TemplateLiteral = F, i.TypeCastExpression = L, i.UnaryExpression = ie, i.UpdateExpression = z, i.VariableDeclarator = ee;
    var l = Ze(), u = hd(), o = Xp();
    const {
      BOOLEAN_BINARY_OPERATORS: f,
      BOOLEAN_UNARY_OPERATORS: p,
      NUMBER_BINARY_OPERATORS: P,
      NUMBER_UNARY_OPERATORS: w,
      STRING_UNARY_OPERATORS: x,
      anyTypeAnnotation: A,
      arrayTypeAnnotation: g,
      booleanTypeAnnotation: I,
      buildMatchMemberExpression: v,
      genericTypeAnnotation: S,
      identifier: _,
      nullLiteralTypeAnnotation: B,
      numberTypeAnnotation: y,
      stringTypeAnnotation: X,
      tupleTypeAnnotation: Z,
      unionTypeAnnotation: J,
      voidTypeAnnotation: G,
      isIdentifier: O
    } = l;
    function ee() {
      if (this.get("id").isIdentifier())
        return this.get("init").getTypeAnnotation();
    }
    function L(qe) {
      return qe.typeAnnotation;
    }
    L.validParent = !0;
    function q(qe) {
      return qe.typeAnnotation;
    }
    q.validParent = !0;
    function H() {
      return this.get("expression").getTypeAnnotation();
    }
    function N(qe) {
      if (qe.callee.type === "Identifier")
        return S(qe.callee);
    }
    function F() {
      return X();
    }
    function ie(qe) {
      const Ge = qe.operator;
      if (Ge === "void")
        return G();
      if (w.includes(Ge))
        return y();
      if (x.includes(Ge))
        return X();
      if (p.includes(Ge))
        return I();
    }
    function re(qe) {
      const Ge = qe.operator;
      if (P.includes(Ge))
        return y();
      if (f.includes(Ge))
        return I();
      if (Ge === "+") {
        const at = this.get("right"), it = this.get("left");
        return it.isBaseType("number") && at.isBaseType("number") ? y() : it.isBaseType("string") || at.isBaseType("string") ? X() : J([X(), y()]);
      }
    }
    function Q() {
      const qe = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, o.createUnionType)(qe);
    }
    function pe() {
      const qe = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, o.createUnionType)(qe);
    }
    function ne() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function R() {
      return this.get("expression").getTypeAnnotation();
    }
    function C() {
      return this.get("right").getTypeAnnotation();
    }
    function z(qe) {
      const Ge = qe.operator;
      if (Ge === "++" || Ge === "--")
        return y();
    }
    function ae() {
      return X();
    }
    function ce() {
      return y();
    }
    function ye() {
      return I();
    }
    function he() {
      return B();
    }
    function Pe() {
      return S(_("RegExp"));
    }
    function Ne() {
      return S(_("Object"));
    }
    function we() {
      return S(_("Array"));
    }
    function Ie() {
      return we();
    }
    Ie.validParent = !0;
    function Le() {
      return S(_("Function"));
    }
    const fe = v("Array.from"), Te = v("Object.keys"), de = v("Object.values"), Ue = v("Object.entries");
    function Je() {
      const {
        callee: qe
      } = this.node;
      return Te(qe) ? g(X()) : fe(qe) || de(qe) || O(qe, {
        name: "Array"
      }) ? g(A()) : Ue(qe) ? g(Z([X(), A()])) : st(this.get("callee"));
    }
    function He() {
      return st(this.get("tag"));
    }
    function st(qe) {
      if (qe = qe.resolve(), qe.isFunction()) {
        const {
          node: Ge
        } = qe;
        if (Ge.async)
          return Ge.generator ? S(_("AsyncIterator")) : S(_("Promise"));
        if (Ge.generator)
          return S(_("Iterator"));
        if (qe.node.returnType)
          return qe.node.returnType;
      }
    }
  }(tl)), tl;
}
var Vc;
function md() {
  if (Vc) return Er;
  Vc = 1, Object.defineProperty(Er, "__esModule", {
    value: !0
  }), Er._getTypeAnnotation = q, Er.baseTypeStrictlyMatches = ie, Er.couldBeBaseType = F, Er.getTypeAnnotation = ee, Er.isBaseType = H, Er.isGenericType = re;
  var i = dd(), l = Ze();
  const {
    anyTypeAnnotation: u,
    isAnyTypeAnnotation: o,
    isArrayTypeAnnotation: f,
    isBooleanTypeAnnotation: p,
    isEmptyTypeAnnotation: P,
    isFlowBaseAnnotation: w,
    isGenericTypeAnnotation: x,
    isIdentifier: A,
    isMixedTypeAnnotation: g,
    isNumberTypeAnnotation: I,
    isStringTypeAnnotation: v,
    isTSArrayType: S,
    isTSTypeAnnotation: _,
    isTSTypeReference: B,
    isTupleTypeAnnotation: y,
    isTypeAnnotation: X,
    isUnionTypeAnnotation: Z,
    isVoidTypeAnnotation: J,
    stringTypeAnnotation: G,
    voidTypeAnnotation: O
  } = l;
  function ee() {
    let Q = this.getData("typeAnnotation");
    return Q != null || (Q = q.call(this) || u(), (X(Q) || _(Q)) && (Q = Q.typeAnnotation), this.setData("typeAnnotation", Q)), Q;
  }
  const L = /* @__PURE__ */ new WeakSet();
  function q() {
    const Q = this.node;
    if (!Q)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const ne = this.parentPath.parentPath, R = ne.parentPath;
        return ne.key === "left" && R.isForInStatement() ? G() : ne.key === "left" && R.isForOfStatement() ? u() : O();
      } else
        return;
    if (Q.typeAnnotation)
      return Q.typeAnnotation;
    if (!L.has(Q)) {
      L.add(Q);
      try {
        var pe;
        let ne = i[Q.type];
        if (ne)
          return ne.call(this, Q);
        if (ne = i[this.parentPath.type], (pe = ne) != null && pe.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        L.delete(Q);
      }
    }
  }
  function H(Q, pe) {
    return N(Q, this.getTypeAnnotation(), pe);
  }
  function N(Q, pe, ne) {
    if (Q === "string")
      return v(pe);
    if (Q === "number")
      return I(pe);
    if (Q === "boolean")
      return p(pe);
    if (Q === "any")
      return o(pe);
    if (Q === "mixed")
      return g(pe);
    if (Q === "empty")
      return P(pe);
    if (Q === "void")
      return J(pe);
    if (ne)
      return !1;
    throw new Error(`Unknown base type ${Q}`);
  }
  function F(Q) {
    const pe = this.getTypeAnnotation();
    if (o(pe)) return !0;
    if (Z(pe)) {
      for (const ne of pe.types)
        if (o(ne) || N(Q, ne, !0))
          return !0;
      return !1;
    } else
      return N(Q, pe, !0);
  }
  function ie(Q) {
    const pe = this.getTypeAnnotation(), ne = Q.getTypeAnnotation();
    return !o(pe) && w(pe) ? ne.type === pe.type : !1;
  }
  function re(Q) {
    const pe = this.getTypeAnnotation();
    return Q === "Array" && (S(pe) || f(pe) || y(pe)) ? !0 : x(pe) && A(pe.id, {
      name: Q
    }) || B(pe) && A(pe.typeName, {
      name: Q
    });
  }
  return Er;
}
var Pr = {}, sn = {}, Xa = { exports: {} }, Kc;
function yd() {
  if (Kc) return Xa.exports;
  Kc = 1;
  var i = String, l = function() {
    return { isColorSupported: !1, reset: i, bold: i, dim: i, italic: i, underline: i, inverse: i, hidden: i, strikethrough: i, black: i, red: i, green: i, yellow: i, blue: i, magenta: i, cyan: i, white: i, gray: i, bgBlack: i, bgRed: i, bgGreen: i, bgYellow: i, bgBlue: i, bgMagenta: i, bgCyan: i, bgWhite: i, blackBright: i, redBright: i, greenBright: i, yellowBright: i, blueBright: i, magentaBright: i, cyanBright: i, whiteBright: i, bgBlackBright: i, bgRedBright: i, bgGreenBright: i, bgYellowBright: i, bgBlueBright: i, bgMagentaBright: i, bgCyanBright: i, bgWhiteBright: i };
  };
  return Xa.exports = l(), Xa.exports.createColors = l, Xa.exports;
}
var vs = {}, Wc;
function Td() {
  return Wc || (Wc = 1, Object.defineProperty(vs, "__esModule", {
    value: !0
  }), vs.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, vs.matchToToken = function(i) {
    var l = { type: "invalid", value: i[0], closed: void 0 };
    return i[1] ? (l.type = "string", l.closed = !!(i[3] || i[4])) : i[5] ? l.type = "comment" : i[6] ? (l.type = "comment", l.closed = !!i[7]) : i[8] ? l.type = "regex" : i[9] ? l.type = "number" : i[10] ? l.type = "name" : i[11] ? l.type = "punctuator" : i[12] && (l.type = "whitespace"), l;
  }), vs;
}
var $c;
function Yp() {
  if ($c) return sn;
  $c = 1, Object.defineProperty(sn, "__esModule", { value: !0 });
  var i = /* @__PURE__ */ yd(), l = Td(), u = to();
  function o() {
    return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : i.isColorSupported;
  }
  const f = (J, G) => (O) => J(G(O));
  function p(J) {
    return {
      keyword: J.cyan,
      capitalized: J.yellow,
      jsxIdentifier: J.yellow,
      punctuator: J.yellow,
      number: J.magenta,
      string: J.green,
      regex: J.magenta,
      comment: J.gray,
      invalid: f(f(J.white, J.bgRed), J.bold),
      gutter: J.gray,
      marker: f(J.red, J.bold),
      message: f(J.red, J.bold),
      reset: J.reset
    };
  }
  const P = p(i.createColors(!0)), w = p(i.createColors(!1));
  function x(J) {
    return J ? P : w;
  }
  const A = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), g = /\r\n|[\n\r\u2028\u2029]/, I = /^[()[\]{}]$/;
  let v;
  {
    const J = /^[a-z][\w-]*$/i, G = function(O, ee, L) {
      if (O.type === "name") {
        if (u.isKeyword(O.value) || u.isStrictReservedWord(O.value, !0) || A.has(O.value))
          return "keyword";
        if (J.test(O.value) && (L[ee - 1] === "<" || L.slice(ee - 2, ee) === "</"))
          return "jsxIdentifier";
        if (O.value[0] !== O.value[0].toLowerCase())
          return "capitalized";
      }
      return O.type === "punctuator" && I.test(O.value) ? "bracket" : O.type === "invalid" && (O.value === "@" || O.value === "#") ? "punctuator" : O.type;
    };
    v = function* (O) {
      let ee;
      for (; ee = l.default.exec(O); ) {
        const L = l.matchToToken(ee);
        yield {
          type: G(L, ee.index, O),
          value: L.value
        };
      }
    };
  }
  function S(J) {
    if (J === "") return "";
    const G = x(!0);
    let O = "";
    for (const {
      type: ee,
      value: L
    } of v(J))
      ee in G ? O += L.split(g).map((q) => G[ee](q)).join(`
`) : O += L;
    return O;
  }
  let _ = !1;
  const B = /\r\n|[\n\r\u2028\u2029]/;
  function y(J, G, O) {
    const ee = Object.assign({
      column: 0,
      line: -1
    }, J.start), L = Object.assign({}, ee, J.end), {
      linesAbove: q = 2,
      linesBelow: H = 3
    } = O || {}, N = ee.line, F = ee.column, ie = L.line, re = L.column;
    let Q = Math.max(N - (q + 1), 0), pe = Math.min(G.length, ie + H);
    N === -1 && (Q = 0), ie === -1 && (pe = G.length);
    const ne = ie - N, R = {};
    if (ne)
      for (let C = 0; C <= ne; C++) {
        const z = C + N;
        if (!F)
          R[z] = !0;
        else if (C === 0) {
          const ae = G[z - 1].length;
          R[z] = [F, ae - F + 1];
        } else if (C === ne)
          R[z] = [0, re];
        else {
          const ae = G[z - C].length;
          R[z] = [0, ae];
        }
      }
    else
      F === re ? F ? R[N] = [F, 0] : R[N] = !0 : R[N] = [F, re - F];
    return {
      start: Q,
      end: pe,
      markerLines: R
    };
  }
  function X(J, G, O = {}) {
    const ee = O.forceColor || o() && O.highlightCode, L = x(ee), q = J.split(B), {
      start: H,
      end: N,
      markerLines: F
    } = y(G, q, O), ie = G.start && typeof G.start.column == "number", re = String(N).length;
    let pe = (ee ? S(J) : J).split(B, N).slice(H, N).map((ne, R) => {
      const C = H + 1 + R, ae = ` ${` ${C}`.slice(-re)} |`, ce = F[C], ye = !F[C + 1];
      if (ce) {
        let he = "";
        if (Array.isArray(ce)) {
          const Pe = ne.slice(0, Math.max(ce[0] - 1, 0)).replace(/[^\t]/g, " "), Ne = ce[1] || 1;
          he = [`
 `, L.gutter(ae.replace(/\d/g, " ")), " ", Pe, L.marker("^").repeat(Ne)].join(""), ye && O.message && (he += " " + L.message(O.message));
        }
        return [L.marker(">"), L.gutter(ae), ne.length > 0 ? ` ${ne}` : "", he].join("");
      } else
        return ` ${L.gutter(ae)}${ne.length > 0 ? ` ${ne}` : ""}`;
    }).join(`
`);
    return O.message && !ie && (pe = `${" ".repeat(re + 1)}${O.message}
${pe}`), ee ? L.reset(pe) : pe;
  }
  function Z(J, G, O, ee = {}) {
    if (!_) {
      _ = !0;
      const q = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(q, "DeprecationWarning");
      else {
        const H = new Error(q);
        H.name = "DeprecationWarning", console.warn(new Error(q));
      }
    }
    return O = Math.max(O, 0), X(J, {
      start: {
        column: O,
        line: G
      }
    }, ee);
  }
  return sn.codeFrameColumns = X, sn.default = Z, sn.highlight = S, sn;
}
var qt = {}, xr = {}, As = {}, Jc;
function Sd() {
  return Jc || (Jc = 1, Object.defineProperty(As, "__esModule", {
    value: !0
  }), As.hooks = void 0, As.hooks = [function(i, l) {
    if (i.key === "test" && (l.isWhile() || l.isSwitchCase()) || i.key === "declaration" && l.isExportDeclaration() || i.key === "body" && l.isLabeledStatement() || i.listKey === "declarations" && l.isVariableDeclaration() && l.node.declarations.length === 1 || i.key === "expression" && l.isExpressionStatement())
      return l.remove(), !0;
  }, function(i, l) {
    if (l.isSequenceExpression() && l.node.expressions.length === 1)
      return l.replaceWith(l.node.expressions[0]), !0;
  }, function(i, l) {
    if (l.isBinary())
      return i.key === "left" ? l.replaceWith(l.node.right) : l.replaceWith(l.node.left), !0;
  }, function(i, l) {
    if (l.isIfStatement() && i.key === "consequent" || i.key === "body" && (l.isLoop() || l.isArrowFunctionExpression()))
      return i.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }]), As;
}
var Xc;
function ll() {
  if (Xc) return xr;
  Xc = 1, Object.defineProperty(xr, "__esModule", {
    value: !0
  }), xr._assertUnremoved = S, xr._callRemovalHooks = g, xr._markRemoved = v, xr._remove = I, xr._removeFromScope = A, xr.remove = x;
  var i = Sd(), l = ln(), u = Hp(), o = en(), f = Ze(), p = ul(), P = Ar();
  const {
    getBindingIdentifiers: w
  } = f;
  function x() {
    var _;
    if (S.call(this), P.resync.call(this), g.call(this)) {
      v.call(this);
      return;
    }
    (_ = this.opts) != null && _.noScope || A.call(this), this.shareCommentsWithSiblings(), I.call(this), v.call(this);
  }
  function A() {
    const _ = w(this.node, !1, !1, !0);
    Object.keys(_).forEach((B) => this.scope.removeBinding(B));
  }
  function g() {
    if (this.parentPath) {
      for (const _ of i.hooks)
        if (_(this, this.parentPath)) return !0;
    }
  }
  function I() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), p.updateSiblingKeys.call(this, this.key, -1)) : u._replaceWith.call(this, null);
  }
  function v() {
    this._traverseFlags |= o.SHOULD_SKIP | o.REMOVED, this.parent && (0, l.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
  }
  function S() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  return xr;
}
var Cs = {}, Yc;
function gd() {
  if (Yc) return Cs;
  Yc = 1, Object.defineProperty(Cs, "__esModule", {
    value: !0
  }), Cs.default = void 0;
  var i = Ze(), l = i;
  const {
    react: u
  } = i, {
    cloneNode: o,
    jsxExpressionContainer: f,
    variableDeclaration: p,
    variableDeclarator: P
  } = l, w = {
    ReferencedIdentifier(A, g) {
      if (A.isJSXIdentifier() && u.isCompatTag(A.node.name) && !A.parentPath.isJSXMemberExpression())
        return;
      if (A.node.name === "this") {
        let v = A.scope;
        do
          if (v.path.isFunction() && !v.path.isArrowFunctionExpression())
            break;
        while (v = v.parent);
        v && g.breakOnScopePaths.push(v.path);
      }
      const I = A.scope.getBinding(A.node.name);
      if (I) {
        for (const v of I.constantViolations)
          if (v.scope !== I.path.scope) {
            g.mutableBinding = !0, A.stop();
            return;
          }
        I === g.scope.getBinding(A.node.name) && (g.bindings[A.node.name] = I);
      }
    }
  };
  class x {
    constructor(g, I) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = I, this.path = g, this.attachAfter = !1;
    }
    isCompatibleScope(g) {
      for (const I of Object.keys(this.bindings)) {
        const v = this.bindings[I];
        if (!g.bindingIdentifierEquals(I, v.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let g = this.path.scope;
      do {
        if (this.isCompatibleScope(g))
          this.scopes.push(g);
        else
          break;
        if (this.breakOnScopePaths.includes(g.path))
          break;
      } while (g = g.parent);
    }
    getAttachmentPath() {
      let g = this._getAttachmentPath();
      if (!g) return;
      let I = g.scope;
      if (I.path === g && (I = g.scope.parent), I.path.isProgram() || I.path.isFunction())
        for (const v of Object.keys(this.bindings)) {
          if (!I.hasOwnBinding(v)) continue;
          const S = this.bindings[v];
          if (S.kind === "param" || S.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(S.path).key >= g.key) {
            this.attachAfter = !0, g = S.path;
            for (const B of S.constantViolations)
              this.getAttachmentParentForPath(B).key > g.key && (g = B);
          }
        }
      return g;
    }
    _getAttachmentPath() {
      const I = this.scopes.pop();
      if (I) {
        if (I.path.isFunction())
          if (this.hasOwnParamBindings(I)) {
            if (this.scope === I) return;
            const v = I.path.get("body").get("body");
            for (let S = 0; S < v.length; S++)
              if (!v[S].node._blockHoist)
                return v[S];
          } else
            return this.getNextScopeAttachmentParent();
        else if (I.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const g = this.scopes.pop();
      if (g) return this.getAttachmentParentForPath(g.path);
    }
    getAttachmentParentForPath(g) {
      do
        if (!g.parentPath || Array.isArray(g.container) && g.isStatement())
          return g;
      while (g = g.parentPath);
    }
    hasOwnParamBindings(g) {
      for (const I of Object.keys(this.bindings)) {
        if (!g.hasOwnBinding(I)) continue;
        const v = this.bindings[I];
        if (v.kind === "param" && v.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(w, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      const g = this.getAttachmentPath();
      if (!g || g.getFunctionParent() === this.path.getFunctionParent()) return;
      let I = g.scope.generateUidIdentifier("ref");
      const v = P(I, this.path.node), S = this.attachAfter ? "insertAfter" : "insertBefore", [_] = g[S]([g.isVariableDeclarator() ? v : p("var", [v])]), B = this.path.parentPath;
      return B.isJSXElement() && this.path.container === B.node.children && (I = f(I)), this.path.replaceWith(o(I)), g.isVariableDeclarator() ? _.get("init") : _.get("declarations.0.init");
    }
  }
  return Cs.default = x, Cs;
}
var Hc;
function ul() {
  if (Hc) return qt;
  Hc = 1, Object.defineProperty(qt, "__esModule", {
    value: !0
  }), qt._containerInsert = ee, qt._containerInsertAfter = q, qt._containerInsertBefore = L, qt._verifyNodeList = Q, qt.insertAfter = ie, qt.insertBefore = O, qt.pushContainer = ne, qt.unshiftContainer = pe, qt.updateSiblingKeys = re;
  var i = ln(), l = en(), u = Ar(), o = ll(), f = Ze(), p = gd();
  const {
    arrowFunctionExpression: P,
    assertExpression: w,
    assignmentExpression: x,
    blockStatement: A,
    callExpression: g,
    cloneNode: I,
    expressionStatement: v,
    isAssignmentExpression: S,
    isCallExpression: _,
    isExportNamedDeclaration: B,
    isExpression: y,
    isIdentifier: X,
    isSequenceExpression: Z,
    isSuper: J,
    thisExpression: G
  } = f;
  function O(R) {
    o._assertUnremoved.call(this);
    const C = Q.call(this, R), {
      parentPath: z,
      parent: ae
    } = this;
    if (z.isExpressionStatement() || z.isLabeledStatement() || B(ae) || z.isExportDefaultDeclaration() && this.isDeclaration())
      return z.insertBefore(C);
    if (this.isNodeType("Expression") && !this.isJSXElement() || z.isForStatement() && this.key === "init")
      return this.node && C.push(this.node), this.replaceExpressionWithStatements(C);
    if (Array.isArray(this.container))
      return L.call(this, C);
    if (this.isStatementOrBlock()) {
      const ce = this.node, ye = ce && (!this.isExpressionStatement() || ce.expression != null);
      return this.replaceWith(A(ye ? [ce] : [])), this.unshiftContainer("body", C);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  function ee(R, C) {
    re.call(this, R, C.length);
    const z = [];
    this.container.splice(R, 0, ...C);
    for (let ye = 0; ye < C.length; ye++) {
      var ae;
      const he = R + ye, Pe = this.getSibling(he);
      z.push(Pe), (ae = this.context) != null && ae.queue && u.pushContext.call(Pe, this.context);
    }
    const ce = u._getQueueContexts.call(this);
    for (const ye of z) {
      u.setScope.call(ye), ye.debug("Inserted.");
      for (const he of ce)
        he.maybeQueue(ye, !0);
    }
    return z;
  }
  function L(R) {
    return ee.call(this, this.key, R);
  }
  function q(R) {
    return ee.call(this, this.key + 1, R);
  }
  const H = (R) => R[R.length - 1];
  function N(R) {
    return Z(R.parent) && (H(R.parent.expressions) !== R.node || N(R.parentPath));
  }
  function F(R, C) {
    if (!S(R) || !X(R.left))
      return !1;
    const z = C.getBlockParent();
    return z.hasOwnBinding(R.left.name) && z.getOwnBinding(R.left.name).constantViolations.length <= 1;
  }
  function ie(R) {
    if (o._assertUnremoved.call(this), this.isSequenceExpression())
      return H(this.get("expressions")).insertAfter(R);
    const C = Q.call(this, R), {
      parentPath: z,
      parent: ae
    } = this;
    if (z.isExpressionStatement() || z.isLabeledStatement() || B(ae) || z.isExportDefaultDeclaration() && this.isDeclaration())
      return z.insertAfter(C.map((ce) => y(ce) ? v(ce) : ce));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !z.isJSXElement() || z.isForStatement() && this.key === "init") {
      const ce = this;
      if (ce.node) {
        const ye = ce.node;
        let {
          scope: he
        } = this;
        if (he.path.isPattern())
          return w(ye), ce.replaceWith(g(P([], ye), [])), ce.get("callee.body").insertAfter(C), [ce];
        if (N(ce))
          C.unshift(ye);
        else if (_(ye) && J(ye.callee))
          C.unshift(ye), C.push(G());
        else if (F(ye, he))
          C.unshift(ye), C.push(I(ye.left));
        else if (he.isPure(ye, !0))
          C.push(ye);
        else {
          z.isMethod({
            computed: !0,
            key: ye
          }) && (he = he.parent);
          const Pe = he.generateDeclaredUidIdentifier();
          C.unshift(v(x("=", I(Pe), ye))), C.push(v(I(Pe)));
        }
      }
      return this.replaceExpressionWithStatements(C);
    } else {
      if (Array.isArray(this.container))
        return q.call(this, C);
      if (this.isStatementOrBlock()) {
        const ce = this.node, ye = ce && (!this.isExpressionStatement() || ce.expression != null);
        return this.replaceWith(A(ye ? [ce] : [])), this.pushContainer("body", C);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function re(R, C) {
    if (!this.parent) return;
    const z = (0, i.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, ae] of z)
      typeof ae.key == "number" && ae.container === this.container && ae.key >= R && (ae.key += C);
  }
  function Q(R) {
    if (!R)
      return [];
    Array.isArray(R) || (R = [R]);
    for (let C = 0; C < R.length; C++) {
      const z = R[C];
      let ae;
      if (z ? typeof z != "object" ? ae = "contains a non-object node" : z.type ? z instanceof l.default && (ae = "has a NodePath when it expected a raw object") : ae = "without a type" : ae = "has falsy node", ae) {
        const ce = Array.isArray(z) ? "array" : typeof z;
        throw new Error(`Node list ${ae} with the index of ${C} and type of ${ce}`);
      }
    }
    return R;
  }
  function pe(R, C) {
    o._assertUnremoved.call(this), C = Q.call(this, C);
    const z = l.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[R],
      listKey: R,
      key: 0
    }).setContext(this.context);
    return L.call(z, C);
  }
  function ne(R, C) {
    o._assertUnremoved.call(this);
    const z = Q.call(this, C), ae = this.node[R];
    return l.default.get({
      parentPath: this,
      parent: this.node,
      container: ae,
      listKey: R,
      key: ae.length
    }).setContext(this.context).replaceWithMultiple(z);
  }
  return qt.hoist = function(C = this.scope) {
    return new p.default(this, C).run();
  }, qt;
}
var Gc;
function Hp() {
  if (Gc) return Pr;
  Gc = 1, Object.defineProperty(Pr, "__esModule", {
    value: !0
  }), Pr._replaceWith = he, Pr.replaceExpressionWithStatements = Pe, Pr.replaceInline = we, Pr.replaceWith = ye, Pr.replaceWithMultiple = ae, Pr.replaceWithSourceString = ce;
  var i = Yp(), l = so(), u = en(), o = ln(), f = ul(), p = il(), P = Ze(), w = Ar();
  const {
    FUNCTION_TYPES: x,
    arrowFunctionExpression: A,
    assignmentExpression: g,
    awaitExpression: I,
    blockStatement: v,
    buildUndefinedNode: S,
    callExpression: _,
    cloneNode: B,
    conditionalExpression: y,
    expressionStatement: X,
    getBindingIdentifiers: Z,
    identifier: J,
    inheritLeadingComments: G,
    inheritTrailingComments: O,
    inheritsComments: ee,
    isBlockStatement: L,
    isEmptyStatement: q,
    isExpression: H,
    isExpressionStatement: N,
    isIfStatement: F,
    isProgram: ie,
    isStatement: re,
    isVariableDeclaration: Q,
    removeComments: pe,
    returnStatement: ne,
    sequenceExpression: R,
    validate: C,
    yieldExpression: z
  } = P;
  function ae(Ie) {
    var Le;
    w.resync.call(this), Ie = f._verifyNodeList.call(this, Ie), G(Ie[0], this.node), O(Ie[Ie.length - 1], this.node), (Le = (0, o.getCachedPaths)(this.hub, this.parent)) == null || Le.delete(this.node), this.node = this.container[this.key] = null;
    const fe = this.insertAfter(Ie);
    return this.node ? this.requeue() : this.remove(), fe;
  }
  function ce(Ie) {
    w.resync.call(this);
    let Le;
    try {
      Ie = `(${Ie})`, Le = (0, p.parse)(Ie);
    } catch (Te) {
      const de = Te.loc;
      throw de && (Te.message += ` - make sure this is an expression.
` + (0, i.codeFrameColumns)(Ie, {
        start: {
          line: de.line,
          column: de.column + 1
        }
      }), Te.code = "BABEL_REPLACE_SOURCE_ERROR"), Te;
    }
    const fe = Le.program.body[0].expression;
    return l.default.removeProperties(fe), this.replaceWith(fe);
  }
  function ye(Ie) {
    if (w.resync.call(this), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let Le = Ie instanceof u.default ? Ie.node : Ie;
    if (!Le)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === Le)
      return [this];
    if (this.isProgram() && !ie(Le))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(Le))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof Le == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let fe = "";
    if (this.isNodeType("Statement") && H(Le) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(Le) && !this.parentPath.isExportDefaultDeclaration() && (Le = X(Le), fe = "expression"), this.isNodeType("Expression") && re(Le) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(Le))
      return this.replaceExpressionWithStatements([Le]);
    const Te = this.node;
    return Te && (ee(Le, Te), pe(Te)), he.call(this, Le), this.type = Le.type, w.setScope.call(this), this.requeue(), [fe ? this.get(fe) : this];
  }
  function he(Ie) {
    var Le;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? C(this.parent, this.key, [Ie]) : C(this.parent, this.key, Ie), this.debug(`Replace with ${Ie == null ? void 0 : Ie.type}`), (Le = (0, o.getCachedPaths)(this.hub, this.parent)) == null || Le.set(Ie, this).delete(this.node), this.node = this.container[this.key] = Ie;
  }
  function Pe(Ie) {
    w.resync.call(this);
    const Le = [], fe = Ne(Ie, Le);
    if (fe) {
      for (const it of Le) this.scope.push({
        id: it
      });
      return this.replaceWith(fe)[0].get("expressions");
    }
    const Te = this.getFunctionParent(), de = Te == null ? void 0 : Te.node.async, Ue = Te == null ? void 0 : Te.node.generator, Je = A([], v(Ie));
    this.replaceWith(_(Je, []));
    const He = this.get("callee");
    He.get("body").scope.hoistVariables((it) => this.scope.push({
      id: it
    }));
    const st = He.getCompletionRecords();
    for (const it of st) {
      if (!it.isExpressionStatement()) continue;
      const ft = it.findParent((Xe) => Xe.isLoop());
      if (ft) {
        let Xe = ft.getData("expressionReplacementReturnUid");
        Xe ? Xe = J(Xe.name) : (Xe = He.scope.generateDeclaredUidIdentifier("ret"), He.get("body").pushContainer("body", ne(B(Xe))), ft.setData("expressionReplacementReturnUid", Xe)), it.get("expression").replaceWith(g("=", B(Xe), it.node.expression));
      } else
        it.replaceWith(ne(it.node.expression));
    }
    He.arrowFunctionToExpression();
    const qe = He, Ge = de && l.default.hasType(this.get("callee.body").node, "AwaitExpression", x), at = Ue && l.default.hasType(this.get("callee.body").node, "YieldExpression", x);
    return Ge && (qe.set("async", !0), at || this.replaceWith(I(this.node))), at && (qe.set("generator", !0), this.replaceWith(z(this.node, !0))), qe.get("body.body");
  }
  function Ne(Ie, Le) {
    const fe = [];
    let Te = !0;
    for (const de of Ie)
      if (q(de) || (Te = !1), H(de))
        fe.push(de);
      else if (N(de))
        fe.push(de.expression);
      else if (Q(de)) {
        if (de.kind !== "var") return;
        for (const Ue of de.declarations) {
          const Je = Z(Ue);
          for (const He of Object.keys(Je))
            Le.push(B(Je[He]));
          Ue.init && fe.push(g("=", Ue.id, Ue.init));
        }
        Te = !0;
      } else if (F(de)) {
        const Ue = de.consequent ? Ne([de.consequent], Le) : S(), Je = de.alternate ? Ne([de.alternate], Le) : S();
        if (!Ue || !Je) return;
        fe.push(y(de.test, Ue, Je));
      } else if (L(de)) {
        const Ue = Ne(de.body, Le);
        if (!Ue) return;
        fe.push(Ue);
      } else if (q(de))
        Ie.indexOf(de) === 0 && (Te = !0);
      else
        return;
    return Te && fe.push(S()), fe.length === 1 ? fe[0] : R(fe);
  }
  function we(Ie) {
    if (w.resync.call(this), Array.isArray(Ie))
      if (Array.isArray(this.container)) {
        Ie = f._verifyNodeList.call(this, Ie);
        const Le = f._containerInsertAfter.call(this, Ie);
        return this.remove(), Le;
      } else
        return this.replaceWithMultiple(Ie);
    else
      return this.replaceWith(Ie);
  }
  return Pr;
}
var Is = {}, zc;
function bd() {
  if (zc) return Is;
  zc = 1, Object.defineProperty(Is, "__esModule", {
    value: !0
  }), Is.evaluate = v, Is.evaluateTruthy = P;
  const i = ["Number", "String", "Math"], l = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], u = ["random"];
  function o(S) {
    return i.includes(S);
  }
  function f(S) {
    return l.includes(S);
  }
  function p(S) {
    return u.includes(S);
  }
  function P() {
    const S = this.evaluate();
    if (S.confident) return !!S.value;
  }
  function w(S, _) {
    _.confident && (_.deoptPath = S, _.confident = !1);
  }
  const x = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function A(S, _) {
    const {
      node: B
    } = S, {
      seen: y
    } = _;
    if (y.has(B)) {
      const X = y.get(B);
      if (X.resolved)
        return X.value;
      w(S, _);
      return;
    } else {
      const X = {
        resolved: !1
      };
      y.set(B, X);
      const Z = g(S, _);
      return _.confident && (X.resolved = !0, X.value = Z), Z;
    }
  }
  function g(S, _) {
    if (_.confident) {
      if (S.isSequenceExpression()) {
        const B = S.get("expressions");
        return A(B[B.length - 1], _);
      }
      if (S.isStringLiteral() || S.isNumericLiteral() || S.isBooleanLiteral())
        return S.node.value;
      if (S.isNullLiteral())
        return null;
      if (S.isTemplateLiteral())
        return I(S, S.node.quasis, _);
      if (S.isTaggedTemplateExpression() && S.get("tag").isMemberExpression()) {
        const B = S.get("tag.object"), {
          node: {
            name: y
          }
        } = B, X = S.get("tag.property");
        if (B.isIdentifier() && y === "String" && !S.scope.getBinding(y) && X.isIdentifier() && X.node.name === "raw")
          return I(S, S.node.quasi.quasis, _, !0);
      }
      if (S.isConditionalExpression()) {
        const B = A(S.get("test"), _);
        return _.confident ? A(B ? S.get("consequent") : S.get("alternate"), _) : void 0;
      }
      if (S.isExpressionWrapper())
        return A(S.get("expression"), _);
      if (S.isMemberExpression() && !S.parentPath.isCallExpression({
        callee: S.node
      })) {
        const B = S.get("property"), y = S.get("object");
        if (y.isLiteral()) {
          const X = y.node.value, Z = typeof X;
          let J = null;
          if (S.node.computed) {
            if (J = A(B, _), !_.confident) return;
          } else B.isIdentifier() && (J = B.node.name);
          if ((Z === "number" || Z === "string") && J != null && (typeof J == "number" || typeof J == "string"))
            return X[J];
        }
      }
      if (S.isReferencedIdentifier()) {
        const B = S.scope.getBinding(S.node.name);
        if (B) {
          if (B.constantViolations.length > 0 || S.node.start < B.path.node.end) {
            w(B.path, _);
            return;
          }
          if (B.hasValue)
            return B.value;
        }
        const y = S.node.name;
        if (x.has(y)) {
          if (!B)
            return x.get(y);
          w(B.path, _);
          return;
        }
        const X = S.resolve();
        if (X === S) {
          w(S, _);
          return;
        } else
          return A(X, _);
      }
      if (S.isUnaryExpression({
        prefix: !0
      })) {
        if (S.node.operator === "void")
          return;
        const B = S.get("argument");
        if (S.node.operator === "typeof" && (B.isFunction() || B.isClass()))
          return "function";
        const y = A(B, _);
        if (!_.confident) return;
        switch (S.node.operator) {
          case "!":
            return !y;
          case "+":
            return +y;
          case "-":
            return -y;
          case "~":
            return ~y;
          case "typeof":
            return typeof y;
        }
      }
      if (S.isArrayExpression()) {
        const B = [], y = S.get("elements");
        for (const X of y) {
          const Z = X.evaluate();
          if (Z.confident)
            B.push(Z.value);
          else {
            w(Z.deopt, _);
            return;
          }
        }
        return B;
      }
      if (S.isObjectExpression()) {
        const B = {}, y = S.get("properties");
        for (const X of y) {
          if (X.isObjectMethod() || X.isSpreadElement()) {
            w(X, _);
            return;
          }
          const Z = X.get("key");
          let J;
          if (X.node.computed) {
            if (J = Z.evaluate(), !J.confident) {
              w(J.deopt, _);
              return;
            }
            J = J.value;
          } else Z.isIdentifier() ? J = Z.node.name : J = Z.node.value;
          let O = X.get("value").evaluate();
          if (!O.confident) {
            w(O.deopt, _);
            return;
          }
          O = O.value, B[J] = O;
        }
        return B;
      }
      if (S.isLogicalExpression()) {
        const B = _.confident, y = A(S.get("left"), _), X = _.confident;
        _.confident = B;
        const Z = A(S.get("right"), _), J = _.confident;
        switch (S.node.operator) {
          case "||":
            return _.confident = X && (!!y || J), _.confident ? y || Z : void 0;
          case "&&":
            return _.confident = X && (!y || J), _.confident ? y && Z : void 0;
          case "??":
            return _.confident = X && (y != null || J), _.confident ? y ?? Z : void 0;
        }
      }
      if (S.isBinaryExpression()) {
        const B = A(S.get("left"), _);
        if (!_.confident) return;
        const y = A(S.get("right"), _);
        if (!_.confident) return;
        switch (S.node.operator) {
          case "-":
            return B - y;
          case "+":
            return B + y;
          case "/":
            return B / y;
          case "*":
            return B * y;
          case "%":
            return B % y;
          case "**":
            return Math.pow(B, y);
          case "<":
            return B < y;
          case ">":
            return B > y;
          case "<=":
            return B <= y;
          case ">=":
            return B >= y;
          case "==":
            return B == y;
          case "!=":
            return B != y;
          case "===":
            return B === y;
          case "!==":
            return B !== y;
          case "|":
            return B | y;
          case "&":
            return B & y;
          case "^":
            return B ^ y;
          case "<<":
            return B << y;
          case ">>":
            return B >> y;
          case ">>>":
            return B >>> y;
        }
      }
      if (S.isCallExpression()) {
        const B = S.get("callee");
        let y, X;
        if (B.isIdentifier() && !S.scope.getBinding(B.node.name) && (o(B.node.name) || f(B.node.name)) && (X = hl[B.node.name]), B.isMemberExpression()) {
          const Z = B.get("object"), J = B.get("property");
          if (Z.isIdentifier() && J.isIdentifier() && o(Z.node.name) && !p(J.node.name)) {
            y = hl[Z.node.name];
            const G = J.node.name;
            hasOwnProperty.call(y, G) && (X = y[G]);
          }
          if (Z.isLiteral() && J.isIdentifier()) {
            const G = typeof Z.node.value;
            (G === "string" || G === "number") && (y = Z.node.value, X = y[J.node.name]);
          }
        }
        if (X) {
          const Z = S.get("arguments").map((J) => A(J, _));
          return _.confident ? X.apply(y, Z) : void 0;
        }
      }
      w(S, _);
    }
  }
  function I(S, _, B, y = !1) {
    let X = "", Z = 0;
    const J = S.isTemplateLiteral() ? S.get("expressions") : S.get("quasi.expressions");
    for (const G of _) {
      if (!B.confident) break;
      X += y ? G.value.raw : G.value.cooked;
      const O = J[Z++];
      O && (X += String(A(O, B)));
    }
    if (B.confident)
      return X;
  }
  function v() {
    const S = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    };
    let _ = A(this, S);
    return S.confident || (_ = void 0), {
      confident: S.confident,
      deopt: S.deoptPath,
      value: _
    };
  }
  return Is;
}
var fr = {}, Ot = {}, Ut = {}, Qc;
function Ed() {
  if (Qc) return Ut;
  Qc = 1, Object.defineProperty(Ut, "__esModule", {
    value: !0
  }), Ut.statements = Ut.statement = Ut.smart = Ut.program = Ut.expression = void 0;
  var i = Ze();
  const {
    assertExpressionStatement: l
  } = i;
  function u(f) {
    return {
      code: (p) => `/* @babel/template */;
${p}`,
      validate: () => {
      },
      unwrap: (p) => f(p.program.body.slice(1))
    };
  }
  Ut.smart = u((f) => f.length > 1 ? f : f[0]), Ut.statements = u((f) => f), Ut.statement = u((f) => {
    if (f.length === 0)
      throw new Error("Found nothing to return.");
    if (f.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return f[0];
  });
  const o = Ut.expression = {
    code: (f) => `(
${f}
)`,
    validate: (f) => {
      if (f.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (o.unwrap(f).start === 0)
        throw new Error("Parse result included parens.");
    },
    unwrap: ({
      program: f
    }) => {
      const [p] = f.body;
      return l(p), p.expression;
    }
  };
  return Ut.program = {
    code: (f) => f,
    validate: () => {
    },
    unwrap: (f) => f.program
  }, Ut;
}
var Ya = {}, an = {}, Zc;
function cl() {
  if (Zc) return an;
  Zc = 1, Object.defineProperty(an, "__esModule", {
    value: !0
  }), an.merge = u, an.normalizeReplacements = f, an.validate = o;
  const i = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function l(p, P) {
    if (p == null) return {};
    var w = {};
    for (var x in p) if ({}.hasOwnProperty.call(p, x)) {
      if (P.includes(x)) continue;
      w[x] = p[x];
    }
    return w;
  }
  function u(p, P) {
    const {
      placeholderWhitelist: w = p.placeholderWhitelist,
      placeholderPattern: x = p.placeholderPattern,
      preserveComments: A = p.preserveComments,
      syntacticPlaceholders: g = p.syntacticPlaceholders
    } = P;
    return {
      parser: Object.assign({}, p.parser, P.parser),
      placeholderWhitelist: w,
      placeholderPattern: x,
      preserveComments: A,
      syntacticPlaceholders: g
    };
  }
  function o(p) {
    if (p != null && typeof p != "object")
      throw new Error("Unknown template options.");
    const P = p || {}, {
      placeholderWhitelist: w,
      placeholderPattern: x,
      preserveComments: A,
      syntacticPlaceholders: g
    } = P, I = l(P, i);
    if (w != null && !(w instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (x != null && !(x instanceof RegExp) && x !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (A != null && typeof A != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (g != null && typeof g != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (g === !0 && (w != null || x != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: I,
      placeholderWhitelist: w || void 0,
      placeholderPattern: x ?? void 0,
      preserveComments: A ?? void 0,
      syntacticPlaceholders: g ?? void 0
    };
  }
  function f(p) {
    if (Array.isArray(p))
      return p.reduce((P, w, x) => (P["$" + x] = w, P), {});
    if (typeof p == "object" || p == null)
      return p || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  return an;
}
var Ha = {}, Ga = {}, ep;
function Gp() {
  if (ep) return Ga;
  ep = 1, Object.defineProperty(Ga, "__esModule", {
    value: !0
  }), Ga.default = B;
  var i = Ze(), l = il(), u = Yp();
  const {
    isCallExpression: o,
    isExpressionStatement: f,
    isFunction: p,
    isIdentifier: P,
    isJSXIdentifier: w,
    isNewExpression: x,
    isPlaceholder: A,
    isStatement: g,
    isStringLiteral: I,
    removePropertiesDeep: v,
    traverse: S
  } = i, _ = /^[_$A-Z0-9]+$/;
  function B(J, G, O) {
    const {
      placeholderWhitelist: ee,
      placeholderPattern: L,
      preserveComments: q,
      syntacticPlaceholders: H
    } = O, N = Z(G, O.parser, H);
    v(N, {
      preserveComments: q
    }), J.validate(N);
    const F = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: ee,
      placeholderPattern: L,
      syntacticPlaceholders: H
    };
    return S(N, y, F), Object.assign({
      ast: N
    }, F.syntactic.placeholders.length ? F.syntactic : F.legacy);
  }
  function y(J, G, O) {
    var ee;
    let L, q = O.syntactic.placeholders.length > 0;
    if (A(J)) {
      if (O.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      L = J.name.name, q = !0;
    } else {
      if (q || O.syntacticPlaceholders)
        return;
      if (P(J) || w(J))
        L = J.name;
      else if (I(J))
        L = J.value;
      else
        return;
    }
    if (q && (O.placeholderPattern != null || O.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!q && (O.placeholderPattern === !1 || !(O.placeholderPattern || _).test(L)) && !((ee = O.placeholderWhitelist) != null && ee.has(L)))
      return;
    G = G.slice();
    const {
      node: H,
      key: N
    } = G[G.length - 1];
    let F;
    I(J) || A(J, {
      expectedNode: "StringLiteral"
    }) ? F = "string" : x(H) && N === "arguments" || o(H) && N === "arguments" || p(H) && N === "params" ? F = "param" : f(H) && !A(J) ? (F = "statement", G = G.slice(0, -1)) : g(J) && A(J) ? F = "statement" : F = "other";
    const {
      placeholders: ie,
      placeholderNames: re
    } = q ? O.syntactic : O.legacy;
    ie.push({
      name: L,
      type: F,
      resolve: (Q) => X(Q, G),
      isDuplicate: re.has(L)
    }), re.add(L);
  }
  function X(J, G) {
    let O = J;
    for (let q = 0; q < G.length - 1; q++) {
      const {
        key: H,
        index: N
      } = G[q];
      N === void 0 ? O = O[H] : O = O[H][N];
    }
    const {
      key: ee,
      index: L
    } = G[G.length - 1];
    return {
      parent: O,
      key: ee,
      index: L
    };
  }
  function Z(J, G, O) {
    const ee = (G.plugins || []).slice();
    O !== !1 && ee.push("placeholders"), G = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, G, {
      plugins: ee
    });
    try {
      return (0, l.parse)(J, G);
    } catch (L) {
      const q = L.loc;
      throw q && (L.message += `
` + (0, u.codeFrameColumns)(J, {
        start: q
      }), L.code = "BABEL_TEMPLATE_PARSE_ERROR"), L;
    }
  }
  return Ga;
}
var za = {}, tp;
function zp() {
  if (tp) return za;
  tp = 1, Object.defineProperty(za, "__esModule", {
    value: !0
  }), za.default = g;
  var i = Ze();
  const {
    blockStatement: l,
    cloneNode: u,
    emptyStatement: o,
    expressionStatement: f,
    identifier: p,
    isStatement: P,
    isStringLiteral: w,
    stringLiteral: x,
    validate: A
  } = i;
  function g(v, S) {
    const _ = u(v.ast);
    return S && (v.placeholders.forEach((B) => {
      if (!hasOwnProperty.call(S, B.name)) {
        const y = B.name;
        throw new Error(`Error: No substitution given for "${y}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${y}'])}
            - { placeholderPattern: /^${y}$/ }`);
      }
    }), Object.keys(S).forEach((B) => {
      if (!v.placeholderNames.has(B))
        throw new Error(`Unknown substitution "${B}" given`);
    })), v.placeholders.slice().reverse().forEach((B) => {
      try {
        I(B, _, S && S[B.name] || null);
      } catch (y) {
        throw y.message = `@babel/template placeholder "${B.name}": ${y.message}`, y;
      }
    }), _;
  }
  function I(v, S, _) {
    v.isDuplicate && (Array.isArray(_) ? _ = _.map((J) => u(J)) : typeof _ == "object" && (_ = u(_)));
    const {
      parent: B,
      key: y,
      index: X
    } = v.resolve(S);
    if (v.type === "string") {
      if (typeof _ == "string" && (_ = x(_)), !_ || !w(_))
        throw new Error("Expected string substitution");
    } else if (v.type === "statement")
      X === void 0 ? _ ? Array.isArray(_) ? _ = l(_) : typeof _ == "string" ? _ = f(p(_)) : P(_) || (_ = f(_)) : _ = o() : _ && !Array.isArray(_) && (typeof _ == "string" && (_ = p(_)), P(_) || (_ = f(_)));
    else if (v.type === "param") {
      if (typeof _ == "string" && (_ = p(_)), X === void 0) throw new Error("Assertion failure.");
    } else if (typeof _ == "string" && (_ = p(_)), Array.isArray(_))
      throw new Error("Cannot replace single expression with an array.");
    function Z(J, G, O) {
      const ee = J[G];
      J[G] = O, (ee.type === "Identifier" || ee.type === "Placeholder") && (ee.typeAnnotation && (O.typeAnnotation = ee.typeAnnotation), ee.optional && (O.optional = ee.optional), ee.decorators && (O.decorators = ee.decorators));
    }
    if (X === void 0)
      A(B, y, _), Z(B, y, _);
    else {
      const J = B[y].slice();
      v.type === "statement" || v.type === "param" ? _ == null ? J.splice(X, 1) : Array.isArray(_) ? J.splice(X, 1, ..._) : Z(J, X, _) : Z(J, X, _), A(B, y, J), B[y] = J;
    }
  }
  return za;
}
var rp;
function Pd() {
  if (rp) return Ha;
  rp = 1, Object.defineProperty(Ha, "__esModule", {
    value: !0
  }), Ha.default = o;
  var i = cl(), l = Gp(), u = zp();
  function o(f, p, P) {
    p = f.code(p);
    let w;
    return (x) => {
      const A = (0, i.normalizeReplacements)(x);
      return w || (w = (0, l.default)(f, p, P)), f.unwrap((0, u.default)(w, A));
    };
  }
  return Ha;
}
var Qa = {}, ip;
function xd() {
  if (ip) return Qa;
  ip = 1, Object.defineProperty(Qa, "__esModule", {
    value: !0
  }), Qa.default = o;
  var i = cl(), l = Gp(), u = zp();
  function o(P, w, x) {
    const {
      metadata: A,
      names: g
    } = f(P, w, x);
    return (I) => {
      const v = {};
      return I.forEach((S, _) => {
        v[g[_]] = S;
      }), (S) => {
        const _ = (0, i.normalizeReplacements)(S);
        return _ && Object.keys(_).forEach((B) => {
          if (hasOwnProperty.call(v, B))
            throw new Error("Unexpected replacement overlap.");
        }), P.unwrap((0, u.default)(A, _ ? Object.assign(_, v) : v));
      };
    };
  }
  function f(P, w, x) {
    let A = "BABEL_TPL$";
    const g = w.join("");
    do
      A = "$$" + A;
    while (g.includes(A));
    const {
      names: I,
      code: v
    } = p(w, A);
    return {
      metadata: (0, l.default)(P, P.code(v), {
        parser: x.parser,
        placeholderWhitelist: new Set(I.concat(x.placeholderWhitelist ? Array.from(x.placeholderWhitelist) : [])),
        placeholderPattern: x.placeholderPattern,
        preserveComments: x.preserveComments,
        syntacticPlaceholders: x.syntacticPlaceholders
      }),
      names: I
    };
  }
  function p(P, w) {
    const x = [];
    let A = P[0];
    for (let g = 1; g < P.length; g++) {
      const I = `${w}${g - 1}`;
      x.push(I), A += I + P[g];
    }
    return {
      names: x,
      code: A
    };
  }
  return Qa;
}
var np;
function vd() {
  if (np) return Ya;
  np = 1, Object.defineProperty(Ya, "__esModule", {
    value: !0
  }), Ya.default = f;
  var i = cl(), l = Pd(), u = xd();
  const o = (0, i.validate)({
    placeholderPattern: !1
  });
  function f(P, w) {
    const x = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), g = w || (0, i.validate)(null);
    return Object.assign((I, ...v) => {
      if (typeof I == "string") {
        if (v.length > 1) throw new Error("Unexpected extra params.");
        return p((0, l.default)(P, I, (0, i.merge)(g, (0, i.validate)(v[0]))));
      } else if (Array.isArray(I)) {
        let S = x.get(I);
        return S || (S = (0, u.default)(P, I, g), x.set(I, S)), p(S(v));
      } else if (typeof I == "object" && I) {
        if (v.length > 0) throw new Error("Unexpected extra params.");
        return f(P, (0, i.merge)(g, (0, i.validate)(I)));
      }
      throw new Error(`Unexpected template param ${typeof I}`);
    }, {
      ast: (I, ...v) => {
        if (typeof I == "string") {
          if (v.length > 1) throw new Error("Unexpected extra params.");
          return (0, l.default)(P, I, (0, i.merge)((0, i.merge)(g, (0, i.validate)(v[0])), o))();
        } else if (Array.isArray(I)) {
          let S = A.get(I);
          return S || (S = (0, u.default)(P, I, (0, i.merge)(g, o)), A.set(I, S)), S(v)();
        }
        throw new Error(`Unexpected template param ${typeof I}`);
      }
    });
  }
  function p(P) {
    let w = "";
    try {
      throw new Error();
    } catch (x) {
      x.stack && (w = x.stack.split(`
`).slice(3).join(`
`));
    }
    return (x) => {
      try {
        return P(x);
      } catch (A) {
        throw A.stack += `
    =============
${w}`, A;
      }
    };
  }
  return Ya;
}
var sp;
function Ad() {
  if (sp) return Ot;
  sp = 1, Object.defineProperty(Ot, "__esModule", {
    value: !0
  }), Ot.statements = Ot.statement = Ot.smart = Ot.program = Ot.expression = Ot.default = void 0;
  var i = Ed(), l = vd();
  const u = Ot.smart = (0, l.default)(i.smart), o = Ot.statement = (0, l.default)(i.statement), f = Ot.statements = (0, l.default)(i.statements), p = Ot.expression = (0, l.default)(i.expression), P = Ot.program = (0, l.default)(i.program);
  return Ot.default = Object.assign(u.bind(void 0), {
    smart: u,
    statement: o,
    statements: f,
    expression: p,
    program: P,
    ast: u.ast
  }), Ot;
}
var ap;
function Cd() {
  if (ap) return fr;
  ap = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.arrowFunctionToExpression = Le, fr.ensureBlock = Ne, fr.ensureFunctionName = be, fr.splitExportDeclaration = Xe, fr.toComputedKey = Pe, fr.unwrapFunctionEnvironment = we;
  var i = Ze(), l = Ad(), u = no(), o = Ar();
  const {
    arrowFunctionExpression: f,
    assignmentExpression: p,
    binaryExpression: P,
    blockStatement: w,
    callExpression: x,
    conditionalExpression: A,
    expressionStatement: g,
    identifier: I,
    isIdentifier: v,
    jsxIdentifier: S,
    logicalExpression: _,
    LOGICAL_OPERATORS: B,
    memberExpression: y,
    metaProperty: X,
    numericLiteral: Z,
    objectExpression: J,
    restElement: G,
    returnStatement: O,
    sequenceExpression: ee,
    spreadElement: L,
    stringLiteral: q,
    super: H,
    thisExpression: N,
    toExpression: F,
    unaryExpression: ie,
    toBindingIdentifierName: re,
    isFunction: Q,
    isAssignmentPattern: pe,
    isRestElement: ne,
    getFunctionName: R,
    cloneNode: C,
    variableDeclaration: z,
    variableDeclarator: ae,
    exportNamedDeclaration: ce,
    exportSpecifier: ye,
    inherits: he
  } = i;
  function Pe() {
    let j;
    if (this.isMemberExpression())
      j = this.node.property;
    else if (this.isProperty() || this.isMethod())
      j = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || v(j) && (j = q(j.name)), j;
  }
  function Ne() {
    const j = this.get("body"), D = j.node;
    if (Array.isArray(j))
      throw new Error("Can't convert array path to a block statement");
    if (!D)
      throw new Error("Can't convert node without a body");
    if (j.isBlockStatement())
      return D;
    const V = [];
    let le = "body", me, ge;
    j.isStatement() ? (ge = "body", me = 0, V.push(j.node)) : (le += ".body.0", this.isFunction() ? (me = "argument", V.push(O(j.node))) : (me = "expression", V.push(g(j.node)))), this.node.body = w(V);
    const xe = this.get(le);
    return o.setup.call(j, xe, ge ? xe.node[ge] : xe.node, ge, me), this.node;
  }
  fr.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function we() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    Te(this);
  }
  function Ie(j, D) {
    j.node.type = D;
  }
  function Le({
    allowInsertArrow: j = !0,
    allowInsertArrowWithRest: D = j,
    noNewArrows: V = !((le) => (le = arguments[0]) == null ? void 0 : le.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let le = this;
    if (!V) {
      var me;
      le = (me = le.ensureFunctionName(!1)) != null ? me : le;
    }
    const {
      thisBinding: ge,
      fnPath: xe
    } = Te(le, V, j, D);
    if (xe.ensureBlock(), Ie(xe, "FunctionExpression"), !V) {
      const De = ge ? null : xe.scope.generateUidIdentifier("arrowCheckId");
      return De && xe.parentPath.scope.push({
        id: De,
        init: J([])
      }), xe.get("body").unshiftContainer("body", g(x(this.hub.addHelper("newArrowCheck"), [N(), I(De ? De.name : ge)]))), xe.replaceWith(x(y(xe.node, I("bind")), [De ? I(De.name) : N()])), xe.get("callee.object");
    }
    return xe;
  }
  const fe = (0, u.environmentVisitor)({
    CallExpression(j, {
      allSuperCalls: D
    }) {
      j.get("callee").isSuper() && D.push(j);
    }
  });
  function Te(j, D = !0, V = !0, le = !0) {
    let me, ge = j.findParent((oe) => {
      if (oe.isArrowFunctionExpression()) {
        var K;
        return (K = me) != null || (me = oe), !1;
      }
      return oe.isFunction() || oe.isProgram() || oe.isClassProperty({
        static: !1
      }) || oe.isClassPrivateProperty({
        static: !1
      });
    });
    const xe = ge.isClassMethod({
      kind: "constructor"
    });
    if (ge.isClassProperty() || ge.isClassPrivateProperty())
      if (me)
        ge = me;
      else if (V)
        j.replaceWith(x(f([], F(j.node)), [])), ge = j.get("callee"), j = ge.get("body");
      else
        throw j.buildCodeFrameError("Unable to transform arrow inside class property");
    const {
      thisPaths: De,
      argumentsPaths: We,
      newTargetPaths: Ce,
      superProps: Ye,
      superCalls: $e
    } = ft(j);
    if (xe && $e.length > 0) {
      if (!V)
        throw $e[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!le)
        throw $e[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      const oe = [];
      ge.traverse(fe, {
        allSuperCalls: oe
      });
      const K = qe(ge);
      oe.forEach((Ae) => {
        const Be = I(K);
        Be.loc = Ae.node.callee.loc, Ae.get("callee").replaceWith(Be);
      });
    }
    if (We.length > 0) {
      const oe = at(ge, "arguments", () => {
        const K = () => I("arguments");
        return ge.scope.path.isProgram() ? A(P("===", ie("typeof", K()), q("undefined")), ge.scope.buildUndefinedNode(), K()) : K();
      });
      We.forEach((K) => {
        const Ae = I(oe);
        Ae.loc = K.node.loc, K.replaceWith(Ae);
      });
    }
    if (Ce.length > 0) {
      const oe = at(ge, "newtarget", () => X(I("new"), I("target")));
      Ce.forEach((K) => {
        const Ae = I(oe);
        Ae.loc = K.node.loc, K.replaceWith(Ae);
      });
    }
    if (Ye.length > 0) {
      if (!V)
        throw Ye[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      Ye.reduce((K, Ae) => K.concat(Ue(Ae)), []).forEach((K) => {
        const Ae = K.node.computed ? "" : K.get("property").node.name, Be = K.parentPath, Ke = Be.isAssignmentExpression({
          left: K.node
        }), ct = Be.isCallExpression({
          callee: K.node
        }), Lt = Be.isTaggedTemplateExpression({
          tag: K.node
        }), Kt = Ge(ge, Ke, Ae), Nt = [];
        if (K.node.computed && Nt.push(K.get("property").node), Ke) {
          const xt = Be.node.right;
          Nt.push(xt);
        }
        const At = x(I(Kt), Nt);
        ct ? (Be.unshiftContainer("arguments", N()), K.replaceWith(y(At, I("call"))), De.push(Be.get("arguments.0"))) : Ke ? Be.replaceWith(At) : Lt ? (K.replaceWith(x(y(At, I("bind"), !1), [N()])), De.push(K.get("arguments.0"))) : K.replaceWith(At);
      });
    }
    let et;
    return (De.length > 0 || !D) && (et = st(ge, xe), (D || xe && Je(ge)) && (De.forEach((oe) => {
      const K = oe.isJSX() ? S(et) : I(et);
      K.loc = oe.node.loc, oe.replaceWith(K);
    }), D || (et = null))), {
      thisBinding: et,
      fnPath: j
    };
  }
  function de(j) {
    return B.includes(j);
  }
  function Ue(j) {
    if (j.parentPath.isAssignmentExpression() && j.parentPath.node.operator !== "=") {
      const V = j.parentPath, le = V.node.operator.slice(0, -1), me = V.node.right, ge = de(le);
      if (j.node.computed) {
        const xe = j.scope.generateDeclaredUidIdentifier("tmp"), De = j.node.object, We = j.node.property;
        V.get("left").replaceWith(y(De, p("=", xe, We), !0)), V.get("right").replaceWith(D(ge ? "=" : le, y(De, I(xe.name), !0), me));
      } else {
        const xe = j.node.object, De = j.node.property;
        V.get("left").replaceWith(y(xe, De)), V.get("right").replaceWith(D(ge ? "=" : le, y(xe, I(De.name)), me));
      }
      return ge ? V.replaceWith(_(le, V.node.left, V.node.right)) : V.node.operator = "=", [V.get("left"), V.get("right").get("left")];
    } else if (j.parentPath.isUpdateExpression()) {
      const V = j.parentPath, le = j.scope.generateDeclaredUidIdentifier("tmp"), me = j.node.computed ? j.scope.generateDeclaredUidIdentifier("prop") : null, ge = [p("=", le, y(j.node.object, me ? p("=", me, j.node.property) : j.node.property, j.node.computed)), p("=", y(j.node.object, me ? I(me.name) : j.node.property, j.node.computed), P(j.parentPath.node.operator[0], I(le.name), Z(1)))];
      j.parentPath.node.prefix || ge.push(I(le.name)), V.replaceWith(ee(ge));
      const xe = V.get("expressions.0.right"), De = V.get("expressions.1.left");
      return [xe, De];
    }
    return [j];
    function D(V, le, me) {
      return V === "=" ? p("=", le, me) : P(V, le, me);
    }
  }
  function Je(j) {
    return j.isClassMethod() && !!j.parentPath.parentPath.node.superClass;
  }
  const He = (0, u.environmentVisitor)({
    CallExpression(j, {
      supers: D,
      thisBinding: V
    }) {
      j.get("callee").isSuper() && (D.has(j.node) || (D.add(j.node), j.replaceWithMultiple([j.node, p("=", I(V), I("this"))])));
    }
  });
  function st(j, D) {
    return at(j, "this", (V) => {
      if (!D || !Je(j)) return N();
      j.traverse(He, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: V
      });
    });
  }
  function qe(j) {
    return at(j, "supercall", () => {
      const D = j.scope.generateUidIdentifier("args");
      return f([G(D)], x(H(), [L(I(D.name))]));
    });
  }
  function Ge(j, D, V) {
    return at(j, `superprop_${D ? "set" : "get"}:${V || ""}`, () => {
      const me = [];
      let ge;
      if (V)
        ge = y(H(), I(V));
      else {
        const xe = j.scope.generateUidIdentifier("prop");
        me.unshift(xe), ge = y(H(), I(xe.name), !0);
      }
      if (D) {
        const xe = j.scope.generateUidIdentifier("value");
        me.push(xe), ge = p("=", ge, I(xe.name));
      }
      return f(me, ge);
    });
  }
  function at(j, D, V) {
    const le = "binding:" + D;
    let me = j.getData(le);
    if (!me) {
      const ge = j.scope.generateUidIdentifier(D);
      me = ge.name, j.setData(le, me), j.scope.push({
        id: ge,
        init: V(me)
      });
    }
    return me;
  }
  const it = (0, u.environmentVisitor)({
    ThisExpression(j, {
      thisPaths: D
    }) {
      D.push(j);
    },
    JSXIdentifier(j, {
      thisPaths: D
    }) {
      j.node.name === "this" && (!j.parentPath.isJSXMemberExpression({
        object: j.node
      }) && !j.parentPath.isJSXOpeningElement({
        name: j.node
      }) || D.push(j));
    },
    CallExpression(j, {
      superCalls: D
    }) {
      j.get("callee").isSuper() && D.push(j);
    },
    MemberExpression(j, {
      superProps: D
    }) {
      j.get("object").isSuper() && D.push(j);
    },
    Identifier(j, {
      argumentsPaths: D
    }) {
      if (!j.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let V = j.scope;
      do {
        if (V.hasOwnBinding("arguments")) {
          V.rename("arguments");
          return;
        }
        if (V.path.isFunction() && !V.path.isArrowFunctionExpression())
          break;
      } while (V = V.parent);
      D.push(j);
    },
    MetaProperty(j, {
      newTargetPaths: D
    }) {
      j.get("meta").isIdentifier({
        name: "new"
      }) && j.get("property").isIdentifier({
        name: "target"
      }) && D.push(j);
    }
  });
  function ft(j) {
    const D = [], V = [], le = [], me = [], ge = [];
    return j.traverse(it, {
      thisPaths: D,
      argumentsPaths: V,
      newTargetPaths: le,
      superProps: me,
      superCalls: ge
    }), {
      thisPaths: D,
      argumentsPaths: V,
      newTargetPaths: le,
      superProps: me,
      superCalls: ge
    };
  }
  function Xe() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    const j = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      const me = j.isFunctionDeclaration() || j.isClassDeclaration(), ge = j.isFunctionExpression() || j.isClassExpression(), xe = j.isScope() ? j.scope.parent : j.scope;
      let De = j.node.id, We = !1;
      De ? ge && xe.hasBinding(De.name) && (We = !0, De = xe.generateUidIdentifier(De.name)) : (We = !0, De = xe.generateUidIdentifier("default"), (me || ge) && (j.node.id = C(De)));
      const Ce = me ? j.node : z("var", [ae(C(De), j.node)]), Ye = ce(null, [ye(C(De), I("default"))]);
      return this.insertAfter(Ye), this.replaceWith(Ce), We && xe.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    const D = j.getOuterBindingIdentifiers(), V = Object.keys(D).map((me) => ye(I(me), I(me))), le = ce(null, V);
    return this.insertAfter(le), this.replaceWith(j.node), this;
  }
  const Tt = {
    "ReferencedIdentifier|BindingIdentifier"(j, D) {
      j.node.name === D.name && (D.needsRename = !0, j.stop());
    },
    Scope(j, D) {
      j.scope.hasOwnBinding(D.name) && j.skip();
    }
  };
  function be(j) {
    if (this.node.id) return this;
    const D = R(this.node, this.parent);
    if (D == null) return this;
    let {
      name: V
    } = D;
    if (!j && /[\uD800-\uDFFF]/.test(V) || V.startsWith("get ") || V.startsWith("set "))
      return null;
    V = re(V.replace(/[/ ]/g, "_"));
    const le = I(V);
    he(le, D.originalNode);
    const me = {
      needsRename: !1,
      name: V
    }, {
      scope: ge
    } = this, xe = ge.getOwnBinding(V);
    if (xe ? xe.kind === "param" && (me.needsRename = !0) : (ge.parent.hasBinding(V) || ge.hasGlobal(V)) && this.traverse(Tt, me), !me.needsRename)
      return this.node.id = le, ge.getProgramParent().references[le.name] = !0, this;
    if (ge.hasBinding(le.name) && !ge.hasGlobal(le.name))
      return ge.rename(le.name), this.node.id = le, ge.getProgramParent().references[le.name] = !0, this;
    if (!Q(this.node)) return null;
    const De = ge.generateUidIdentifier(le.name), We = [];
    for (let Ye = 0, $e = ve(this.node); Ye < $e; Ye++)
      We.push(ge.generateUidIdentifier("x"));
    const Ce = l.default.expression.ast`
    (function (${De}) {
      function ${le}(${We}) {
        return ${C(De)}.apply(this, arguments);
      }

      ${C(le)}.toString = function () {
        return ${C(De)}.toString();
      }

      return ${C(le)};
    })(${F(this.node)})
  `;
    return this.replaceWith(Ce)[0].get("arguments.0");
  }
  function ve(j) {
    const D = j.params.findIndex((V) => pe(V) || ne(V));
    return D === -1 ? j.params.length : D;
  }
  return fr;
}
var rl = {}, op;
function Id() {
  return op || (op = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), i._guessExecutionStatusRelativeTo = H, i._resolve = Q, i.canHaveVariableDeclarationOrExpression = _, i.canSwapBetweenExpressionAndStatement = B, i.getSource = J, i.isCompletionRecord = y, i.isConstantExpression = pe, i.isInStrictMode = ne, i.isNodeType = S, i.isStatementOrBlock = X, i.isStatic = v, i.matchesPattern = I, i.referencesImport = Z, i.resolve = re, i.willIMaybeExecuteBefore = G;
    var l = Ze();
    const {
      STATEMENT_OR_BLOCK_KEYS: u,
      VISITOR_KEYS: o,
      isBlockStatement: f,
      isExpression: p,
      isIdentifier: P,
      isLiteral: w,
      isStringLiteral: x,
      isType: A,
      matchesPattern: g
    } = l;
    function I(R, C) {
      return g(this.node, R, C);
    }
    i.has = function(C) {
      var z;
      const ae = (z = this.node) == null ? void 0 : z[C];
      return ae && Array.isArray(ae) ? !!ae.length : !!ae;
    };
    function v() {
      return this.scope.isStatic(this.node);
    }
    i.is = i.has, i.isnt = function(C) {
      return !this.has(C);
    }, i.equals = function(C, z) {
      return this.node[C] === z;
    };
    function S(R) {
      return A(this.type, R);
    }
    function _() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function B(R) {
      return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? f(R) : this.isBlockStatement() ? p(R) : !1;
    }
    function y(R) {
      let C = this, z = !0;
      do {
        const {
          type: ae,
          container: ce
        } = C;
        if (!z && (C.isFunction() || ae === "StaticBlock"))
          return !!R;
        if (z = !1, Array.isArray(ce) && C.key !== ce.length - 1)
          return !1;
      } while ((C = C.parentPath) && !C.isProgram() && !C.isDoExpression());
      return !0;
    }
    function X() {
      return this.parentPath.isLabeledStatement() || f(this.container) ? !1 : u.includes(this.key);
    }
    function Z(R, C) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === C || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? x(this.node.property, {
          value: C
        }) : this.node.property.name === C)) {
          const ye = this.get("object");
          return ye.isReferencedIdentifier() && ye.referencesImport(R, "*");
        }
        return !1;
      }
      const z = this.scope.getBinding(this.node.name);
      if (!z || z.kind !== "module") return !1;
      const ae = z.path, ce = ae.parentPath;
      if (!ce.isImportDeclaration()) return !1;
      if (ce.node.source.value === R) {
        if (!C) return !0;
      } else
        return !1;
      return !!(ae.isImportDefaultSpecifier() && C === "default" || ae.isImportNamespaceSpecifier() && C === "*" || ae.isImportSpecifier() && P(ae.node.imported, {
        name: C
      }));
    }
    function J() {
      const R = this.node;
      if (R.end) {
        const C = this.hub.getCode();
        if (C) return C.slice(R.start, R.end);
      }
      return "";
    }
    function G(R) {
      return this._guessExecutionStatusRelativeTo(R) !== "after";
    }
    function O(R) {
      return R.isProgram() ? R : (R.parentPath.scope.getFunctionParent() || R.parentPath.scope.getProgramParent()).path;
    }
    function ee(R, C) {
      switch (R) {
        case "LogicalExpression":
          return C === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return C === "consequent" || C === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return C === "body";
        case "ForStatement":
          return C === "body" || C === "update";
        case "SwitchStatement":
          return C === "cases";
        case "TryStatement":
          return C === "handler";
        case "AssignmentPattern":
          return C === "right";
        case "OptionalMemberExpression":
          return C === "property";
        case "OptionalCallExpression":
          return C === "arguments";
        default:
          return !1;
      }
    }
    function L(R, C) {
      for (let z = 0; z < C; z++) {
        const ae = R[z];
        if (ee(ae.parent.type, ae.parentKey))
          return !0;
      }
      return !1;
    }
    const q = Symbol();
    function H(R) {
      return N(this, R, /* @__PURE__ */ new Map());
    }
    function N(R, C, z) {
      const ae = {
        this: O(R),
        target: O(C)
      };
      if (ae.target.node !== ae.this.node)
        return ie(R, ae.target, z);
      const ce = {
        target: C.getAncestry(),
        this: R.getAncestry()
      };
      if (ce.target.includes(R)) return "after";
      if (ce.this.includes(C)) return "before";
      let ye;
      const he = {
        target: 0,
        this: 0
      };
      for (; !ye && he.this < ce.this.length; ) {
        const Ie = ce.this[he.this];
        he.target = ce.target.indexOf(Ie), he.target >= 0 ? ye = Ie : he.this++;
      }
      if (!ye)
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      if (L(ce.this, he.this - 1) || L(ce.target, he.target - 1))
        return "unknown";
      const Pe = {
        this: ce.this[he.this - 1],
        target: ce.target[he.target - 1]
      };
      if (Pe.target.listKey && Pe.this.listKey && Pe.target.container === Pe.this.container)
        return Pe.target.key > Pe.this.key ? "before" : "after";
      const Ne = o[ye.type], we = {
        this: Ne.indexOf(Pe.this.parentKey),
        target: Ne.indexOf(Pe.target.parentKey)
      };
      return we.target > we.this ? "before" : "after";
    }
    function F(R, C, z) {
      if (C.isFunctionDeclaration()) {
        if (C.parentPath.isExportDeclaration())
          return "unknown";
      } else return N(R, C, z) === "before" ? "before" : "unknown";
      const ae = C.scope.getBinding(C.node.id.name);
      if (!ae.references) return "before";
      const ce = ae.referencePaths;
      let ye;
      for (const he of ce) {
        if (!!he.find((we) => we.node === C.node)) continue;
        if (he.key !== "callee" || !he.parentPath.isCallExpression())
          return "unknown";
        const Ne = N(R, he, z);
        if (ye && ye !== Ne)
          return "unknown";
        ye = Ne;
      }
      return ye;
    }
    function ie(R, C, z) {
      let ae = z.get(R.node), ce;
      if (!ae)
        z.set(R.node, ae = /* @__PURE__ */ new Map());
      else if (ce = ae.get(C.node))
        return ce === q ? "unknown" : ce;
      ae.set(C.node, q);
      const ye = F(R, C, z);
      return ae.set(C.node, ye), ye;
    }
    function re(R, C) {
      return Q.call(this, R, C) || this;
    }
    function Q(R, C) {
      var z;
      if (!((z = C) != null && z.includes(this)))
        if (C = C || [], C.push(this), this.isVariableDeclarator()) {
          if (this.get("id").isIdentifier())
            return this.get("init").resolve(R, C);
        } else if (this.isReferencedIdentifier()) {
          const ae = this.scope.getBinding(this.node.name);
          if (!ae || !ae.constant || ae.kind === "module") return;
          if (ae.path !== this) {
            const ce = ae.path.resolve(R, C);
            return this.find((ye) => ye.node === ce.node) ? void 0 : ce;
          }
        } else {
          if (this.isTypeCastExpression())
            return this.get("expression").resolve(R, C);
          if (R && this.isMemberExpression()) {
            const ae = this.toComputedKey();
            if (!w(ae)) return;
            const ce = ae.value, ye = this.get("object").resolve(R, C);
            if (ye.isObjectExpression()) {
              const he = ye.get("properties");
              for (const Pe of he) {
                if (!Pe.isProperty()) continue;
                const Ne = Pe.get("key");
                let we = Pe.isnt("computed") && Ne.isIdentifier({
                  name: ce
                });
                if (we = we || Ne.isLiteral({
                  value: ce
                }), we) return Pe.get("value").resolve(R, C);
              }
            } else if (ye.isArrayExpression() && !isNaN(+ce)) {
              const Pe = ye.get("elements")[ce];
              if (Pe) return Pe.resolve(R, C);
            }
          }
        }
    }
    function pe() {
      if (this.isIdentifier()) {
        const R = this.scope.getBinding(this.node.name);
        return R ? R.constant : !1;
      }
      if (this.isLiteral())
        return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((R) => R.isConstantExpression()) : !0;
      if (this.isUnaryExpression())
        return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
      if (this.isBinaryExpression()) {
        const {
          operator: R
        } = this.node;
        return R !== "in" && R !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
        name: "Symbol"
      }) && !this.scope.hasBinding("Symbol", {
        noGlobals: !0
      }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
        noGlobals: !0
      }) && this.get("arguments")[0].isStringLiteral() : !1;
    }
    function ne() {
      return !!(this.isProgram() ? this : this.parentPath).find((z) => {
        if (z.isProgram({
          sourceType: "module"
        }) || z.isClass()) return !0;
        if (z.isArrowFunctionExpression() && !z.get("body").isBlockStatement())
          return !1;
        let ae;
        if (z.isFunction())
          ae = z.node.body;
        else if (z.isProgram())
          ae = z.node;
        else
          return !1;
        for (const ce of ae.directives)
          if (ce.value.value === "use strict")
            return !0;
      });
    }
  }(rl)), rl;
}
var Pt = {}, lp;
function wd() {
  if (lp) return Pt;
  lp = 1, Object.defineProperty(Pt, "__esModule", {
    value: !0
  }), Pt._getKey = H, Pt._getPattern = N, Pt.get = q, Pt.getAllNextSiblings = ee, Pt.getAllPrevSiblings = L, Pt.getAssignmentIdentifiers = F, Pt.getBindingIdentifierPaths = Q, Pt.getBindingIdentifiers = ie, Pt.getCompletionRecords = Z, Pt.getNextSibling = O, Pt.getOpposite = I, Pt.getOuterBindingIdentifierPaths = pe, Pt.getOuterBindingIdentifiers = re, Pt.getPrevSibling = G, Pt.getSibling = J;
  var i = en(), l = Ze();
  const {
    getAssignmentIdentifiers: u,
    getBindingIdentifiers: o,
    getOuterBindingIdentifiers: f,
    numericLiteral: p,
    unaryExpression: P
  } = l, w = 0, x = 1;
  function A(ne) {
    return {
      type: w,
      path: ne
    };
  }
  function g(ne) {
    return {
      type: x,
      path: ne
    };
  }
  function I() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  function v(ne, R, C) {
    return ne && R.push(...X(ne, C)), R;
  }
  function S(ne, R, C) {
    let z = [];
    for (let ae = 0; ae < ne.length; ae++) {
      const ce = ne[ae], ye = X(ce, C), he = [], Pe = [];
      for (const Ne of ye)
        Ne.type === w && he.push(Ne), Ne.type === x && Pe.push(Ne);
      he.length && (z = he), R.push(...Pe);
    }
    return R.push(...z), R;
  }
  function _(ne) {
    ne.forEach((R) => {
      R.type = x;
    });
  }
  function B(ne, R) {
    ne.forEach((C) => {
      C.path.isBreakStatement({
        label: null
      }) && (R ? C.path.replaceWith(P("void", p(0))) : C.path.remove());
    });
  }
  function y(ne, R) {
    const C = [];
    if (R.canHaveBreak) {
      let z = [];
      for (let ae = 0; ae < ne.length; ae++) {
        const ce = ne[ae], ye = Object.assign({}, R, {
          inCaseClause: !1
        });
        ce.isBlockStatement() && (R.inCaseClause || R.shouldPopulateBreak) ? ye.shouldPopulateBreak = !0 : ye.shouldPopulateBreak = !1;
        const he = X(ce, ye);
        if (he.length > 0 && he.every((Pe) => Pe.type === x)) {
          z.length > 0 && he.every((Pe) => Pe.path.isBreakStatement({
            label: null
          })) ? (_(z), C.push(...z), z.some((Pe) => Pe.path.isDeclaration()) && (C.push(...he), B(he, !0)), B(he, !1)) : (C.push(...he), R.shouldPopulateBreak || B(he, !0));
          break;
        }
        if (ae === ne.length - 1)
          C.push(...he);
        else {
          z = [];
          for (let Pe = 0; Pe < he.length; Pe++) {
            const Ne = he[Pe];
            Ne.type === x && C.push(Ne), Ne.type === w && z.push(Ne);
          }
        }
      }
    } else if (ne.length)
      for (let z = ne.length - 1; z >= 0; z--) {
        const ae = X(ne[z], R);
        if (ae.length > 1 || ae.length === 1 && !ae[0].path.isVariableDeclaration()) {
          C.push(...ae);
          break;
        }
      }
    return C;
  }
  function X(ne, R) {
    let C = [];
    if (ne.isIfStatement())
      C = v(ne.get("consequent"), C, R), C = v(ne.get("alternate"), C, R);
    else {
      if (ne.isDoExpression() || ne.isFor() || ne.isWhile() || ne.isLabeledStatement())
        return v(ne.get("body"), C, R);
      if (ne.isProgram() || ne.isBlockStatement())
        return y(ne.get("body"), R);
      if (ne.isFunction())
        return X(ne.get("body"), R);
      if (ne.isTryStatement())
        C = v(ne.get("block"), C, R), C = v(ne.get("handler"), C, R);
      else {
        if (ne.isCatchClause())
          return v(ne.get("body"), C, R);
        if (ne.isSwitchStatement())
          return S(ne.get("cases"), C, R);
        if (ne.isSwitchCase())
          return y(ne.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        ne.isBreakStatement() ? C.push(g(ne)) : C.push(A(ne));
      }
    }
    return C;
  }
  function Z() {
    return X(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((R) => R.path);
  }
  function J(ne) {
    return i.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: ne
    }).setContext(this.context);
  }
  function G() {
    return this.getSibling(this.key - 1);
  }
  function O() {
    return this.getSibling(this.key + 1);
  }
  function ee() {
    let ne = this.key, R = this.getSibling(++ne);
    const C = [];
    for (; R.node; )
      C.push(R), R = this.getSibling(++ne);
    return C;
  }
  function L() {
    let ne = this.key, R = this.getSibling(--ne);
    const C = [];
    for (; R.node; )
      C.push(R), R = this.getSibling(--ne);
    return C;
  }
  function q(ne, R = !0) {
    R === !0 && (R = this.context);
    const C = ne.split(".");
    return C.length === 1 ? H.call(this, ne, R) : N.call(this, C, R);
  }
  function H(ne, R) {
    const C = this.node, z = C[ne];
    return Array.isArray(z) ? z.map((ae, ce) => i.default.get({
      listKey: ne,
      parentPath: this,
      parent: C,
      container: z,
      key: ce
    }).setContext(R)) : i.default.get({
      parentPath: this,
      parent: C,
      container: C,
      key: ne
    }).setContext(R);
  }
  function N(ne, R) {
    let C = this;
    for (const z of ne)
      z === "." ? C = C.parentPath : Array.isArray(C) ? C = C[z] : C = C.get(z, R);
    return C;
  }
  function F() {
    return u(this.node);
  }
  function ie(ne) {
    return o(this.node, ne);
  }
  function re(ne) {
    return f(this.node, ne);
  }
  function Q(ne = !1, R = !1) {
    const z = [this], ae = /* @__PURE__ */ Object.create(null);
    for (; z.length; ) {
      const ce = z.shift();
      if (!ce || !ce.node) continue;
      const ye = o.keys[ce.node.type];
      if (ce.isIdentifier()) {
        ne ? (ae[ce.node.name] = ae[ce.node.name] || []).push(ce) : ae[ce.node.name] = ce;
        continue;
      }
      if (ce.isExportDeclaration()) {
        const he = ce.get("declaration");
        he.isDeclaration() && z.push(he);
        continue;
      }
      if (R) {
        if (ce.isFunctionDeclaration()) {
          z.push(ce.get("id"));
          continue;
        }
        if (ce.isFunctionExpression())
          continue;
      }
      if (ye)
        for (let he = 0; he < ye.length; he++) {
          const Pe = ye[he], Ne = ce.get(Pe);
          Array.isArray(Ne) ? z.push(...Ne) : Ne.node && z.push(Ne);
        }
    }
    return ae;
  }
  function pe(ne = !1) {
    return this.getBindingIdentifierPaths(ne, !0);
  }
  return Pt;
}
var on = {}, up;
function Od() {
  if (up) return on;
  up = 1, Object.defineProperty(on, "__esModule", {
    value: !0
  }), on.addComment = p, on.addComments = P, on.shareCommentsWithSiblings = o;
  var i = Ze();
  const {
    addComment: l,
    addComments: u
  } = i;
  function o() {
    if (typeof this.key == "string") return;
    const w = this.node;
    if (!w) return;
    const x = w.trailingComments, A = w.leadingComments;
    if (!x && !A) return;
    const g = this.getSibling(this.key - 1), I = this.getSibling(this.key + 1), v = !!g.node, S = !!I.node;
    v && (A && g.addComments("trailing", f(A, g.node.trailingComments)), x && !S && g.addComments("trailing", x)), S && (x && I.addComments("leading", f(x, I.node.leadingComments)), A && !v && I.addComments("leading", A));
  }
  function f(w, x) {
    if (!(x != null && x.length)) return w;
    const A = new Set(x);
    return w.filter((g) => !A.has(g));
  }
  function p(w, x, A) {
    l(this.node, w, x, A);
  }
  function P(w, x) {
    u(this.node, w, x);
  }
  return on;
}
var cp;
function en() {
  if (cp) return er;
  cp = 1, Object.defineProperty(er, "__esModule", {
    value: !0
  }), er.default = er.SHOULD_STOP = er.SHOULD_SKIP = er.REMOVED = void 0;
  var i = Ep(), l = nf(), u = so(), o = Vp(), f = Ze(), p = f, P = ln(), w = pd(), x = fd(), A = md(), g = Hp(), I = bd(), v = Cd(), S = Id(), _ = Ar(), B = _, y = ll(), X = ul(), Z = wd(), J = Od(), G = Up();
  const {
    validate: O
  } = f, ee = l("babel");
  er.REMOVED = 1, er.SHOULD_STOP = 2, er.SHOULD_SKIP = 4;
  const L = er.default = class Qp {
    constructor(N, F) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = F, this.hub = N, this.data = null, this.context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(N) {
      N ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(N) {
      N ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(N) {
      N ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: N,
      parentPath: F,
      parent: ie,
      container: re,
      listKey: Q,
      key: pe
    }) {
      if (!N && F && (N = F.hub), !ie)
        throw new Error("To get a node path the parent needs to exist");
      const ne = re[pe], R = P.getOrCreateCachedPaths(N, ie);
      let C = R.get(ne);
      return C || (C = new Qp(N, ie), ne && R.set(ne, C)), _.setup.call(C, F, re, Q, pe), C;
    }
    getScope(N) {
      return this.isScope() ? new o.default(this) : N;
    }
    setData(N, F) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[N] = F;
    }
    getData(N, F) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let ie = this.data[N];
      return ie === void 0 && F !== void 0 && (ie = this.data[N] = F), ie;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(N, F = SyntaxError) {
      return this.hub.buildError(this.node, N, F);
    }
    traverse(N, F) {
      (0, u.default)(this.node, N, this.scope, F, this);
    }
    set(N, F) {
      O(this.node, N, F), this.node[N] = F;
    }
    getPathLocation() {
      const N = [];
      let F = this;
      do {
        let ie = F.key;
        F.inList && (ie = `${F.listKey}[${ie}]`), N.unshift(ie);
      } while (F = F.parentPath);
      return N.join(".");
    }
    debug(N) {
      ee.enabled && ee(`${this.getPathLocation()} ${this.type}: ${N}`);
    }
    toString() {
      return (0, w.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(N) {
      N || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, q = {
    findParent: x.findParent,
    find: x.find,
    getFunctionParent: x.getFunctionParent,
    getStatementParent: x.getStatementParent,
    getEarliestCommonAncestorFrom: x.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: x.getDeepestCommonAncestorFrom,
    getAncestry: x.getAncestry,
    isAncestor: x.isAncestor,
    isDescendant: x.isDescendant,
    inType: x.inType,
    getTypeAnnotation: A.getTypeAnnotation,
    isBaseType: A.isBaseType,
    couldBeBaseType: A.couldBeBaseType,
    baseTypeStrictlyMatches: A.baseTypeStrictlyMatches,
    isGenericType: A.isGenericType,
    replaceWithMultiple: g.replaceWithMultiple,
    replaceWithSourceString: g.replaceWithSourceString,
    replaceWith: g.replaceWith,
    replaceExpressionWithStatements: g.replaceExpressionWithStatements,
    replaceInline: g.replaceInline,
    evaluateTruthy: I.evaluateTruthy,
    evaluate: I.evaluate,
    toComputedKey: v.toComputedKey,
    ensureBlock: v.ensureBlock,
    unwrapFunctionEnvironment: v.unwrapFunctionEnvironment,
    arrowFunctionToExpression: v.arrowFunctionToExpression,
    splitExportDeclaration: v.splitExportDeclaration,
    ensureFunctionName: v.ensureFunctionName,
    matchesPattern: S.matchesPattern,
    isStatic: S.isStatic,
    isNodeType: S.isNodeType,
    canHaveVariableDeclarationOrExpression: S.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: S.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: S.isCompletionRecord,
    isStatementOrBlock: S.isStatementOrBlock,
    referencesImport: S.referencesImport,
    getSource: S.getSource,
    willIMaybeExecuteBefore: S.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: S._guessExecutionStatusRelativeTo,
    resolve: S.resolve,
    isConstantExpression: S.isConstantExpression,
    isInStrictMode: S.isInStrictMode,
    isDenylisted: B.isDenylisted,
    visit: B.visit,
    skip: B.skip,
    skipKey: B.skipKey,
    stop: B.stop,
    setContext: B.setContext,
    requeue: B.requeue,
    requeueComputedKeyAndDecorators: B.requeueComputedKeyAndDecorators,
    remove: y.remove,
    insertBefore: X.insertBefore,
    insertAfter: X.insertAfter,
    unshiftContainer: X.unshiftContainer,
    pushContainer: X.pushContainer,
    getOpposite: Z.getOpposite,
    getCompletionRecords: Z.getCompletionRecords,
    getSibling: Z.getSibling,
    getPrevSibling: Z.getPrevSibling,
    getNextSibling: Z.getNextSibling,
    getAllNextSiblings: Z.getAllNextSiblings,
    getAllPrevSiblings: Z.getAllPrevSiblings,
    get: Z.get,
    getAssignmentIdentifiers: Z.getAssignmentIdentifiers,
    getBindingIdentifiers: Z.getBindingIdentifiers,
    getOuterBindingIdentifiers: Z.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: Z.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: Z.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: J.shareCommentsWithSiblings,
    addComment: J.addComment,
    addComments: J.addComments
  };
  Object.assign(L.prototype, q), L.prototype.arrowFunctionToShadowed = v.arrowFunctionToShadowed, Object.assign(L.prototype, {
    has: S.has,
    is: S.is,
    isnt: S.isnt,
    equals: S.equals,
    hoist: X.hoist,
    updateSiblingKeys: X.updateSiblingKeys,
    call: B.call,
    isBlacklisted: B.isBlacklisted,
    setScope: B.setScope,
    resync: B.resync,
    popContext: B.popContext,
    pushContext: B.pushContext,
    setup: B.setup,
    setKey: B.setKey
  }), L.prototype._guessExecutionStatusRelativeToDifferentFunctions = S._guessExecutionStatusRelativeTo, L.prototype._guessExecutionStatusRelativeToDifferentFunctions = S._guessExecutionStatusRelativeTo, Object.assign(L.prototype, {
    _getTypeAnnotation: A._getTypeAnnotation,
    _replaceWith: g._replaceWith,
    _resolve: S._resolve,
    _call: B._call,
    _resyncParent: B._resyncParent,
    _resyncKey: B._resyncKey,
    _resyncList: B._resyncList,
    _resyncRemoved: B._resyncRemoved,
    _getQueueContexts: B._getQueueContexts,
    _removeFromScope: y._removeFromScope,
    _callRemovalHooks: y._callRemovalHooks,
    _remove: y._remove,
    _markRemoved: y._markRemoved,
    _assertUnremoved: y._assertUnremoved,
    _containerInsert: X._containerInsert,
    _containerInsertBefore: X._containerInsertBefore,
    _containerInsertAfter: X._containerInsertAfter,
    _verifyNodeList: X._verifyNodeList,
    _getKey: Z._getKey,
    _getPattern: Z._getPattern
  });
  for (const H of p.TYPES) {
    const N = `is${H}`, F = p[N];
    L.prototype[N] = function(ie) {
      return F(this.node, ie);
    }, L.prototype[`assert${H}`] = function(ie) {
      if (!F(this.node, ie))
        throw new TypeError(`Expected node path of type ${H}`);
    };
  }
  Object.assign(L.prototype, G);
  for (const H of Object.keys(i))
    H[0] !== "_" && (p.TYPES.includes(H) || p.TYPES.push(H));
  return er;
}
var pp;
function Nd() {
  if (pp) return os;
  pp = 1, Object.defineProperty(os, "__esModule", {
    value: !0
  }), os.default = void 0;
  var i = en(), l = Ze(), u = Ar();
  const {
    VISITOR_KEYS: o
  } = l;
  class f {
    constructor(P, w, x, A) {
      this.queue = null, this.priorityQueue = null, this.parentPath = A, this.scope = P, this.state = x, this.opts = w;
    }
    shouldVisit(P) {
      const w = this.opts;
      if (w.enter || w.exit || w[P.type]) return !0;
      const x = o[P.type];
      if (!(x != null && x.length)) return !1;
      for (const A of x)
        if (P[A])
          return !0;
      return !1;
    }
    create(P, w, x, A) {
      return i.default.get({
        parentPath: this.parentPath,
        parent: P,
        container: w,
        key: x,
        listKey: A
      });
    }
    maybeQueue(P, w) {
      this.queue && (w ? this.queue.push(P) : this.priorityQueue.push(P));
    }
    visitMultiple(P, w, x) {
      if (P.length === 0) return !1;
      const A = [];
      for (let g = 0; g < P.length; g++) {
        const I = P[g];
        I && this.shouldVisit(I) && A.push(this.create(w, P, g, x));
      }
      return this.visitQueue(A);
    }
    visitSingle(P, w) {
      return this.shouldVisit(P[w]) ? this.visitQueue([this.create(P, P, w)]) : !1;
    }
    visitQueue(P) {
      this.queue = P, this.priorityQueue = [];
      const w = /* @__PURE__ */ new WeakSet();
      let x = !1, A = 0;
      for (; A < P.length; ) {
        const g = P[A];
        if (A++, u.resync.call(g), (g.contexts.length === 0 || g.contexts[g.contexts.length - 1] !== this) && u.pushContext.call(g, this), g.key === null) continue;
        const {
          node: I
        } = g;
        if (!w.has(I)) {
          if (I && w.add(I), g.visit()) {
            x = !0;
            break;
          }
          if (this.priorityQueue.length && (x = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = P, x))
            break;
        }
      }
      for (let g = 0; g < A; g++)
        u.popContext.call(P[g]);
      return this.queue = null, x;
    }
    visit(P, w) {
      const x = P[w];
      return x ? Array.isArray(x) ? this.visitMultiple(x, P, w) : this.visitSingle(P, w) : !1;
    }
  }
  return os.default = f, os;
}
var fp;
function pl() {
  if (fp) return Fs;
  fp = 1, Object.defineProperty(Fs, "__esModule", {
    value: !0
  }), Fs.traverseNode = o;
  var i = Nd(), l = Ze();
  const {
    VISITOR_KEYS: u
  } = l;
  function o(f, p, P, w, x, A, g) {
    const I = u[f.type];
    if (!I) return !1;
    const v = new i.default(P, p, w, x);
    if (g)
      return A != null && A[x.parentKey] ? !1 : v.visitQueue([x]);
    for (const S of I)
      if (!(A != null && A[S]) && v.visit(f, S))
        return !0;
    return !1;
  }
  return Fs;
}
var hp;
function Ar() {
  if (hp) return dt;
  hp = 1, Object.defineProperty(dt, "__esModule", {
    value: !0
  }), dt._call = p, dt._getQueueContexts = H, dt._resyncKey = y, dt._resyncList = X, dt._resyncParent = B, dt._resyncRemoved = Z, dt.call = f, dt.isDenylisted = P, dt.popContext = J, dt.pushContext = G, dt.requeue = L, dt.requeueComputedKeyAndDecorators = q, dt.resync = _, dt.setContext = S, dt.setKey = ee, dt.setScope = v, dt.setup = O, dt.skip = A, dt.skipKey = g, dt.stop = I, dt.visit = x;
  var i = pl(), l = en(), u = ll(), o = Ze();
  function f(N) {
    const F = this.opts;
    if (this.debug(N), this.node && p.call(this, F[N]))
      return !0;
    if (this.node) {
      var ie;
      return p.call(this, (ie = F[this.node.type]) == null ? void 0 : ie[N]);
    }
    return !1;
  }
  function p(N) {
    if (!N) return !1;
    for (const F of N) {
      if (!F) continue;
      const ie = this.node;
      if (!ie) return !0;
      const re = F.call(this.state, this, this.state);
      if (re && typeof re == "object" && typeof re.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (re)
        throw new Error(`Unexpected return value from visitor method ${F}`);
      if (this.node !== ie || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  function P() {
    var N;
    const F = (N = this.opts.denylist) != null ? N : this.opts.blacklist;
    return F == null ? void 0 : F.includes(this.node.type);
  }
  dt.isBlacklisted = P;
  function w(N, F) {
    N.context !== F && (N.context = F, N.state = F.state, N.opts = F.opts);
  }
  function x() {
    var N, F;
    if (!this.node || this.isDenylisted() || (N = (F = this.opts).shouldSkip) != null && N.call(F, this))
      return !1;
    const ie = this.context;
    return this.shouldSkip || f.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (w(this, ie), this.debug("Recursing into..."), this.shouldStop = (0, i.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), w(this, ie), f.call(this, "exit"), this.shouldStop);
  }
  function A() {
    this.shouldSkip = !0;
  }
  function g(N) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[N] = !0;
  }
  function I() {
    this._traverseFlags |= l.SHOULD_SKIP | l.SHOULD_STOP;
  }
  function v() {
    var N, F;
    if ((N = this.opts) != null && N.noScope) return;
    let ie = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && ie.isMethod() || this.key === "discriminant" && ie.isSwitchStatement()) && (ie = ie.parentPath);
    let re;
    for (; ie && !re; ) {
      var Q;
      if ((Q = ie.opts) != null && Q.noScope) return;
      re = ie.scope, ie = ie.parentPath;
    }
    this.scope = this.getScope(re), (F = this.scope) == null || F.init();
  }
  function S(N) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, N && (this.context = N, this.state = N.state, this.opts = N.opts), v.call(this), this;
  }
  function _() {
    this.removed || (B.call(this), X.call(this), y.call(this));
  }
  function B() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  function y() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let N = 0; N < this.container.length; N++)
          if (this.container[N] === this.node) {
            ee.call(this, N);
            return;
          }
      } else
        for (const N of Object.keys(this.container))
          if (this.container[N] === this.node) {
            ee.call(this, N);
            return;
          }
      this.key = null;
    }
  }
  function X() {
    if (!this.parent || !this.inList) return;
    const N = this.parent[this.listKey];
    this.container !== N && (this.container = N || null);
  }
  function Z() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && u._markRemoved.call(this);
  }
  function J() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  function G(N) {
    this.contexts.push(N), this.setContext(N);
  }
  function O(N, F, ie, re) {
    this.listKey = ie, this.container = F, this.parentPath = N || this.parentPath, ee.call(this, re);
  }
  function ee(N) {
    var F;
    this.key = N, this.node = this.container[this.key], this.type = (F = this.node) == null ? void 0 : F.type;
  }
  function L(N = this) {
    if (N.removed) return;
    const F = this.contexts;
    for (const ie of F)
      ie.maybeQueue(N);
  }
  function q() {
    const {
      context: N,
      node: F
    } = this;
    if (!o.isPrivate(F) && F.computed && N.maybeQueue(this.get("key")), F.decorators)
      for (const ie of this.get("decorators"))
        N.maybeQueue(ie);
  }
  function H() {
    let N = this, F = this.contexts;
    for (; !F.length && (N = N.parentPath, !!N); )
      F = N.contexts;
    return F;
  }
  return dt;
}
var ws = {}, dp;
function _d() {
  if (dp) return ws;
  dp = 1, Object.defineProperty(ws, "__esModule", {
    value: !0
  }), ws.default = void 0;
  class i {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(u, o, f = TypeError) {
      return new f(o);
    }
  }
  return ws.default = i, ws;
}
var mp;
function so() {
  return mp || (mp = 1, function(i) {
    Object.defineProperty(i, "__esModule", {
      value: !0
    }), Object.defineProperty(i, "Hub", {
      enumerable: !0,
      get: function() {
        return w.default;
      }
    }), Object.defineProperty(i, "NodePath", {
      enumerable: !0,
      get: function() {
        return p.default;
      }
    }), Object.defineProperty(i, "Scope", {
      enumerable: !0,
      get: function() {
        return P.default;
      }
    }), i.visitors = i.default = void 0, Ar();
    var l = no();
    i.visitors = l;
    var u = Ze(), o = ln(), f = pl(), p = en(), P = Vp(), w = _d();
    const {
      VISITOR_KEYS: x,
      removeProperties: A,
      traverseFast: g
    } = u;
    function I(S, _ = {}, B, y, X, Z) {
      if (S) {
        if (!_.noScope && !B && S.type !== "Program" && S.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${S.type} node without passing scope and parentPath.`);
        if (!X && Z)
          throw new Error("visitSelf can only be used when providing a NodePath.");
        x[S.type] && (l.explode(_), (0, f.traverseNode)(S, _, B, y, X, null, Z));
      }
    }
    i.default = I, I.visitors = l, I.verify = l.verify, I.explode = l.explode, I.cheap = function(S, _) {
      g(S, _);
    }, I.node = function(S, _, B, y, X, Z) {
      (0, f.traverseNode)(S, _, B, y, X, Z);
    }, I.clearNode = function(S, _) {
      A(S, _);
    }, I.removeProperties = function(S, _) {
      return g(S, I.clearNode, _), S;
    };
    function v(S, _) {
      S.node.type === _.type && (_.has = !0, S.stop());
    }
    I.hasType = function(S, _, B) {
      if (B != null && B.includes(S.type)) return !1;
      if (S.type === _) return !0;
      const y = {
        has: !1,
        type: _
      };
      return I(S, {
        noScope: !0,
        denylist: B,
        enter: v
      }, null, y), y.has;
    }, I.cache = o;
  }(Ko)), Ko;
}
var Dd = so();
const yp = /* @__PURE__ */ Zp(Dd);
var It = Ze();
const kd = `
class UniformUIController {
  pane = new Pane({ title: "Shader Uniforms" });

  constructor(persistent) {
    this.persistent = persistent;
    
    if (this.persistent) {
      const savedState = localStorage.getItem("threeUniformGuiPluginState");
      if (savedState) {
        try {
          const parsedState = JSON.parse(savedState);
          this.initialUniformState = parsedState;
          this.currentState = this.initialUniformState
        } catch (err) {
          console.error(err);
        }
      }
    }

    const presets = localStorage.getItem("threeUniformGuiPluginPresets");
    if(presets) {
      this.presets = JSON.parse(presets)
    }
    
    
  }

  setupUI(){
    this.setupCopyConfigButton();
    this.setupUndoRedoButtons()
    this.setupPresets();
  }

  presets = {}

  setupPresets() {
    const presetFolder = this.pane.addFolder({
      title: 'Presets',
      expanded: false
    })

    const PRESETPARAMS = {
      newPresetName: "",
      currentPreset: "",
    }

    presetFolder.addBinding(PRESETPARAMS, "newPresetName", {
      label: "Name"
    })
    
    const btn = presetFolder.addButton({
      title: 'Create Preset',
    });

    const createPresetDropDown = () => {
      const options = Object.keys(this.presets).reduce((acc, value) => {
        acc[value] = value
        return acc
      }, {none: ""})

      const presetDropDown = presetFolder.addBinding(PRESETPARAMS, "currentPreset", {
        options: options
      }).on("change", (e) => {
        if(e.value.trim() === ""){
          this.undoRedoInProgress = true;
          this.currentState && this.applyConfigs(this.currentState)
          this.undoRedoInProgress = false;
          return;
        }
        const configs = this.presets[e.value]
        this.undoRedoInProgress = true;
        configs && this.applyConfigs(configs)
        this.undoRedoInProgress = false;
      })
      return presetDropDown
    }

    let presetOptions = createPresetDropDown()
   

    btn.on('click', () => {
      const newPresetName = PRESETPARAMS.newPresetName;
      if(newPresetName.trim() === "") return;
      const newPreset = this.uniformStateSerializer();
      delete newPreset.Presets
      this.presets[newPresetName] = newPreset;
      presetOptions.dispose()
      presetOptions = createPresetDropDown()
      localStorage.setItem("threeUniformGuiPluginPresets", JSON.stringify(this.presets));
      PRESETPARAMS.newPresetName = ""
      this.pane.refresh()
    });
  }

  setupCopyConfigButton() {
    const btn = this.pane.addButton({
      title: "Copy configs",
    });

    let t;

    btn.on("click", () => {
      if (t) clearTimeout(t);
      btn.title = "Coping...";
      this.pane.refresh();

      const uniformState = this.uniformStateSerializer();
      navigator.clipboard.writeText(JSON.stringify(uniformState));
      btn.title = "Copied!!";
      this.pane.refresh();

      t = setTimeout(() => {
        btn.title = "Copy configs";
        this.pane.refresh();
      }, 1000);
    });
  }

  uniformStateSerializer = () => {
    const paneState = this.pane.exportState();

    const extractValues = (children, accumulator) => {
      return children.reduce((acc, value) => {
        if (value.label) {
          if (value.binding.value?.isColor) {
            const color = {
              r: value.binding.value.r,
              g: value.binding.value.g,
              b: value.binding.value.b,
            };
            acc[value.label] = JSON.stringify(color);
          } else {
            acc[value.label] = value.binding.value;
          }
        }
        if (value.children) {
          acc[value.title] = extractValues(value.children, {});
        }
        return acc;
      }, accumulator);
    };
    const state = extractValues(paneState.children, {})
    delete state.Presets
    return state;
  };

  applyConfigs = (configs) => {
    const paneState = this.pane.exportState();
    
    const applyValues = (children, params) => {
      children.forEach(child => {
        if(child.title !== 'Presets'){
          if(child.binding){
            const value = params[child.label]
            if(child.binding.value?.isColor){
              const colorValue = JSON.parse(value)
              child.binding.value.r = colorValue.r
              child.binding.value.g = colorValue.g
              child.binding.value.b = colorValue.b
            }else{
              child.binding.value = value
            }
          }else if(child.children){
            applyValues(child.children, params[child.title] || {})
          }
        }
      })
    }
    applyValues(paneState.children, configs)
    this.pane.importState(paneState);
  }

  saveTimerId = null;

  undoStack = [];
  redoStack = [];

  undoRedoController = null 
  
  refreshUndoRedoController = () => {
    let i = 0
    this.undoRedoController.cellToApiMap_.forEach((api) => {
      if(i === 0){
        api.disabled = this.undoStack.length < 1
      }else{
        api.disabled = this.redoStack.length < 1
      }
      i += 1;
    })
  }

  undoRedoInProgress = false

  undo = () => {
    this.undoRedoInProgress = true
    const last = this.undoStack.pop();
    const uniformState = this.uniformStateSerializer();
    this.applyConfigs(last)
    this.redoStack.push(uniformState);
    this.refreshUndoRedoController()
    this.undoRedoInProgress = false
  };

  redo = () => {
    this.undoRedoInProgress = true
    const last = this.redoStack.pop();
    const uniformState = this.uniformStateSerializer();
    this.applyConfigs(last)
    this.undoStack.push(uniformState);
    this.refreshUndoRedoController()
    this.undoRedoInProgress = false
  };
  

  setupUndoRedoButtons = () => {
    this.undoRedoController = this.pane.addBlade({
      view: 'buttongrid',
      size: [2, 1],
      cells: (x, y) => ({
        title: [
          ['Undo', 'Redo'],
        ][y][x],
      })
    }).on('click', (ev) => {
      if(ev.index[0] === 0){
        this.undo();
      }else{
        this.redo()
      }
    });
    
    this.refreshUndoRedoController()
  }

  uniformSaveDebounced = () => {
    this.saveTimerId && clearTimeout(this.saveTimerId);
    console.log(this.undoRedoInProgress)
    if(this.undoRedoInProgress){
      const uniformState = this.uniformStateSerializer();
      this.persistent &&
        localStorage.setItem(
          "threeUniformGuiPluginState",
          JSON.stringify(uniformState)
        );
      return;
    } 
    this.saveTimerId = setTimeout(() => {
      const uniformState = this.uniformStateSerializer();
      if(this.currentState){
        this.undoStack.push({...this.currentState});
      }
      this.currentState = uniformState
      console.log(this.undoStack)
      this.refreshUndoRedoController()
      this.persistent &&
        localStorage.setItem(
          "threeUniformGuiPluginState",
          JSON.stringify(uniformState)
        );
    }, 500);
  };

  dispose = () => {};
}

`, Tp = {
  persistent: !1,
  devOnly: !0
  // Default to only work in dev mode
}, Sp = {
  basename: (i, l) => {
    const u = i.split(/[/\\]/);
    let o = u[u.length - 1];
    return l && o.endsWith(l) && (o = o.slice(0, -l.length)), o;
  },
  extname: (i) => {
    const l = i.lastIndexOf(".");
    return l !== -1 ? i.slice(l) : "";
  }
}, gp = yp.default || // @ts-ignore
yp, Gi = {
  log: (...i) => console.log("\x1B[36m%s\x1B[0m", "[three-uniform-gui]", ...i),
  warn: (...i) => console.log("\x1B[33m%s\x1B[0m", "[three-uniform-gui][warn]", ...i),
  error: (...i) => console.log("\x1B[31m%s\x1B[0m", "[three-uniform-gui][error]", ...i)
};
function Ld(i) {
  if (i)
    for (const l of i) {
      const u = l.value.match(/@range:\s*(\{[\s\S]*?\})/);
      if (u) {
        let o = u[1];
        try {
          return JSON.parse(o);
        } catch {
          const p = o.replace(
            /([{,]\s*)([a-zA-Z_]\w*)\s*:/g,
            '$1"$2":'
          );
          try {
            return JSON.parse(p);
          } catch {
            Gi.warn("Invalid uniform range configuration:", o);
            return;
          }
        }
      }
    }
}
function bp(i, l) {
  if (l && It.isStringLiteral(l))
    switch (l.value.toLowerCase()) {
      case "float":
        return "number";
      case "bool":
        return "boolean";
      case "color":
        return "color";
      case "vec2":
        return "vector2";
      case "vec3":
        return "vector3";
      case "vec4":
        return "vector4";
      default:
        return null;
    }
  if (It.isNewExpression(i))
    switch (It.isMemberExpression(i.callee) ? i.callee.property.name : It.isIdentifier(i.callee) ? i.callee.name : null) {
      case "Color":
        return "color";
      case "Vector2":
        return "vector2";
      case "Vector3":
        return "vector3";
      case "Vector4":
        return "vector4";
      case "Matrix3":
        return "matrix3";
      case "Matrix4":
        return "matrix4";
      default:
        return null;
    }
  return It.isNumericLiteral(i) ? "number" : It.isBooleanLiteral(i) ? "boolean" : It.isMemberExpression(i) ? "number" : null;
}
const Os = (i, l) => `{
    let folder = window.uniformPane.pane.children.find(child => child.title === '${i}');
      if(folder){
        ${l}
      }else{
        
      }
    }
  `;
function Md(i, l, u) {
  switch (i.type) {
    case "boolean":
      return Os(
        l,
        `
          if(window.uniformPane.initialUniformState){
            if(window.uniformPane.initialUniformState.${l}?.${i.name}){
              ${i.name}.value = window.uniformPane.initialUniformState.${l}.${i.name}
            }
          }else{
            const uniformState = window.uniformPane.uniformStateSerializer();
            window.uniformPane.currentState = uniformState
          }
          folder.addBinding(${i.name}, 'value', {
            label: '${i.name}'
          }).on("change", () => {
              ${u} && window.uniformPane.uniformSaveDebounced()
          });
      `
      );
    // [All other cases]
    case "number":
      const o = i.range ? Object.entries(i.range).filter(([P, w]) => w !== void 0).map(([P, w]) => `${P}: ${w}`).join(`,
            `) : "step: 0.01";
      return Os(
        l,
        `
          if(window.uniformPane.initialUniformState){
            if(window.uniformPane.initialUniformState.${l}?.${i.name}){
              ${i.name}.value = window.uniformPane.initialUniformState.${l}.${i.name}
            }
          }else{
            const uniformState = window.uniformPane.uniformStateSerializer();
            window.uniformPane.currentState = uniformState
          }
        folder.addBinding(${i.name}, 'value', {
            label: '${i.name}',
            ${o}
          }).on("change", () => {
              ${u} && window.uniformPane.uniformSaveDebounced()
          });
      `
      );
    case "color":
      return Os(
        l,
        `
          if(window.uniformPane.initialUniformState){
              if(window.uniformPane.initialUniformState.${l}?.${i.name}){
                const color = JSON.parse(window.uniformPane.initialUniformState.${l}.${i.name} )
                ${i.name}.value.setRGB(color.r, color.g, color.b) 
              }
          }else{
            const uniformState = window.uniformPane.uniformStateSerializer();
            window.uniformPane.currentState = uniformState
          }
          folder.addBinding(${i.name}, 'value', {
              label: '${i.name}',
              view: 'color',
              picker: 'inline',
              color: {type: 'float'},
          }).on("change", () => {
                ${u} && window.uniformPane.uniformSaveDebounced()
          });
        `
      );
    case "vector2":
    case "vector3":
    case "vector4":
      const f = i.type === "vector2" ? ["x", "y"] : i.type === "vector3" ? ["x", "y", "z"] : ["x", "y", "z", "w"], p = i.range ? Object.entries(i.range).filter(([P, w]) => w !== void 0).map(([P, w]) => `${P}: ${w}`).join(`,
              `) : "step: 0.01";
      return Os(
        l,
        `
          const ${i.name}Folder = folder.addFolder({
            title: '${i.name}'
          }) 
          
          ${f.map((P) => `
              if(window.uniformPane.initialUniformState){
                if(window.uniformPane.initialUniformState.${l}?.${i.name}){
                  const value = window.uniformPane.initialUniformState.${l}.${i.name}
                  ${i.name}.value.${P} = value.${P}
                }
              }else{
                const uniformState = window.uniformPane.uniformStateSerializer();
                window.uniformPane.currentState = uniformState
              }
            ${i.name}Folder.addBinding(${i.name}.value, '${P}', {
              label: '${P}',
              ${p}
            }).on("change", () => {
              ${u} &&  window.uniformPane.uniformSaveDebounced()
            });
          `).join(`
`)}
        `
      );
    case "texture":
      return Os(
        l,
        ` const ${i.name}Params = {
              file: "",
            }
            const ${i.name}Folder = folder.addFolder({
              title: '${i.name}'
            });
            ${i.name}Folder.addBinding(${i.name}Params, "file", {
              view: "file-input",
              lineCount: 3,
              filetypes: [".png", ".jpg"],
              invalidFiletypeMessage: "We can't accept those filetypes!",
            })
            .on("change", (ev) => {
              if (!ev.value) {
                return;
              }
              const imageFile = ev.value;
              const blobUrl = URL.createObjectURL(imageFile);
              const texture = new THREE.TextureLoader().load(blobUrl);
              ${i.name}.value = texture;
              ${u} && window.uniformPane.uniformSaveDebounced()
            });`
      );
    default:
      return "";
  }
}
function Kd(i) {
  const l = typeof i == "boolean" ? { ...Tp, persistent: i } : { ...Tp, ...i };
  return Gi.log("Options:", l), {
    name: "three-uniform-gui",
    enforce: "pre",
    apply: (u, { command: o }) => !(l.devOnly && o !== "serve"),
    transform(u, o) {
      if (o.match(/\.[jt]sx?$/)) {
        Gi.log("Processing file:", o);
        try {
          const f = ef.parse(u, {
            sourceType: "module",
            plugins: ["typescript", "jsx"],
            comments: !0,
            attachComments: !0
            // Enable comment parsing
          }), p = [];
          let P = !1;
          const w = f.comments || [];
          if (gp(f, {
            VariableDeclarator(v) {
              if (It.isCallExpression(v.node.init) && It.isIdentifier(v.node.init.callee) && v.node.init.callee.name === "uniform" && It.isIdentifier(v.node.id)) {
                const [S, _] = v.node.init.arguments;
                let B = bp(S, _);
                if (!B && It.isIdentifier(S)) {
                  const y = v.scope.getBinding(S.name);
                  if (y && y.kind !== "module" && It.isVariableDeclarator(y.path.node) && y.path.node.init) {
                    const X = y.path.node.init;
                    B = bp(X);
                  }
                }
                if (B && v.node.end) {
                  const y = v.node.start || 0;
                  let X;
                  for (let G = w.length - 1; G >= 0; G -= 1) {
                    const O = w[G];
                    if (typeof O.end == "number" && O.end <= y) {
                      const ee = u.slice(O.end, y), L = (ee.match(/\n/g) || []).length;
                      if (/^[\s;]*$/.test(ee) && L <= 1) {
                        X = O;
                        break;
                      }
                      if (L > 1) break;
                    }
                  }
                  const Z = [
                    ...X ? [X] : [],
                    ...v.parent.leadingComments || [],
                    ...v.node.leadingComments || []
                  ], J = Ld(Z);
                  p.push({
                    name: v.node.id.name,
                    type: B,
                    position: v.node.end,
                    range: J
                  });
                }
              }
              It.isIdentifier(v.node.id) && It.isCallExpression(v.node.init) && It.isIdentifier(v.node.init.callee) && v.node.init.callee.name === "texture" && v.node.end && p.push({
                name: v.node.id.name,
                type: "texture",
                position: v.node.end
              });
            },
            //@ts-ignore
            ImportDeclaration(v) {
              v.node.source.value === "tweakpane" && v.node.specifiers.some(
                //@ts-ignore
                (S) => (
                  //@ts-ignore
                  It.isImportSpecifier(S) && S.imported.name === "Pane"
                )
              ) && (P = !0);
            }
          }), p.length === 0) {
            Gi.log("No uniforms found in file");
            return;
          }
          const x = Sp.extname(o), A = Sp.basename(o, x);
          Gi.log("Found uniforms:", p), p.sort((v, S) => S.position - v.position);
          let g = u, I = 0;
          return gp(f, {
            //@ts-ignore
            ImportDeclaration(v) {
              const S = v.node.end || 0;
              I = Math.max(I, S);
            }
          }), p.forEach((v) => {
            const S = Md(
              v,
              `uniform_${A}`,
              l.persistent
            );
            g = g.slice(0, v.position) + `;
` + S + g.slice(v.position);
          }), g = g.slice(0, I) + `
          if (!window.uniformPane) {
            ${kd}
            window.uniformPane = new UniformUIController(${l.persistent});
            window.uniformPane.pane.registerPlugin(TweakpaneEssentialsPlugin);
            window.uniformPane.pane.registerPlugin(TweakpaneFileImportPlugin);
            window.uniformPane.setupUI()
          }
          
          let folder = window.uniformPane.pane.children.find(child => child.title === 'uniform_${A}');
          if (folder) {
            folder.dispose();
          }

          window.uniformPane.pane.addFolder({ title: 'uniform_${A}'})

          ` + g.slice(I), P || (g = `
            import { Pane } from 'tweakpane';
            import * as TweakpaneEssentialsPlugin from '@tweakpane/plugin-essentials';
            import * as TweakpaneFileImportPlugin from 'tweakpane-plugin-file-import';
          ` + g), Gi.log("Successfully transformed file"), {
            code: g,
            map: null
          };
        } catch (f) {
          return Gi.error("Error processing file:", f), null;
        }
      }
    }
  };
}
export {
  Kd as default
};
